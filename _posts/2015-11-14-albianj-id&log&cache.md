---
layout: post
categories: [Albianj,java]
title: "腾讯文学内容中心分布式统一框架的设计与实现--id生成器、日志与缓
存"
tags: [ALbianj,java]
---


####分布式锁服务

在albianj的设计中，分布式锁服务是从开始就被认为是一个极其重要的主键。
但是因为业务实际情况，导致了在整个系统中，发生资源抢占的情况并不突出，
可以说是几乎不存在，这是特殊业务导致的，并不是albianj本身的问题。
但是我们也确实考虑了分布式锁服务的机制，并且认为还是很有必要实现它，以
保证在一些极端的情况下，数据仍然保持绝对的一致性。我们将会在下一篇的文章中详细的
论述我们的分布式锁服务的构建，这块和分布式存储一样，是一个单独的组件，
详细请查看分布式锁服务的文章。

####对象唯一ID生成器

albianj作为在分布式系统场景下使用的一个基本开发框架，id生成器也是一个
必备的功能。作为一个在分布式系统这个特定条件下的说使用的id，这个id必须
满足几个特点：

1. id必须唯一，这个好像是废话，但是确实是id的最主要的功能；

2. id必须要自带业务功能，必须要做到“望文生义”，必须看见id就能知道这个
id所表示的意思；

3. id必须是可以有一定的规律的，这个规律id生成器能自己实现最好，如果这
个规律有很强的业务性质，id生成器无法实现，那么也要流出空余的槽位；

4. id必须能明确的携带它的生成信息，以方便发生问题时第一时间定位现场；

5. id必须满足业务和数据存储的需要，必须要在合理的范围内生成；

根据上面的几点，albianj一共设计了3种id生成器，一种生成的id是给log
使用的，这部分会在log部分中详细说明。剩下的2种id生成器一种是albianj自
带的，它所生成的id是一个32位长的字符串；另外一种是一个单独的由c写成的
服务，它所生成的id是一个int64的值。

字符串的id直接由albianj生成，它依赖albianj自带的kernel属性文件，位
于config目录下。这个字符串由4部分组成：

4位长的machineid-7位长的appname-14位长的时间（精确到秒）-4位长的随机数

对于machineid和appname来说，它们如果长度长于规定的值将会被截取，如果长
度长于规定的值，会在左边进行pad操作。这样，albianj就可以保证控制生成的
id一定是32位的长度。这个生成的字符串起初被设计用来作为对象在数据库中的
字段，因为字符串的扩展性和自定义性实在太好了，他的诱惑实在太大，但是当
用字符串作为主键的时候，引起的性能问题也相比int会慢好几倍，所以最后
albianj放弃了用字符串作为对象唯一标识的做法，但是这个id被用在了job上，
他被用来标识job，让job在整个系统中唯一，并且也被用来处理当系统发生异常
的时候，让运维可以快速的通过id定位事发现场，进行进一步的处理。

我们在albianj真正用来做对象唯一标识的是int64的整数型id。整数的id相对于
字符串来说肯定是能快上好几个数量级的，特别是在索引筛选的时候。所以
albianj最后选择了用这个方案来解决对象唯一性问题。

整数型的id也采用了2种方式。一种是二进制按位移动构建的，另外一种是10进
制，采用乘法的方式实现的。二进制的方案是实现简单，保证不会溢出，但是程
序易懂人类难理解。10进制的方法实现也简单，但是如果保证不溢出的话需要精确
的计算，还有一个是逼格不够高，总是觉得有点土，但是好处是人类能看懂，而
且很容易的就能分辨出来。不管是二进制还是十进制，他们的实现思想都是一样
的，就是按照位数进行左移。

一个数由4部分组成：时间戳、生成id的machineid、id的类型、随机数
。二进制的数前32位是时间戳，接着8位是machineid，然后是10位的类型，最
后是10位的随机数。而十进制的组成是按照真实的数据位来划分的，真实的数据
位就是十进制为一位，而十进制为了规避int64的最大值问题，还必须要舍去掉
最高的一位，所以一共就只有19位，而又因为兼容原来的数据类型而不至于更改
所有的数据库表，所以我们的id还是能带符号的，这样就被减少了一位，所以一
共就只有18位可以供使用。所以十进制的id是：32位二进制的时间戳转换成十进
制后左移（这里是直接按照十进制移动，而不是二进制，下同）9位，然后接3位
machineid的值左移6位，再接4位随机数左移2位。最后的2位空出来是为了给程
序自定义数据路由使用。这里没有type对吧？因为在我们的系统中，有明确对象
类型的对象才会使用十进制数的id来区分，id生成器已经最后空出来了2位，就
是给开发者自己标注使用的，所以这里的十进制id是没有显式的加入type信息的，
因为对我们的业务来说，这些type都是已经被定义并且被固定的。而且也不用担
心id会重复的情况，不一样的type会使用不同的id随机数槽进行计算，就算在单
位时间内生成同样的两个id，也因为type的不同，他们不会被保存在同一个数据
库中作为同一个类型对象的主键，所以并不冲突。但是为了后期在使用上有
更大的自由使用幅度，albianj的id生成器也有一种后4位递增的规则id，以保证当业
务需要使用hash或者是取模运算做数据路由的情况，这种情况还在id中加入了
type的值。

为了更好的数据库性能，albianj的id生成器生成的id都是自增的，但是它
并不保证在相对狭小的时间内递增，而是保证在一大段的时间内单调递增，这个
一大段的时间可以确立在1s-2s这个时间段。这也就是说并不能把id生成器生成
的id用来做时间向量。但这并不会极大的影响数据库的性能，
从理论的角度出发，可能会让数据库的索引有分页，断页的操作，但是从实际的
情况来看，基本上对于数据库的影响是没有的，所以可以放心大胆的这样设计和
实现。

在设计的时候，albianj的id生成器是接入nameservice，使用nameservice来保
证id生成器的高可用性，但是在实践的过程中，发现其实id生成器主要依赖的仅
仅是一个时间戳，albianj可以把生成的id看成是一个时间向量，而id生成器服
务是一个无状态的服务，所以最后albianj放弃了原来接入nameservice的计划，
而是使用了平行部署+负债均衡的方式来实现了id生成器的高可用性。

albianj实现id生成器的时候采用了短链接的方式，也提供了长连接的方式，但
是默认和推荐使用短链接。这是和我们现实的环境有关的，albianj面对的服务
器集群有可能是跨机房部署的，在大内网内，长连接相对短链接来说不是那么的
稳定，使用短链接可以有更高的健壮性和可用性的保障。

为了更好的使用id生成器，也为了兼容现实中正在使用的多语言情况，albianj
还给id生成器集成了一个restful服务，通过restful服务，可以满足所有站点对
于唯一id的需求，也大大的方便了隐藏后面的id生成器集群。

####log系统

作为一个要在分布式系统中运行的框架，日志系统是一个必备的功能。不管是开
发人员还是运维人员，但系统出现问题的时候首先是由监控系统发现，但是监控
系统一般只能是发现问题，并不能诊断问题的原因，这时候就需要日志来帮忙。
日志：它是系统在线上运行时的黑匣子，通过日志往往可以救我们一命。

albianj的日志还结合了异常处理系统。对于抛出问题的异常，albianj会详细的记
录堆栈信息，以便后期的维护和检查使用。albianj也顺带解决了可能的信息泄
漏问题，类似于java中经典的tomcat抛出的带有内存信息的提示信息和c#报出的
“黄页”。albianj解决这个问题的方式是使用2种不同的方言来分别给出信
息.当发生异常或者是发生错误的时候，albianj定义了一个总体的、模糊的、概
述性的信息以提供给用户，而会把详细的堆栈信息记录到我们的日志系统。两者
之间通过使用上文讲到的id生成器生成的id和一些干扰的id作为关联，以方便运
维人员方便的定位到底是哪台服务器出了问题。albianj并没有使用类似于linux中
的errno的机制来逐个的定义错误，这是因为errno实在太难控制和管理，随着时
间的推移，项目需求的增长，团队的各种变迁，最后如果使用使用errno，首先
得有一个相关的冗长的文档来解释，其次是必须再专门派一个人去维护整个文档
和所有的errno的定义。而这里说出现的异常信息或者是错误信息，作为客户并
不需要具体的出错原因，而只是仅仅可以在报告错误的时候能有一个标识，而对
于系统来说，根据这个标识就可以查找到日志，这样就可以获取出错的信息，仅
此而已。而对于如果是相同的异常或者错误，使用类型或者是通过出错的地点就
可以知道是不是同一个异常，所以根本没有必要用类似于errno这样的重型机制
来解决异常和错误的问题。  

albianj的log基于log4j实现，这样做的好处是大大的方便和节省了很多代码量
的开发，第二个好处是log4j几乎实现了所有的日志可能发生的记录行为。这两
点满足了albianj对于系统的需要。当albianj启动的时候，就会去建立日志文件，
当日志增大到一点的size后就会被切分到另外一个新建立的日志文件。建立的文
件名上都有新建的时间点，以便查找的时候可以尽可能方便的定位。

目前因为人手的问题，albianj的日志还是散布在各自的服务器上的，这给日常
的运维带来了一些额外的工作，并且也并不是那么的智能化和自动化。后期，我
们将会设计和开发一个logdb。logdb不仅仅会统一而集中的收集和管理各种日志，并且允许
在收集日志的时候加入需要的一些特殊业务。logdb已经在考虑之中，后续会有
logdb的文章被推出来。

####缓存系统

在现在的互联网企业，几乎没有一家敢说自己可以不用缓存，我们当然也不例外。
在设计和构建albiaj的时候，也把对缓存系统的支持作为一个必不可少的组件加
以了考虑，作为albianj一贯要求的标准，在实现albianj对于缓存支持的同时，
尽可能的做到albianj所强调和坚持的一致性原则。经过努力，albianj不但把对于
缓存的支持实现了，而且还做到了对于开发者来说绝对的一致性和未曾强调的一
键使用。

在现今的互联网大环境下，缓存最大的使用场景就是在数据库之前架设，用来把
相同请求的数据暂存在内存中，然后在单位时间内或者是某事件未触发的情况下，
供客户端请求，以减少客户端大量的并发请求被直接发送到数据库，导致数据库
扛不住压力而down机。在albianj中，缓存主要的用处也是在于缓存数据库的数
据，减少对于数据库的请求。但是albianj并不会牵涉到缓存层的物理部署，也
不会直接实现缓存，而是作为一个客户端来使用缓存。

albianj主要支持的是分布式的redis。albianj内置了redis的客户端，并在
redis的客户端上进行了二次开发，以让albianj满足对于缓存的需求。albianj
的缓存依赖于config中的cached.xml配置文件，在这个配置文件中，可以配置
redis的服务器信息，也可以配置redis的部署情况信息，albianj都会对此加以
支持。但是albianj并不支持redis的集群功能。这是albiaj使用缓存的出发点决定
的。albianj只是使用缓存作为一个缓冲，而并不是拿来做存储，虽然redis也有存
储的功能。所以这部分数据的定位应该是易失且可失数据，不存在也不会干扰程
序的正常运行，如果要做高可用，一个多主+各主一个master就可以实现了，如
果需要合理的利用各台机器，那么就必须要重新在客户端层再增加一个负载均衡
层，使用算法执行多写主操作，现在有开源的组件可以使用，但是相对来说代价
有点大，所以albianj只使用最小的功能就可以满足albianj对于缓存的需要。

在albianj中，最大的需求就是在ORM中缓存数据。albianj在persisten.xml中增加
了一个cached的配置节，可以通过这个配置节让albianj接管的对象打开缓存功
能，开发者借助这个配置节就可以让albianj自动的实现缓存功能。ORM在使用缓
存的时候因为是要发生网络连接、发送数据等等步骤，所以ORM中集成的缓存功
能被设计了异步执行。从而可以不用担心对于主流的业务造成影响。

还有一种情况是开发者必须要自定义缓存，可能存储的不是直接从ORM中取出的
数据，而是已经经过业务加工的数据。那么albianj也考虑到了这点，albianj也
暴露了直接操作缓存的接口，以供开发者实现自己的缓存目的。

albianj还支持本地缓存，然后本地缓存一般不推荐使用。本地缓存经常会越用越大，
内存也容易溢出。但是albianj还是设计并且实现了它。使用LRU机制对于本地缓
存进行了瘦身处理，还规定了缓存的最大大小来强制性的约束缓存的使用。
albianj实现本地缓存的主要目的是给albianj本身自己用的。在albianj中，由
于实现的需要，中间存在很多的反射等调用。每次调用反射都是一件很浪费性能
的事情，所以我们需要使用本地缓存把这些信息缓存起来。而这些信息又不大，
远远小于内存溢出的阀值，也远远小于我们定义的缓存的最大大小。所以
albianj可以安全的使用本地缓存来给自己提供性能上的提升。

总的来说，albianj不是真正的去实现一个缓存服务器，而是将目前大家都使用
的缓存服务集成到albianj内部，以供其使用。albianj的缓存集成既可以实现对
于自身功能的需求，又对开发者提供了一致的接口，并且透明化的处理，而且还
未定制化暴露了接口。从albianj的一站式定位来说，缓存的集成再次体现了
albianj所强调的统一化。
