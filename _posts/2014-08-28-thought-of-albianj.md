---
layout: post
categories: [arch,albianj]
title:  "albianj架构和设计的一些想法"
tags: [arch,java,albianj]
---

####albianj是什么？  
其实albianj是一套框架，它主要就是解决互联网公司经常碰到的对于大量数据和高并发
情况下，数据库压力无法解决的问题。它主要由IOC+ORM组成，但是和spring和hbm不一样
，albianj没有那么重，相比简直就是非常轻。albianj就是解决实际问题出现的，并不是
由论文或者假象情况实现。  
####albianj的出现
大概是在11年，那个时候我在ctrip，在7月份的时候有个前同事和我创业的事情。当时是
做奢侈品电子商务，然后他们缺一个技术负责人，想加上我一起。然后我们见了一下面，
聊了一下关于技术的那部分事情，后来回家后，秉承有备无患的原则，我开始了albianj
的开发工作，其实albianj是albian的java版本，它还有一个c#版本，但是因为原来的公
司已经有框架的原因，c#版本的没有怎么使用，但是java版本倒是在今年的公司内使用了
，主要用在了日志存储这一块上。  
需要说明的是，我并不是在重复的造轮子。我知道，并且大家也都知道，在java程序
中你可以说什么都缺，但是唯独开源框架那是肯定不会缺的，在java世界中，框架级的程
序如果你有心排列一下，足以排满整个黄浦江了。那为什么还要写albianj呢？因为我不
想交那么多的复杂税。  
举个例子：spring中，更加论文描述，DI的方式有几种？据我已经退化的记忆力，好像是
三种：继承、参数和还有一种忘记了。但是你真正在程序中经常使用的（注意，是经常使
用的）有几种？99.9999%的人只会使用一种。如果你的程序用了2种或者以上，那么你的
维护者看见你的程序就会骂娘。相信我，这是真的。  

<!-- more -->
####我们碰到的实际问题
首先，我们得假设一下：有一个电子商务网站，每天的pv大概在1kw以上，交易额在2kw以
上，有百万甚至千万级用户，有几百台甚至1k台以上的服务器。那么这种情况下，我们会
得到哪些信息？  
1. 压力巨大!不管是web服务器还是db服务器，压力都很大，对不对？  
2. 单机模式肯定是搞不定了，必须要使用分布式的架构了。  
3. 如果搞分布式，怎么解决数据的一致性问题？怎么解决跨库跨表的事务问题？  
4. 机器很多，好像管理这些机器就是一个很大问题？更不要说如果程序出了问
题，假设某个单子除了问题，查找这个问题，查找现场也是一个很大的挑战。  
5. 要维护这个网站，技术人员肯定要100人以上，怎么解决这些人在技术上能步调一致？  
6. 比步调一致更难解决的是，对于开发人员来说，怎么解决分布式架构的透明问题？  
......  
其实还有很多很多的问题需要解决，我们不迷信一个框架或者一个技术就能解决那些问题
，但是至少我们可以期望，一个框架或者一种技术可以缓解这些问题造成的麻烦。
PS：不要怀疑上面对于网站的假设，其实很多网站都差不多这个级别，比如5173，京东，
等等，我相信上面碰到的问题，他们都已经碰到了。5173肯定碰到了，因为我待过。  
####albianj提供的解决办法和思路
1. 首先得解决压力大的问题。压力大在网站上表现为2种：web和db。  
>web相对来说还是好解决的。一把只要机器足够，基本上就没问题。如果你们公司有钱，
那么可以买F5来做负载均衡；如果是创业公司或者穷逼公司或者是技术巨牛，那么可以使
用LVS来解决负载均衡。但是从程序的架构上来说，不是一个负载均衡就能解决所有问题
的，一个典型的问题就是：怎么解决数据唯一性问题？比如说你有一个物品可以卖，但是
不巧它只有最后一件了，这个时候有n（n>=2)个人同时来买这个物品，因为你有多台web
服务器，所以这n个人不是被分配到一台web上的，这个时候你怎么办？一般的做法就是引
入一个分布式锁功能，比如zk，它就可以完成这个功能。可以让一个物品在同一时刻，整
个站点内只有一个人可以去操作，那么是谁最后买到呢？这就是比谁手快。还有人说，我
准备放到DB层去解决，我对DB层做一个事务锁定，然后就可以了。这样不是不可以，并且
做了分布式锁之后对于DB不是就不用事务锁了，而是你这样会对DB产生很多的无效压力操
作，导致DB无效的操作过多，在本身就已经捉襟见肘的DB压力上还要加把盐。  
</br>
>web相对于db还是好解决的。真正考验的地方是DB。这其实病不是我们的错，而是对于
RDB来说，它从娘胎里出来就自带了单点的特性。具体可以去查一下CAP原则。要不然现阶
段NOSQL怎么会那么火？其实NOSQL不应该被叫做NOSQL，更确切的，叫做NORDB跟合适。对
于DB来说，卸载压力的方式也是唯一方式就是缓存。那么解决大数据的方式也是唯一的方
式就是"分",一般叫做分库分表。但是分库分表就会导致一个问题，数据完整性怎么解决
？这也是DBA听到你说要分库分表的时候，第一个要问你的问题。当然，具体怎么分，这
个得看你的业务具体决定，但是你得知道有这种方法，并且能提供一个一致的方法来解决
这个问题，albianj就使用了多阶段提交来完成解决这个问题。多阶段提交，其实就是每
个库都会有自己的事务在albianj中称之为task，然后整个DB操作就是一个job，对于一个
job来说，它可以有多个task构成。这样只有当每个task被db接受后，整个job才算成功，
中间只要有一个task不成功，那么整个job就不成功，所有的task全部被回滚。注意这部
分对于程序员来说都是透明的，程序员和往常一样只要调用albianj的save方法就可以保
存数据了，唯一需要程序要要做的就是写一个callback，以在job失效的时候处理数据的
完整性.  

2. 事务的完整性有了保证后，我们开始解决大数据造成的DB压力问题。对于海量数据来
说，我们没有什么更好的办法来解决它说带来的压力。毕竟那部分数据是我们必须要存储
的，所以在手段上我们显得有点捉襟见肘。但是一般来说，分摊压力最主要的就是要"分
"，不管你怎么样，当单一的数据库或者单一的表不能解决问题的时候，你唯一的选择就
是把他们分开。分开的方式有很多。教科书上一般说是有2中：水平和垂直。但是偶只推
荐水平切分。垂直切分不是不行，但是你想想，在数量一定的情况下，也就是说PK数量一
定的情况下，速度会快吗？所以，水平切分，把当个库或者单个表的数量变小，这样才能
根本上去解决这个问题。水平切分的方法有很多，比如按照时间，按照物品的属性等等。
这些都可以，唯一的要求就是根据你的实际业务出发，看怎么切分方便那就怎么来。对于
albianj来说，它当然不能提供给你一个分库分表的完整功能，但是它在它的ORM中集成了
该功能，在albianj中叫数据路由。具体的路由方法由开发者提供，albianj只负责更加开
发者提供的路由算法来操作数据库。并且这部分对于开发人员来说是半透明的，开发者提
供的只是一个AlbianObject，必须实现IAlabianObject接口，或者继承FreeAlbianObject
（吐血推荐），然后完成你的HashMapping，并且在配置文件中配置一下你的HashMapping
，使它在job context中生效，这样就完成了最头疼的分库分表功能。AlbianObject不仅
仅支持分库分表，还支持读写分离、单一对象多备份存储等等功能，并且同时还解决了单
一对象多存储的版本问题。  

3. 最棘手的2个问题解决了，下面我们来解决机器过多问题。当程序复杂并且部署在大量
机器上的时候，如果其中的一个单子出了问题，维护人员要去找到这个单子的现场，那就
像实在大海中捞针一样了--完全凭运气。但是我们还是有办法来解决这个问题的。
albianj采取的做法是"业务化每个操作",看上去很高深。其实说白了就是业务化自定义主
键。每一个操作，最后对应到数据库中都是一条记录。那么如果我们某个操作发生了问题
，我们当然可以知道它的ID，然后更加ID可以追溯到这个操作实在那台机器上发生的，发
生的时间，发生的业务站点，等等。albianj有一个唯一性ID生成器，只要开发真调用这
个ID生成器来生成ID，并且把数据库中的主键设置成这个ID就能解决在大海中捞针的问题
。并且因为ID带有业务属性，所以仅仅依靠这个ID就能解决一大半的数据路由问题。  

4. 下来要解决的是机器问题。上面说到了ID具有业务的属性，并且能知道案发现场，那
么要做到这个功能，必须要把机器的ID附带到唯一性的ID上。所以我们给albianj的所有
的机器都一个全站唯一性的kernelID，这个ID唯一标识了该机器或者该进程在整个abianj
中的位置。管理这个kernelID的机器在abianj中被称之为albianj-mgr，在albianj启动的
时候，会去mgr机器上去验证一下该kernelid是否已经被使用，如果已经被使用，将不允
许该albianj实例启动，这样就能确保kernelID在整个albianj系统中的唯一，也能保证每
个ID在整站中的唯一。  

5. 最后要解决的问题就是对于开发者来说怎么让albianj符合KISS原则。在整个albianj
设计和开发时候，我一直在做减法。最明显的是把DI的方式从3种减到1种，对于ORM，只
要一个简单的table-object的mapping，不再增加任何额外的功能，比如导致n+1问题的
lazy-load等等。这些问题在互联网开发中其实并不实用，就算我妥协加入了，最后也会
是为了性能考虑把这个功能禁止掉。所以这个局面的情况下还不如直接砍掉。对于一个大
型的软件架构，要保证一致性，唯一的办法就是少做。最好是什么都不做，0对任何人来
说都是0，但是如果是1，那么对于n个人来说就会有n个1的意义，A认为他是一个人，B认
为他是一条路，这样直接导致每个人对于作者要表达的意思各有见解。如果是2甚至是3，
那就是n个数量级的问题了。所以在架构上，你当然不能什么都不做，你唯一要做的是，
一件事情永远只有一条路能做到，最多为了便利性或者某些妥协变成2条路，但是永远不
能秉承"条条道路通罗马"的原则，否则到后面，你就会失控。  

####albianj以后要做的事情
1. 个人觉得zk的性能不怎么样，所以可能会增加一个分布式锁的服务；  
2. 必须增加一个mgr服务，这样albianj就真正能在分布式环境下使用；  
3. 可能需要对于AlbianObject增加一个版本控制；  
4. 增加一个配置服务，这是一个7*24应用必须具备的；  
