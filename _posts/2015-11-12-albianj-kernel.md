---
layout: post
categories: [Albianj,java]
title: "腾讯文学内容中心分布式统一框架的设计与实现--架构与kernel"
tags: [ALbianj,java]
---
####架构
在设计albianj之初，其实并没有一个非常明确的对于架构的标准。我们一
致的认为架构的设计实现与架构的层次类别区分并不是由某些理论或者是某篇论
文或者是某个观点来进行的，而是在真正的实现过程中，随着功能点的增加和实
现的代码逐渐的增多，会自然而然的去对整个的系统进行审视和调整，这部分的
工作会一直循序渐进的继续下去，永远不会停止下来。

到目前为止，albianj已经演化成了具有8个子功能集的大架构。它们之间
并无复杂的依赖关系，除了简单的依赖于同一个kernel以外，别的所有的依赖都
是按需而定的。

<center>
![all](/img/albianj/all.jpg)
</center>
</br>

在框架开发发展了这么多年的今天，对于一个框架来说，寻找一个架构上标新
立异的机会几乎不可能了。而不同在于在使用的便捷性和框架的设计出发点。albianj主要面
向的就是互联网的开发，这是一个基本的立足点。所以，albianj框架首先
不会是大包大揽的功能性集合，对于一些互联网不会用到的功能一律的进行
生删减，但是对于关心的问题，albianj也结合我们自己的实际情况和需求解决
掉了。从而分门别类划分的这几个功能性子集基本上已经代表了albianj所能精简
的极限了。下面会依次的对这些功能性子集做出解释，并且对于没有被albianj
选择的可能的选型做出取舍的原因。

####kernel
作为整个albianj的核心，它有2部分组成。一部分是albianj基本上都需要
用到的公共功能；另外一部分也是albianj都需要用到的，并且是更加重要的、
满足我们对于管理service需要的ioc功能。

先说公共功能。这部分包括了很多的功能性的封装，包括但是不仅仅局限于hash
算法、输出型参数、日期操作、网络基本接口、反射基本接口、运行时栈信息、
加密解密安全、数据验证接口、xml解析等功能。他们是所有的albianj功能集可
能会使用到的，但是我们又无法给他们分开归类的功能。我们把这些功能统一的
放到kernel下面的公共功能集下面，以供albianj使用。

这部分的功能对于albianj的使用者来说，也可以被直接拿来使用，但是更多的时
候，除了验证机制以外，别的功能基本上都不太用得着。所以对这个功能包不清楚或者不
知道它的存在并不影响合理的使用albianj。

对于ioc功能来说，这是整个albianj的核心。其二，对于使用albianj作为开发
框架的业务系统来说，也是它们的核心。ioc都是提供了一个控制反转的功能。
将我们的接口和实现分开，然后根据自己的需要加载实现。传统的ioc（比如
spring）会有n多种的注入方式，初始化参数、接口、属性等等。但是
albianj仅仅使用一种方式：接口方式。选取这个方式的主要原因有以下几个方
面：

1. albianj认为提供多种的注入方式会引起代码的混乱和配置的文件的复杂度，对
   于可维护性来说，过多的解决方案可能会适得其反。当有多个同事同事使用
多种方法时，虽然它们的方法方案被限制在一个框架内，相互之间还是会增加
   学习成本，维护成本；

2. 选择接口注入的方式是因为albianj需要对于service进行控制。在比较了一些注
   入方式后，接口注入是最适合albianj的一种方式。为了更好的管理
   各个service和以后的扩展（这会在下一点中有详细说明），albianj必须要干扰
   service的初始化和使用过程。albianj需要给每个service标注它的生命周期，
   已提供包括惰性加载之类的各种功能；

3. 上面讲到以后的扩展。对于albianj来说，目前的service都是在本地运行的，
   不会出现remoting的调用，也不会出现微服务的模式。但是互联网的世界瞬
   时万变，现在不需要不代表以后不需要，为了让albianj活的更长久，又更强
   的生命力，albianj的ioc功能是被设计成可扩展的。以后如果需要加入
   remoting的过程调用，对于albianj来说也仅仅是只需要修改service初始化
   部分即可，并且当加入remoting调用后，生命周期和惰性加载将会更加的适
   用。

对于albianj的ioc来说，它仅仅只是需要一个配置文件来控制，配置好name，接
口和实现，除了配置以外，albianj还要求所有的service都必须实现
IAlbianService接口，如果是使用默认的albianj的service功能，为了方便，
albianj也提供了FreeAlbianService的基类。这些规则都满足以后，开发者就可以根
据albianj提供的方法从ServiceRouter中根据配置的name获取service就
可以了。剩下的事情都是由albianj内部来完成。

所以albianj的kernel提供了一个解析xml的功能，albainj会把配置在config文
件夹中的配置文件根据实际启用的功能集来加载和解析xml。但是albianj的xml
解析仅仅是提供了最基本的接口功能，因为每个配置文件的格式都是不一样的，
所以具体的解析配置文件的工作被丢给了实际的功能集来完成，这样一来方便了
开发者对于albianj的二次开发，二来也是大大的节省了albianj本身的代码和人
力成本。

那么现实的问题是那些service从哪里来？这些service是在albianj启动的时候
根据你的配置已经进行初始化了。显然albianj使用了单例模式对service进行了
控制。albianj在使用的时候需要使用者在进程启动
的时候显式的调用albianj的启动函数，已启动并且初始化整个albianj环境。这
部分的启动不仅仅初始化albianj的kernel，更是初始化了使用albianj的所有已
配置的service和所有已配置的功能，包括后面会讲到的数据路由、ORM、配置等
等。为了更快的启动albianj和进程，albianj的加载方式还提供另外的一种异步
加载功能。但是使用albianj必须在albianj加载后使用。异步加载仅仅是提供了
进程可以在加载albianj的同时加载它所需要的另外的一些功能。

albianj的kernel除了提供最重要的这两部分之外，在kernel内部还提供了线程
池和异常处理，也定义和实现了log接口（关于log后面会有详细的叙述）。线程
池的作用主要是提供异步的数据操作，这部分会在ORM和缓存部分为使用和提及，
而异常是整个albianj的基础组件。这里所提及的异常是经过完善后的异常，
和程序直接抛出的异常并不是完全相同。这里的异常将会包括比原始异常更丰富
的堆栈信息，它主要面向的是程序员开发和业务处理过程中的日志，让开发者或
者是运维更快速的确定发生异常的地点和原由。

就目前来说，albianj的service已经足够我们使用，当面对的压力变大，系统
需要扩展的事情，只要扩展FreeAlbianService的生命周期实现功能就可以
了。albianj给每个service都定义了一个生命周期，状态依次是：

1. Normal：表示service刚刚构建出来，还不能被albianj初始化，并且不能被
   直接使用；  

2. Initing：表示service在构建出来后正在执行albianj的初始化功能，在这里
   你可以初始化刚刚生成的service，典型的例子是当service作为微服务提供
   的时候，在这里可以想nameservice注册service；
   
3. Running：表示service已经在正常运行状态，使用者可以通过albianj框架调
   用这个service；  

4. UnLoading：表示service正在被卸载，一般来说，这步除了设置状态和卸载
   initing的时候加载的资源就没有什么了，但是如果这个service作为微服务，
   那么需要在这里把service从nameservice中注销掉；

5. Unloaded：表示service已经卸载完毕，正在等待GC回收。service到这一状
态后，它将不能被albianj调用，所以这一状态对于开发者来说是透明的；

albianj的ioc是albianj所有功能的基础，通过简单而可靠的方式实现的ioc为
albianj提供了最大的方便。在扩展性方面，albianj也给了开发者在统一的基础上最大
的自由。下面的所有albianj组件都是建立在albianj ioc的service模型的基础
上。所以搞清楚albianj的ioc，基本上就搞清楚了albianj的一半。

