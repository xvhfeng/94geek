---
layout: post
categories: [Albianj,java]
title: "腾讯文学内容中心分布式统一框架的设计与实现"
tags: [ALbianj,java]
---

###摘要  
我们设计并且开发了内容中心统一的分布式开发框架。我们把它取名为albian，
albian是基于java的（故以下简称albianj）。他主要是面向海量数据处理、海
量数据访问、并且应当具有良好的伸缩性和可定制性。他设计并且运行在简单的
web容器中，比如tomcat或者是jetty，但是它依然提供了企业级开发应该具备的
一切效能。  

虽然从业界来说，目前成熟的框架有很多，但是从EJB因为复杂性而被大多数公
司放弃后，spring+Hibernate在业界成为了事实上的标准。总体来说
spring+Hibernate可以解决掉企业开发的很多问题，但是在互联网行业，在快速
开发、海量数据处理和快速迭代引起的统一问题面前，这个组合还是有或多或少
的问题。所以我们最后决定自己开发一个适合我们自己的框架出来，来解决sh组
合所不能或者不能很好的解决的问题。  

虽然albianj和sh有很多的相似性，可能很多的功能都是重复的实现，但是毕竟
albianj实际来自于我们对于掌控业务和掌控代码的现实需求，所以它更面向于
我们的实际情况，而不是来源于开源组织对于系统的理解或者是某篇论文对于系
统概念的理解。这样，也就意味着albianj相比sh会更实用，并且能给我们带来
更好的可用性和可维护性。  

albianj的使用满足了我们在业务上对于程序代码控制和功能上对于处理海量实
时数据的需要。目前albianj已经使用在我们的生产环境中，主要为整个集团提
供数据的存储和读取之用。目前它一共被部署在上百台的机器上，来完成对于几
十台数据库的各种不是模式的访问。  

在本文章中，我们主要阐述我们设计和开发albianj的一些观点和一些策略选择
的原因，最后我们会列出实际情况下我们的开发效率和性能数据。  

###简介  
我们的albianj主要完成的任务就是统一程序员的工作，让程序员在统一的口径
下完成他们的工作，这仅仅是一个长远的战略目标；更现实的目标是alabianj必
须提供一套简单的机制在应对对于拥有复杂不熟结构的后端数据库的访问和在数
据量增长的过程中，方便的切合数据的再划分等等功能。在开源的项目中，我们
考察了guzz和hbm shared，但是前者过于复杂，导致我们迷失在了配置文件中，
而且对于他显式的指定数据路由有一定的不可接受；而后者，它仅仅只是一个补
丁，而且这个补丁的质量真的令人堪忧，不支持分布式事务这是完成不能接受的
事实，所以我们综合的考量下来，我们决定自己来设计并完成整个框架系统。  

对于albianj，其实它和市面上提供的各种开发框架功能类似，最最基本的功能
也仅仅只是IoC和ORM，所以从这2个方面可以看出，我们还是在追求对于OO的控
制。但是albianj不仅仅只是完成这些功能，它更多需要强调一致性。不仅仅是
数据的一致性，而是对于程序员写代码的一致性和可控性，兼具对于各种
albianj中主键的一致性和可控性；其二，它还需要解决一个大多数的框架都没
有解决的问题，那就是数据路由的能力。简单而一致的数据路由功能可以快速的
开发大数据量的业务，并且也可以在短时间内让自己的系统无缝连接数据切分带
来的困扰。所以相比传统的开发框架，我们在设计和开发albianj的时候就已经
额外的考虑了更多的内容，并在其中进行了有的放矢的选择，引申出了和以往不
同的开发思路，也实现了我们开始对于albianj设计时制定的目标。  

首先，albianj和别的框架不一样的核心点是“一求一法”，简单来说就是一种需
求只会一种办法来解决，轻易不会出现第二种办法。就算为此牺牲一定的编程便
利性，albianj也需要守住这个底线。所以这个模式就和spring或者诸如此类的
框架有质的不同，一方面我们没有必要为了迎合新的概念或者新的技术频繁的对
albianj进行升级和改造，另一方面，我们也没有必要为了多功能而引入不必要
的复杂税。从程序员写代码的角度来说，他们也仅仅只需要学会一种途径就可以
依葫芦画瓢似的解决类似的问题。这样的结果就是代码会无比的统一，熟悉
albianj过后开发也是无比的迅速。这一点是albianj一直在追求的，也是一直在
遵循的一个必须准则。albianj所有的功能都是建立在这个标准之上的。  

其次，和别的框架一样，我们必须也需要使用配置。但是我们和别的框架不一样
的地方是我们没有“约定优于配置原则”。在稍早之前，随着java对于xml的配
置越来越依赖，导致了很多的java程序员40%的时间在写代码，另外的时间都在
写配置或者是copy配置。后来随着各种抱怨的产生，遂订立了一个规则，就是坑
爹的“约定优于配置”。这个出发点其实和hbm的sharing是一样的，它仅仅只是一
个补丁而已。其实我们经过10多年的互联网开发，总结了一下，我们认为，目前
xml的配置一部分是因为功能的复杂而决定了，另外一部分是被滥用了，两点相
加造成了目前的这种境况，然后为了前面的失误，后面加入了一个补丁（约定优
于配置）来解决这个问题。其实并没有真正的解决问题。所以albianj在设计的
过程中就是尽量的对配置做减法，仅仅保留必要的配置，但是在配置和一致性和
可维护性冲突的时候，我们选择了一致性和可维护性，放弃了对于配置精简的需
求。  

第三：albianj是所有组件的总称。其实它里面包括了多个不同功能的组件。对
于这些功能性组件，我们采用了一键安装和是使用的策略。在一些需要使用的地
方只需要配置项加上某些配置，功能会自动启用。这样在保证解决问题一致性的
同时对程序员又不失开发上的便捷。对于我们的整个系统来说，它不仅仅解决了
开发效率的问题，更是解决了年久失修这个困扰我们团队已久的问题。  

第四：albianj对于我们团队来说，还解决了团队中水平参差不齐的问题。因为
albianj恪守一致性的原则，只要对albianj使用得当，写出来的代码几乎是一个
模板刻出来的，不管程序员的水平是应届生还是具有开发经验的程序员，几乎写
的代码大同小异。在关键的数据路由等功能性问题上，albianj提供的解决方案
是提供一些接口来供程序员使用，程序员要做的事情就是实现这些接口而已，中
间并没有除此之外的任何代码需要程序员来完成。  

最后：最重要的一点是，albianj完成是我们整个团队在互联网开发10多年来的
经验结晶。它容易设计并且容易完成，而且因为它是为我们量身定做的，所以在
使用上并不存在任何碍手碍脚的地方。总体上的架构因为全部是我们自己从头开
始搭建，所以解决bug或者易用性问题也是一件非常简单的事情。我们并没有因
为整个albianj的开发而导致业务的延期，相反在业务的开发中，我们不时的发
现albianj改进的点，我们进行了逐一的更改和优化。这些更改和优化也会一并
在这篇文章中体现。  

###设计概述

####目标

在上面的介绍中，我们简单的介绍了albianj的一些设计的思想和准则。并且我
们声明了albianj在系统存在的地位和它的一些基本功能。在这一节中，我们将
详细的说明albianj设计的目标和对我们的挑战。在设计和实现的过程中，我们
印证了一些我们初定的目标，在项目使用和实施的过程中，我们也根据我们实际
的情况对于初定的目标进行了一定的筛减、优化。

1. 首先的目标就是一致性。我们在开始设计albianj的时候就把albianj的一致
   性作为极致的追求来应对。我们认为在一个软件的声明周期内，一致性起到
   的作用不仅仅体现在代码的可读性上，而且更有利于后期的软件的可维护性
   上。特别当团队的人员开始流动的时候（其实我们一直觉得人员的流动是无
   法避免的），拥有一致性和可维护性的软件会拥有更长的生命周期。而且一
   致性不仅仅体现在可维护性上，还有更多的是可以节省前期程序员的工作量
   和降低bug出现的机率。

2. albianj必须可以应对海量数据的访问。在现在的互联网系统中，海量的数据
   和高并发的访问已经变得越来越普遍。对于一个技术来说，应对海量数据和
   高并发流量的策略就是拆分。所以本质上，albianj其实需要面对上百台甚至
   是上千台的后端服务器，他们可能是分布式的存储，也可能是关系型的数据
   库，或者是后端的业务接口服务器。albianj可以提供一种简单而有效的方法
   来应对那么多的机器。实际的情况其实并不仅仅只是这么简单，因为albianj本
   身就在分布式的环境中，它需要部署在成百上千台服务器上，以提供最基本
   的框架服务。

3. 作为一个开发框架，albianj必须要可以随时来应对机器的增加和损坏。
   albianj必须在有限的时间内来应对机器的部署改变，而不需要更改代码或者
   仅仅只是更改有限的配置。传统来说，就算机器一切安全而稳固，整个服务
   也会因为数据量的增加而需要重新审视架构和机器的部署。更多的时候是需
   要拆分数据和移动数据，而albianj需要在面对复杂的架构调整的时候，轻易
   的来应对问题。从而让系统重新稳定架构的成本降到最低。

4. 作为整个系统的最基本的底层，albianj需要适应更多功能的快速加入。并且
   在albianj的规范内快速的形成组件化，做到即插即用的效应。这不仅仅只是
   代码级别说考虑的事情，更多的是需要在设计的过程中就注意对于新功能添
   加的便捷性。也就是说需要从头就开始考虑以后的可扩展性，做到一致性、
   可维护性、可扩展的平衡和兼得。

5. albianj作为这个内容中心的框架，也必须要对程序员做到尽可能的友好，又
   必须考虑一些敏感信息对于系统安全的影响，在这两者之间取得相应的平衡，
   来达到albianj最好的亲和性和安全性。这个挑战不仅仅在于对于albianj的
   使用上，更多的是需要平衡团队内部参差不齐的开发者的编程水平。

6. 因为albianj是从头开始搭建的一整套完整的框架，所以难免会出现bug或者
   是开发者觉得使用不是那么顺畅的地方。albianj还必须提供一整套的完备机
   制来第一时间解决bug或者是易用性的问题。

在大的方向上，albianj的挑战非常的严峻，特别是对于一致性的特别的追求和
需要安全性、易用性、可扩展性之间平衡的需求不是一点点的难度。然而，不管
怎么样，最后还是需要具体的细化到各个技术点的目标上才算是告别空中楼阁，
才会有落地实现的机会，所以我们又对albianj在技术上定下了一些目标，这些
目标组合起来，可以实现上文提到的一些对于albianj的期望。

1. 首先为了配置一致性问题，我们必须使用一致的方法来实现各种功能。我们
   必须设计和实现一套OOP编程机制、其中包括接口、实现、配置之类的相关标准。我
   们还必须设计和实现一套代码的命名标准、代码的相关逻辑组织标准。还必
   须建立和实施一套我们使用albianj的标准和方法。因为
   我们的业务代码最后都会建立在albianj上，所以必须要夯实作为基础的
   albianj和相关的规则规章，我们才有可能实现严格的一致性需求。

2. 对于albianj来说，它其实是一整套我们经常使用的功能性工具集的集合，所
   以我们务必要做到在不损失alabinaj整体性的同时，使用的合理的切分方法
   来设计和实现albianj的各个子功能集。所谓合理的方法，其实无非也就是系
   统的划分原则，在albianj中，我们使用了”统一依赖、各自管理、各自实现、
   减少干涉”的原则，我们给这个原则取了一个名字：边界原则。具体的办法就
   是各自实现自己的功能，尽可能的减少子系统间的相互依赖，尽可能的减少
   跨系统的生命周期内的依赖。

3. 我们不推荐并且放弃了“惯性原则”，我们使用显式的声明来完成所有的功能
   性配置或者是代码的编写。每个人的受教育程度不同、开发经历也不一样、
   对待系统的认知和视角也各不相同，所以我们基本上是无法真正的做到大家
   在同一个认知水平上来处理事务，也就是说“惯性原则”中最重要的“惯性”对
   我们整个团队来说基本上是无法实现的。所以我们必须要提供一种技术或者
   是一种机制来约束这个开发者各自的”惯性“，已达到我们对于整个系统拥有
   一个一致的惯性的理解。

4. albianj作为大家使用的一个功能性集合，我们必要还要做到albianl必须要
   保持简单，并且要做到因为albianj的存在，可以隐藏albianj的后端的业务
   部署关系。不管是业务集群还是数据库集群，都必须被albianj隐藏。开发者
   只要认为使用了albianj就可以简单的把整个系统当成单机系统一样的开发和
   测试。

####架构
在设计albianj之初，我们其实并没有一个非常明确的对于架构的标准。我们一
致的认为架构的设计实现与架构的层次类别区分并不是由某些理论或者是某篇论
文或者是某个观点来进行的，而是在真正的实现过程中，随着功能点的增加和实
现的代码逐渐的增多，会自然而然的去对整个的系统进行审视和调整，这部分的
工作会一直循序渐进的继续下去，永远不会停止下来。

到目前为止，我们的albianj已经演化成了具有8个子功能集的大架构。它们之间
并无复杂的依赖关系，除了简单的依赖于同一个kernel以外，别的所有的依赖都
是按需而定的。

<center>
![all](/img/albianj/all.jpg)
</center>
</br>

在框架开发发展了这么多年的今天，对于一个框架来说，寻找一个架构上的标新
立异的机会几乎不可能了。而不同在于在使用的便捷性和框架的设计出发点。我们的框架主要面
向的就是互联网的开发，这是我们的一个基本的立足点。所以，我们的框架首先
不会是大包大揽的功能性集合，我们对于一些互联网不会用到的功能一律的进行
生删减，但是对于我们关心的问题，我们也结合我们自己的实际情况和需求解决
掉了。从而分门别类的划分的这几个功能性子集基本上已经代表了我们所能精简
的极限了。下面我们会依次的对这些功能性子集做出解释，并且对于没有被我们
选择的可能的选型做出取舍的原因。

####kernel
作为整个albianj的核心，它其实有2部分组成。一部分是albianj基本上都需要
用到的公共功能；另外一部分也是albianj都需要用到的，并且是更加重要的、
满足我们对于管理service需要的ioc功能。

先说公共功能。这部分包括了很多的功能性的封装，包括但是不仅仅局限于hash
算法、输出型参数、日期操作、网络基本接口、反射基本接口、运行时栈信息、
加密解密安全、数据验证接口、xml解析等功能。他们是所有的albianj功能集可
能会使用到的，但是我们又无法给他们分开归类的功能。我们把这些功能统一的
放到kernel下面的公共功能集下面，以供albianj使用。

这部分的功能对于albianj的使用者来说，也可以被直接拿来使用，但是更多的时
候，除了验证机制以外，别的功能基本上都不太用得着。所以对这个功能包不清楚或者不
知道它的存在并不影响合理的使用albianj。

对于ioc功能来说，这是整个albianj的核心。其二，对于使用albianj作为开发
框架的业务系统来说，也是它们的核心。ioc都是提供了一个控制反转的功能。
将我们的接口和实现分开，然后根据自己的需要加载实现。传统的ioc（比如
spring）会有n多种的注入方式，比如初始化参数、接口、属性等等。但是
albianj仅仅使用一种方式：接口方式。选取这个方式的主要原因有以下几个方
面：
1. 我们认为提供多种的注入方式会引起代码的混乱和配置的文件的复杂度，对
   于可维护性来说，过多的解决方案可能会适得其反。当有n个同事同事使用n
   种方法时，虽然它们的方法方案被限制在一个框架内，相互之间还是会增加
   学习成本，维护成本；

2. 选择接口注入的方式是因为我们需要对于service进行控制。在比较了一些注
   入方式后，我们觉得接口注入是最适合albianj的一种方式。为了更好的管理
   各个service和以后的扩展（这会在下一点中有详细说明），我们必须要干扰
   service的初始化和使用过程。我们需要给每个service标注它的生命周期，
   已提供包括惰性加载之类的各种功能；

3. 上面讲到以后的扩展。对于albianj来说，目前的service都是在本地运行的，
   不会出现remoting的调用，也不会出现微服务的模式。但是互联网的世界瞬
   时万变，现在不需要不代表以后不需要，为了让albianj活的更长久，又更强
   的生命力，我们把albianj的ioc功能设计成可扩展的。以后如果需要假如
   remoting的过程调用，对于albianj来说也仅仅是只需要修改service初始化
   部分即可，并且当加入remoting调用后，生命周期和惰性加载将会更加的适
   用。

对于albianj的ioc来说，它仅仅只是需要一个配置文件来控制，配置好name，接
口和实现，除了配置以外，我们还要求所有的service都必须实现
IAlbianService接口，如果是使用默认的albianj的service功能，为了方便，我
们也提供了FreeAlbianService的基类。这些规则都满足以后，开发者就可以根
据albianj提供的方法从ServiceRouter中根据配置的name获取service就
可以了。剩下的事情都是由albianj内部来完成。

所以albianj的kernel提供了一个解析xml的功能，albainj会把配置在config文
件夹中的配置文件根据实际启用的功能集来加载和解析xml。但是albianj的xml
解析仅仅是提供了最基本的接口功能，因为每个配置文件的格式都是不一样的，
所以具体的解析配置文件的工作被丢给了实际的功能集来完成，这样一来方便了
开发者对于albianj的二次开发，二来也是大大的节省了albianj本身的代码和人
力成本。

那么现实的问题是那些service从哪里来？这些service是在albianj启动的时候
根据你的配置已经进行初始化了。albianj在使用的时候需要使用者在进程启动
的时候显式的调用albianj的启动函数，已启动并且初始化整个albianj环境。这
部分的启动不仅仅初始化albianj的kernel，更是初始化了使用albianj的所有已
配置的service和所有已配置的功能，包括后面会讲到的数据路由、ORM、配置等
等。为了更快的启动albianj和进程，albianj的加载方式还提供另外的一种异步
加载功能。但是使用albianj必须在albianj加载后使用。异步加载仅仅是提供了
进程可以在加载albianj的同时加载它所需要的另外的一些功能。

albianj的kernel除了提供最重要的这两部分之外，在kernel内部还提供了线程
池和异常处理，也定义和实现了log接口（关于log后面会有详细的叙述）。线程
池的作用主要是提供异步的数据操作，这部分会在ORM和缓存部分为使用和提及，
而异常是整个albianj的基础组件。这里所提及的异常是经过我们完善后的异常，
和程序直接抛出的异常并不是完全相同。这里的异常将会包括比原始异常更丰富
的堆栈信息，它主要面向的是程序员开发和业务处理过程中的日志，让开发者或
者是运维更快速的确定发生异常的地点和原由。

就目前来说，我们的service已经足够我们使用，当我们面对的压力变大，系统
需要扩展的事情，我们只要扩展FreeAlbianService的生命周期实现功能就可以
了。我们给每个service都定义了一个生命周期，状态依次是：

1. Normal：表示service刚刚构建出来，还不能被albianj初始化，并且不能被
   直接使用；  

2. Initing：表示service在构建出来后正在执行albianj的初始化功能，在这里
   你可以初始化刚刚生成的service，典型的例子是当service作为微服务提供
   的时候，在这里可以想nameservice注册service；
   
3. Running：表示service已经在正常运行状态，使用者可以通过albianj框架调
   用这个service；  

4. UnLoading：表示service正在被卸载，一般来说，这步除了设置状态和卸载
   initing的时候加载的资源就没有什么了，但是如果这个service作为微服务，
   那么需要在这里把service从nameservice中注销掉；

5. Unloaded：表示service已经卸载完毕，正在等待GC回收。service到这一状
态后，它将不能被albianj调用，所以这一状态对于开发者来说是透明的；

####DataRouter

数据路由其实我们设计和实现albianj的初衷，上面提到的kernel其实也是因为
数据路由的存在而设计和实现的，kernel的最初功能只是为了管理数据路由中使
用到的service，但是后来发现这部分其实也是整个系统所需，我们才认真的重
新设计和重构了原本属于DataRouter的这部分，然后把它单独的作为一个功能开
放给开发者。

我们设计和实现数据路由很大一部分的原因是：目前没有找到一个合适我们实际
情况的路由组件。数据路由：它主要完成的功能是当我们对数据库进程操作的时
候，数据路由可以根据我们配置的路由信息把我们的查询或者是数据提交到正确
的目的地。这些目的地包括但是不仅限于数据库，还有可能是一个分布式的存储，
或者是一个nosql的数据存储服务。我们目前对于数据库的路由功能相对来说迫
切程度比较大，但是我们找了一下开源，发现并没有一个适合我们的，连可以拿
来做二次开发的都没有。那么在没路可走的时候，我们开始自己设计和实现数据
路由。

首先的问题就是数据存储的异构性。目前我们大量使用了mysql作为我们的主力
存储，mysql确实也因为优异的性能表现扛住了我们的压力，但是这不代表我们
仅仅会在mysql上做开发，可能也会引入别的数据库，比如oracle。所以我们的
数据路由必须要支持异构的数据存储。在支持异构存储的情况下，我们后面的扩
展才不会大动筋骨。

其次，根据我们的实际情况，albanj的数据路由必须要支持存储的运维部署。比
如支持双写模式、读写分离模式等等。更高的需求是这些运维模式的支持必须是
无缝的，对于开发者来说是透明的。在支持存储部署模式的情况下，我们还必须
做到简单而有效的支持数据的迁移等等后期的维护问题。这样在目前我们的运维
人手和DBA人手都不是很充足的情况下，可以做到尽量简单的维护我们的系统，
节省我们的人力成本。

再次，albianj的数据路由必须可以随心所欲的进行控制。比如路由的开启和关
闭，或者是路由的重定向等等。只要存储的数据已经到位的情况下，albianj的
路由必须可以在第一时间进行系统的支持。这部分也需要对开发者透明，仅仅需
要运维的改动就可以实现。

然后，albianj的数据路由还必须支持数据的完整性。对于所有的系统来说，数
据的完整性是必须的要求之一，也是最重要的要求之一。因为数据路由的加入，
使得其实对于开发者来说，我们的后端数据库已经被屏蔽了。后端的数据库是不
是采用分布式部署等等信息全部被屏蔽掉，所以albianj必须要替开发者在
albianj的层面上解决这个数据的完整性问题。这个完整性问题在分布式数据库
的时候被扩大，原本的事务被扩大成分布式的事务，也就是说albianj也要必须
能支持分布式的事务。

最后：也是albianj的一直坚持的一点，在支持这么多的功能的时候，必须要做
到统一。必须要做到配置上的统一、代码级别上的统一。

经过我们的前期实际的项目实施，我们的数据路由被总结成4种情况:

1. 最简单的一种是直接把一个对象保存到路由指定的数据库.
<center>
![直接保存对象](/img/albianj/dr1.png)
</center>

2. 稍微复杂一点的是需要同时保存多个对象到各自指定的路由数据库，典型的
操作是在保存一个对象的同时再保存一份日志.
<center>
![保存多个对象](/img/albianj/dr2.png)
</center>

3. 再复杂一点的保存多份，也就是多写.  
<center>
![多写](/img/albianj/dr3.png)
</center>

4. 最后是albianj必须还有路由sql语句的能力，而不仅仅是路由数据对象.
<center>
![路由Sql](/img/albianj/dr4.png)
</center>

上面的饼已经画的足够的大，现在是我们实现这个饼的时候了。把空中楼阁落地。
首先，我们确定的一点是这个庞大的数据路由必须在我们的albianj内部实现，
而不是使用类似于mysql proxy这种组件。最简单的原因就是proxy这种组件只能
解决一种数据库的问题，它不能解决所有数据库的问题。也就是说不能解决我们
在扩展中需要的异构数据存储的问题。那么唯一能给我们剩下的就是在JDBC的时
候做手脚了。先来看一段简单代码：

>
    cmdText="INSERT INTO User01 Values....";
    connString = "database=db1;user=root...."
    Connection c = new Connection(connString);
    SqlCommand cmd = new SqlCommand(c,cmdText);
    SqlTransaction tran = c.getTransaction();
    try {
	    tran.begin();
	    cmd.Exec();
	    tran.commit();
    } catch() {
	    tran.rollback();
    }finally{
	    c.close();
    }

这基本上就是我们实现一个JDBC最简单的模型，我们需要在这段代码中绣出花了，
让这朵花能支持我们的数据路由功能。仔细看这段代码，其实除了cmdText和
connString这两句以外，别的代码都是已经被公式化的，也就是我们没办法更改。
而这两句的是仅仅我们能定义的两句。其中cmdText中的表名和connString中的
database值是我们能自定义的，那么我们现在的问题就是怎么样通过一个规则来
确定我们这里表名和basedata的值。其实这个规则就是确定数据路由。在
albianj中，因为albianj位于底层，我们albianj只是调用路由规则，并不定义
路由规则，路由规则都是有开发者定的，所以我们现在的问题又变成了怎么样来
调用规则？

在调用规则之前，我们还要确定一个事情：在哪里调用规则？或者说为了什么而
调用规则，一个很明显的问题是我们不可能让程序员自己直接去写JDBC代码，所
以我们必须要提供一套对象和数据库的映射，那么ORM也就被引进进来了。有了
ORM，又需要更改表名，那么一个地方我们已经找到了，就是在数据对象转成Sql
语句的时候把表名给拼出来。那么最后一个问题，database的问题，我们在什么
时候确定database的值？database的使用是在连接数据库的时候，所以我们在必
须要在连接数据库之前确定这个值。而数据库又和路由相关，所以我们在确定路
由的时候就可以确定database的值。那么最后，albianj演变成路由3部曲：

<center>
![路由选择](/img/albianj/dr5.png "路由选择")
</center>

对着这3部的路由选择，我们在albianj中也提供了一个基类来完成实现这个功能。
在albianj中，FreeAlbianObjectDataRouter基类就是这个实现类，在通常的情
况下，开发者只有继承这个类就可以了，对于自己的路由需求，可以通过这个类
里面的不同的方法来实现，这个类一共提供了6个方法，分成2组，一组提供给读
服务，另外一组提供给写服务。但是仅仅是这个基类还无法完成我们提到的路由
功能，整个的路由功能必须还需要配置文件的配合。其中drouter.xml就是配置
路由的配置文件，drouter根据每个对象来定义它的路由，在发生数据操作的时
候这些路由会被albianj自动调用；还有一个配置文件是storage.xml，这是配置
所有数据库连接的文件，这里的配置信息需要和drouter.xml中的路由配合起来
使用。

####ORM
在albianj中，ORM作为一个基本的组件实现。但是albianj中的ORM和很多开源框
架的ORM有很多功能上的取舍。albianj对于ORM进行了精简，已保留我们最需要
的部分为前提，把所有不相干的功能全部删除掉。所以albianj中的ORM其实仅仅
只是一个对象和关系数据库的实体和表结构映射。它并不提供在ORM层面处理复
杂的对象间关系依赖的问题，这部分的工作被albianj转嫁给了程序员来完成。
这步的转嫁可以让程序员更好的完成业务开发，也可以更好的处理数据的加载等
问题。

但是albianj的ORM集成了上文提到的DataRouter，albianj主要是为互联网开发
而设计的，所以对于albianj来说，解决大并发和海量数据显然要急迫于解决复
杂而吃力不讨好的ORM中的对象问题。也因为加入了DataRouter，所以albianj必
须要重新设计ORM的数据一致性功能。

数据一致性的问题在ORM中可以转换成事务的一致性问题。当数据库只有一台的
时候或者我们的数据都塞在同一个数据库的时候，数据库可以给我们解决掉事务
的一致性问题，但是当我们需要使用分布式数据库的时候，显然单机的事务已经
无法满足我们对于数据一致性的要求，所以我们必须引进能在多台数据库服务器
之间可以保证数据一致性要求的技术。在albianj中，这种技术使用了二次提交
来完成。

在albianj中，每一次的数据库访问被成为是一个job，这个job仅仅与我们的现
实业务相关，和albianj需要访问的数据库实例的数量没有关系。或者说albianj
可以在一次job中访问多个数据库实例。所以，job在abianj中其实是一个分布式
事务的控制中心，它对多个数据库实例的事务进行了抽象和统一接管，但是job
不直接管理各个数据库实例的事务和链接，这部分的工作被albianj交给了task
来处理。







