---
layout: post
categories: [Albianj,java]
title: "腾讯文学内容中心分布式统一框架的设计与实现--数据路由与ORM"
tags: [ALbianj,java]
---
####DataRouter

数据路由其实设计和实现albianj的初衷，也是花费那么多的力气，重新找一个
轮子的最基本的动力。上面提到的kernel其实也是因为
数据路由的存在而设计和实现的，kernel的最初功能只是为了管理数据路由中使
用到的service，但是在实践中发现这部分其实也是整个系统所需，才开始认真的重
新设计和重构了原本属于DataRouter的这部分，然后把它单独的作为一个功能开
放给开发者。

我们设计和实现数据路由很大一部分的原因是：目前没有找到一个合适我们实际
情况的路由组件。数据路由：它主要完成的功能是当开发者对数据库进程操作的时
候，数据路由可以根据配置的路由信息把查询或者是数据提交到正确
的目的地。这些目的地包括但是不仅限于数据库，还有可能是一个分布式的存储，
或者是一个nosql的数据存储服务。目前互联网的现状是，几乎每个公司对于数据库的路由功能相对来说迫
切程度比较大，但是找了一下开源，结果还是挺失望的，发现并没有一个简单而
有效的数据路由可以直接拿到使用。连可以拿
来做二次开发的都没有。那么在无路可走的时候，我们开始自己设计和实现数据
路由。

结合我们的实际情况，首先的问题就是数据存储的异构性。目前我们大量使用了mysql作为主力
存储，mysql确实也因为优异的性能表现扛住了压力，但是这不代表我们
仅仅会在mysql上做开发，可能也会引入别的数据库，比如oracle。所以albianj的
数据路由必须要支持异构的数据存储。在支持异构存储的情况下，后面的扩
展才不会大动筋骨。

其次，根据实际情况，albanj的数据路由必须要支持存储的运维部署。比
如支持双写模式、读写分离模式等等。更高的需求是这些运维模式的支持必须是
无缝的，对于开发者来说是透明的。在支持存储部署模式的情况下，albianj还必须
做到简单而有效的支持数据的迁移等等后期的维护问题。这样在目前我们的运维
人手和DBA人手都不是很充足的情况下，可以做到尽量简单的维护我们的系统，
节省我们的人力成本。

再次，albianj的数据路由必须可以随心所欲的进行控制。比如路由的开启和关
闭，或者是路由的重定向等等。只要存储的数据已经到位的情况下，albianj的
路由必须可以在第一时间进行系统的支持。这部分也需要对开发者透明，仅仅需
要运维的改动就可以实现。

然后，albianj的数据路由还必须支持数据的完整性。对于所有的系统来说，数
据的完整性是必须的要求之一，也是最重要的要求之一。因为数据路由的加入，
使得其实对于开发者来说，后端数据库已经被屏蔽了。后端的数据库是不
是采用分布式部署等等信息全部被屏蔽掉，所以albianj必须要替开发者在
albianj的层面上解决这个数据的完整性问题。这个完整性问题在分布式数据库
的时候被扩大，原本的事务被扩大成分布式的事务，也就是说albianj也要必须
能支持分布式的事务。

最后：也是albianj的一直坚持的一点，在支持这么多的功能的时候，必须要做
到统一。必须要做到配置上的统一、代码级别上的统一。

经过前期实际的项目实施，albianj的数据路由被总结成4种情况:

1. 最简单的一种是直接把一个对象保存到路由指定的数据库.
<center>
![直接保存对象](/img/albianj/dr1.png)
</center>

2. 稍微复杂一点的是需要同时保存多个对象到各自指定的路由数据库，典型的
操作是在保存一个对象的同时再保存一份日志.
<center>
![保存多个对象](/img/albianj/dr2.png)
</center>

3. 再复杂一点的保存多份，也就是多写.  
<center>
![多写](/img/albianj/dr3.png)
</center>

4. 最后是albianj必须还有路由sql语句的能力，而不仅仅是路由数据对象.
<center>
![路由Sql](/img/albianj/dr4.png)
</center>

上面的饼已经画的足够的大，现在是实现这个饼的时候了。把空中楼阁落地。
首先确定的一点是这个庞大的数据路由必须在我们的albianj内部实现，
而不是使用类似于mysql proxy这种组件。最简单的原因就是proxy这种组件只能
解决相关的单一类型数据库的问题，它不能解决所有数据库的问题。也就是说不能解决
在扩展中需要的异构数据存储的问题。那么唯一能剩下的就是在JDBC的时
候做手脚了。先来看一段简单代码：

>
    cmdText="INSERT INTO User01 Values....";
    connString = "database=db1;user=root...."
    Connection c = new Connection(connString);
    SqlCommand cmd = new SqlCommand(c,cmdText);
    SqlTransaction tran = c.getTransaction();
    try {
	    tran.begin();
	    cmd.Exec();
	    tran.commit();
    } catch() {
	    tran.rollback();
    }finally{
	    c.close();
    }

这基本上就是实现一个JDBC最简单的模型，我们需要在这段代码中绣出花了，
让这朵花能支持albianj的数据路由功能。仔细看这段代码，其实除了cmdText和
connString这两句以外，别的代码都是已经被公式化的，也就是没办法更改。
而这两句的是仅仅是能定义的两句。其中cmdText中的表名和connString中的
database值是能自定义的，那么现在的问题就是怎么样通过一个规则来
确定我们这里表名和basedata的值。其实这个规则就是确定数据路由。在
albianj中，因为albianj位于底层，albianj只是调用路由规则，并不定义
路由规则，路由规则都是有开发者定的，所以现在的问题又变成了怎么样来
调用规则？

在调用规则之前，还要确定一个事情：在哪里调用规则？或者说为了什么而
调用规则，一个很明显的问题是不可能让程序员自己直接去写JDBC代码，所
以albianj必须要提供一套对象和数据库的映射，那么ORM也就被引进进来了。有了
ORM，又需要更改表名，那么一个地方已经找到了，就是在数据对象转成Sql
语句的时候把表名给拼出来。那么最后一个问题，database的问题，在什么
时候确定database的值？database的使用是在连接数据库的时候，所以必
须要在连接数据库之前确定这个值。而数据库又和路由相关，所以在确定路
由的时候就可以确定database的值。那么最后，albianj演变成路由3部曲：

<center>
![路由选择](/img/albianj/dr5.png)
</center>

对着这3部的路由选择，在albianj中也提供了一个基类来完成实现这个功能。
在albianj中，FreeAlbianObjectDataRouter基类就是这个实现类，在通常的情
况下，开发者只有继承这个类就可以了，对于自己的路由需求，可以通过这个类
里面的不同的方法来实现，这个类一共提供了6个方法，分成2组，一组提供给读
服务，另外一组提供给写服务。但是仅仅是这个基类还无法完成albianj提到的路由
功能，整个的路由功能必须还需要配置文件的配合。其中drouter.xml就是配置
路由的配置文件，drouter根据每个对象来定义它的路由，在发生数据操作的时
候这些路由会被albianj自动调用；还有一个配置文件是storage.xml，这是配置
所有数据库连接的文件，这里的配置信息需要和drouter.xml中的路由配合起来
使用。

albianj在这里并不会牵涉到实际的业务数据路由拆分策略，这是因为具体的拆分策略都
是需要根据自己的实际业务来决定，而albianj只是要实现一个可以实现这种策
略的机制而不是具体的事实策略，所以这部分将不会在本文中出现。  

####ORM

在albianj中，因为一些异构数据库的问题，要实现数据路由，必须要依靠ORM来
解决这个问题，那么现在，我们开始说说ORM。

在albianj中，ORM也是被作为一个基本的组件实现。但是albianj中的ORM和很多开源框
架的ORM有很多功能上的取舍。albianj对于ORM进行了精简，已保留albianj最需要
的部分为前提，把所有不相干的功能全部删除掉。所以albianj中的ORM其实仅仅
只是一个对象和关系数据库的实体和表结构映射和相关操作。它并不提供在ORM层面处理复
杂的对象间关系依赖的问题，它也没有涉及到很多的ORM都会存在的多种功能，
比如查询方言等等。这部分的工作有的被albianj转嫁给了程序员来完成，有的
直接就是不在albianj的设计理念之内，所以被删除了。而被转嫁的部分，在
albianj的设计理念中，可以让程序员更好的完成业务开发，也可以更好的处理数据的加载等
问题，虽然在工作量上看似增加了开发者的工作，其实对于系统整体来说，这部
分的工作可以让开发者更好的应对业务问题和系统压力问题。

但是albianj的ORM集成了上文提到的DataRouter，albianj主要是为互联网开发
而设计和实现的。对于albianj来说，解决大并发和海量数据显然要急迫于解决复
杂而吃力不讨好的ORM中的对象问题、全功能问题等等。也因为加入了DataRouter，albianj必
须要重新设计ORM的数据一致性功能。

数据一致性的问题在ORM中可以简单的转换成事务的一致性问题。当数据库只有一台的
时候或者数据都塞在同一个数据库的时候，数据库可以解决掉事务
的一致性问题，但是当需要使用分布式数据库的时候，显然单机的事务已经
无法满足系统对于数据一致性的要求，所以albianj必须引进能在多台数据库服务器
之间可以保证数据一致性要求的技术。在albianj中，这种技术使用了二次提交
来完成。

在albianj中，每一次的数据库访问被成为是一个job，这个job仅仅与现
实业务相关，和albianj需要访问的数据库实例的数量没有关系。或者说albianj
可以在一次job中访问多个数据库实例。所以，job在abianj中其实是一个分布式
事务的控制中心，它对多个数据库实例的事务进行了抽象和统一接管，但是job
不直接管理各个数据库实例的事务和链接，这部分的工作被albianj交给了task
来处理。在一个job中，需要操作的数据库实例一一对应于task。task接管了对
于数据库实例的操作和事务过程。从而可以让albianj支持分布式事务。

<center>
![分布式事务结构](/img/albianj/dr6.png)
</center>

albianj的分布式事务并没有采用并行策略，也没有采用嵌套策略。而是同时采
用了这两者的结合体。因为分布式事务的性质决定了在一些极端的是情况下，数
据库中的数据还是会有可能存在不一致的情况。这是采用分布式事务的时候无法
避免的问题。但是albianj也进行了最大程度的去规避这个严重的问题。albianj直
接使用分布式锁搭配上job-task结构就可以处理规避掉这个问题。

albianj在对操作数据的接口中，置入了通知机制，当albianj的事务发生错
误的时候，首先是自动的去回滚，但是当发生了硬件级别的错误后，比如断电等
等问题，那么这时候自动的回滚无济于事，所以albianj会通过通知机制来通知
到系统的维护人员，维护人员会对于这个数据进行回滚。那么在这个回滚的时间段，
albianj的锁服务（下面会讲到锁服务）一直锁定着资源保存事务发生时的状态，最
后会由维护人员把这个资源释放。这种极端的情况几乎是不太可能发生的。现实
中，因为业务的特殊性问题，albianj目前服务的严重的资源抢占情况比较少，
所以这套流程还没有真正的派上什么用处，但是albianj为分布式事务提供了这
种机制，以满足以后系统扩展所带来的数据一致性问题。

显然，albianj的分布式事务对于使用的环境要求是相对比较苛刻的，而且产生
的效果并不一定能达到100%的事务完整性。但这并不是我们故意为之，而是因为
分布式事务本身的不可控性导致的。分布式的不可控性到目前为止其实都没有一
个非常完善的机制来解决，而是尽量的使用各种策略方法来规避各种问题，以达
到事务的一致性。

那么是不是就没有一种办法来作为替代，来解决这种不可控性？所谓：魔高一尺，
道高一丈。方法总比苦难多。所以前辈们又研究出来另一种方案来替代albianj
所使用的方法，这个方案总结下来就是：拆分-重试-记录。

我们把它称为“记帐”模式。把整个的事务切
分成多个单个事务，最后由job把这些事务的对象发送到一组消息机器。这时处
理方式分成两部，前台直接给用户返回提交成功；服务器开始自己的工作。服务
器端会有一组机器不停的去取消息中的数据，
取到数据后就执行，并且每次都记录下取到的数据和版本号等等信息，这些信息
用来作为判重的依据，这样依次的执行队列中的消息，当执行过程中发现异常的
时候，还是自动的去回滚消息，如果发生硬件级别的问题，也是通过通知机制来
强行的恢复数据。

<center>
![记账式事务](/img/albianj/dr7.png)
</center>

记帐方式相比albianj方式的优点是它可以重试，可以在网络不是那么稳定的环
境中进行安全的事务，而albianj事务的解决方案其实就是一锤子买卖。它无法
实现在网络不稳定的情况下进行不断的重试来
实现分布式事务。但是albianj说使用的方法的成本更低，性价比相对第二套方案更高，对
于开发人员来说，也是相对更加的方便。所以我们最后采用了目前这种直接通过
job和task的抽象，然后管理数据库实例连接和事务的方式。

事务的问题解决后，albianj开始设计和实现数据访问接口。在albianj中，
对于数据的访问一般都是通过JDBC来处理，目前albianj提供的接口有mysql和
sql server的。当然也可以很方便的就实现oracle的。对于一个数据层操作来说，
也就是简单insert、modify、delete和select功能。这些功能都需要albianj
使用反射和配置文件配合解决。这里的配置文件是persisten.xml。它是一
个数据实体结构和数据库表结构一个对应关系的文件，albianj提供了对于字段
各种属性的配置，比如是否主键、长度、数据类型等等。每个albianj使用的实
体必须在这里登记以便albianj引擎可以在启动的时候加载这些实体的信息，然
后供后面的ORM使用。这个配置文件还提供了和缓存的集成，可以通过使用一个
cached的配置节就让实体自动的支持缓存的操作。这样我们在albianj的
persisten层也要提供一个对缓存支持的操作，所以就有了find簇函数和load簇
函数的区分。find簇的函数表示先查找缓存，当数据无法在缓存中找到的时候，
在调用load簇函数从数据库中直接获取。

为了给程序员提供最大的方便，albianj还集成了save方法。简单来说就是当这个
实体的数据数据库中存在的时候就更新，没有的时候就执行插入操作。那么这就
牵涉到两个问题：怎么让albianj知道数据是不是在数据库中存在？还有一个：
如果更新，怎么知道数据库中的数值和目前保存的数值有什么改变？

要解决这些问题，albianj对所使用albianj的对象进行了统一的接管和管理。
albianj提供一个IAlabianObject接口，来完成对象的统一工作。按照惯例，
albianj也提供了一个基类FreeAlbianjObject供开发者使用。在albianj中，更
多的会被推荐使用FreeAlbianObject基类而不是IAlbianjObject。因为使用
IAlbianObject开发者还必须要自己实现albianj制定的规范，而这个规范
FreeAlbianObject已经实现了，所以没必要再实现一次。而且自行实现还有考虑
不周或者是实现失误的风险，还不如直接使用FreeAlbianObject方便。那么这个
接口到底提供了什么功能呢？它包含了一个IsNew属性，这个属性属于albianj的
kernel属性，开发者是无法更改的，这个属性标明了实体对象是否是新创建或者
是从数据库卡中获取获得。另外这个接口还定义了一个私有的map来管理这个实
体原来版本的值（如果有的话），在albianj执行ORM的时候，albianj会通过这个
map中的值和对象中的值进行比较来确定哪些字段需要更新。那么这也说明了从
另外一个角度来说，当有对象需要更新的时候，必须先从数据库中先load一下最
新的数据，然后才能去使用已经发生更改的对象来更新数据库。  

另外一种特殊的情况发生在读取的时候，读取数据的时候并不一定都是通过对象
的唯一Id来获取，虽然albianj推荐使用唯一id。所以albianj提供了IFilterCondition来
实现对于数据的筛选，为了更快的满足业务，albianj还提供了
IOrderByCondition接口来提供对于数据的排序。这是albianj为数不多的不OO的
地方，也是albianj认为为了节省劳动力而可以变通的地方。

albianj的ORM重点并不在于实现全部的ORM功能，它删掉了诸如延迟加载等等很
多原本属于ORM的功能，但是却独树一帜的和数据路由功能结合在了一起。
albianj的ORM通过合理的工作分配和调度，使用最小的代价实现了最大的实用价值。
