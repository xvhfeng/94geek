<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>94geek.com</title>
    <description>属于大嘴的个人blog</description>
    <link>http://www.94geek.com/</link>
    <atom:link href="http://www.94geek.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>为什么这样设计Chaos</title>
        <description>&lt;p&gt;随着上一篇介绍Chaos的文章推送，最近有好几家公司或者项目负责人联系我，准备在生产环境中使用Chaos，所以也会经常被问到一些问题。这里我总结了一下经常会被问到的几个问题，给大家做一个统一的回答吧！&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;怎么样搭建Chaos的集群环境？&lt;br /&gt;
这个问题分为2步：
    &lt;ul&gt;
      &lt;li&gt;首先是配置mid：chaos的配置文件中有一个配置项是mid，这个mid就是每台chaos服务器的唯一标识，目前支持配置值是0-9的数字。只要在一个集群中保证每台chaos的mid不一样即可。&lt;/li&gt;
      &lt;li&gt;在chaos的前端放一个ngx或者是HA这种的带有“负载均衡”功能的反向代理服务器，将各自单台的chaos组合起来即可，我们用的是ngx；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;chaos进程起来都是“回话模式”，退出term就没了，怎么设置“后台运行”，难道要自己加&amp;amp;？&lt;br /&gt;
chaos当然不会傻到让使用方自己加&amp;amp;来daemon化，chaos的配置文件中有一个配置项daemon，把这一项设置成true即可。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;chaos起不来，出现libev.so can not found的错误，这是怎么回事？&lt;br /&gt;
这是因为你虽然安装了libev，但是有的系统（比如centos）不会自动去更新系统的so缓存，所以你需要更新一下系统的so缓存。
    &lt;ul&gt;
      &lt;li&gt;执行命令：echo “/usr/local/lib” » /etc/ld.so.conf.d/x86_x64_linux_libev.conf ；&lt;/li&gt;
      &lt;li&gt;ldconfig -v
搞定。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为什么chaos起来后本地可以访问，换台机器就不能访问了？&lt;br /&gt;
首先你要排除一下你的防火墙，iptables之类的配置是不是都已经开启chaos所使用的端口了。如果已经支持了，那么请看一下chaos配置文件中的配置项bind_ip这个项的值是多少，默认是127.0.0.1，请将这个配置项改成chaos服务器所在的外网可以访问的ip，重启chaos，你就可以在另外一台机器上获取id了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;chaos在集群的情况下（特别是不同机器之间）生成的id是保证单调自增的吗？&lt;br /&gt;
不是，chaos生成的id在集群的情况下不保证严格的单调递增，特别是1s内生成的id，但chaos肯定保证2s内生成的id具有严格单调递增性，也就是说后一秒生成的id值肯定大于前一秒生成的id值。造成这个原因主要是因为几点：
    &lt;ul&gt;
      &lt;li&gt;严格单调递增不是不能做到，而是消耗的资源太多了。现在chaos在集群情况下是没有主从之分的，也没有相互之间的任何通讯，从而保证了我们获取一个id的快速性，也保证了chaos整个的简单性；&lt;/li&gt;
      &lt;li&gt;获取id后，我们经常做的一个动作就是分库分表操作，所以id会被根据业务规则散落到各个“段表”中，在这过程中，时间应该会在ms或者是s级别，所以chaos严格递增性其实没有那么大的实际需求，我们就可以不优先实现这个功能；&lt;/li&gt;
      &lt;li&gt;系统的健壮性。平行的chaos功能设计有利于chaos的部署简单化和提高chaos的系统鲁棒性，不管chaos的机器发生什么问题，就算机器down掉或者直接换掉，chaos都可以快速的通过使用新机器、新节点来提供新的功能，不需要恢复数据、操作日志（因为根本就没有，每次的id都是纯计算生成的）等等； &lt;br /&gt;
PS：我们有支持严格单调递增的id生成器，是另外一个系统：lax605。lax605在我们的系统中更多的被用来作为分布式协调器的角色使用，类似于zookeeper。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;chaos生成的id是否存在浪费？怎么处理？  &lt;br /&gt;
有浪费现象，比如现在每台机器每秒都可以支持最大2560000个id的生成，但是因为99.9999%的时候你根本就用不到那么多的id，真实的业务量大概每秒也就几百或者几千的id生成，从而因为id中存在序列号，所以没有被轮询到的id就直接被扔掉了，这确实有浪费现象。怎么处理？chaos就没有去处理，因为我们觉得这个没啥必要，反正每秒id那么多，而且对于业务来说如果分库分表规则是按照时间等作为路由是要严格保证时间上的正确性的，综上我们就不去过多的去做额外的处理了。但如果有业务方确实觉得id是一个虚缺资源，需要每一个都不放过，那么可以通过中继器来过渡一下，自己做一个每个id的存储和分发。但是在这么做之前，我觉得要冷静下来思考一个问题：这种做法真的有必要吗？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;chaos生成的id最大值是多少？多长？长度固定吗？       &lt;br /&gt;
chaos生成的是一个uint64的数，最大的长度是64位，一共最长是18个数字的长度。但是因为id和时间相关，所以开始的时候id的个数长度会比较短，大概在15位左右。所以id的长度是不固定的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;chaos的客户端有没有java的？&lt;br /&gt;
首先，chaos目前支持两种方式访问：tcp和http。java的客户端也确实有，并且也有开源（在albianj项目中），java的客户端就是通过tcp方式访问的。但就我们自己使用的实际情况和实际效果来看，我们不推荐使用java客户端的tcp方式，我们推荐大家更多的使用http来访问chaos，主要有几点：
    &lt;ul&gt;
      &lt;li&gt;http相比tcp更容易调试，curl或者是浏览器就可以直接调试；&lt;/li&gt;
      &lt;li&gt;http相比tcp，http没有语言的相关性需求，当一个公司或者项目大了以后不保证所有的功能都是java来实现的，所以客户端模式会很蛋疼的需要很多的客户端；&lt;/li&gt;
      &lt;li&gt;对于tcp的通讯相比http性能高的问题，chaos这种访问都是在内网，用http和tcp能差多少？&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;id生成器目前在公司内部使用的怎么样？  &lt;br /&gt;
目前公司内部的内容中心、起点改造等站点正在使用id生成器，每天的请求量总体加起来过亿，一共花费了4台普通的pc服务器。id生成器从上线的那天开始一直到今天有2年多了，中间除了因为功能增加以外从来没有down机，也没有重启记录。稳定性达到惊人的100%。可以算是公司内最稳定的线上运行项目，没有之一。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;目前有几家公司正在使用？  &lt;br /&gt;
到今天为止，一共有10+家公司已经在线上使用id生成器，目前来咨询有使用意向的也有7-8家。我们是最大的一家：阅文集团，该集团是腾讯文学、盛大文学合并而成的。请求量和数据量在网络文学届也是数一数二的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;评价一下别的id生成器，和chaos有什么差别？ &lt;br /&gt;
这nm怎么评价，谁都是看自己家的孩子更好看，更可爱啊！不要搞事啊！我严重怀疑问我这个问题的人的居心，但一看问这个问题的还挺多。nm，果然都是来搞事的。不过话说回来，虽然我确实看了很多友商的id生成器设计或者是成品，各有千秋，各有优势吧！我觉得我们的chaos主要有几个优势：
    &lt;ul&gt;
      &lt;li&gt;在架构上更加的简单，平行化的设计，没有单点或者主从的问题，也没有机器的浪费问题，都是主；&lt;/li&gt;
      &lt;li&gt;依赖少，除了依赖网络库libev，没有什么mysql数据库或者redis这种依赖（PS：其实我也觉得很奇怪，为嘛一个id生成器需要依赖数据库或者是redis这种玩意，这种东西到底在id生成器中有啥用？除了复杂化设计外，没看到什么必要）；&lt;/li&gt;
      &lt;li&gt;性能上更牛X一些吧，c语言，事件机制，相比java之类的，那是相当妥妥的；&lt;/li&gt;
      &lt;li&gt;可读性上更人性化一些，十进制的数字，基本上都能看的懂；&lt;/li&gt;
      &lt;li&gt;协议更简单一些，支持http，无语言相关性；&lt;/li&gt;
      &lt;li&gt;更适合作为数据库的主键来使用，特别是需要做分布式数据库的情况，有分库分表等等数据路由的情况特别适合；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 05 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://www.94geek.com/blog/2017/chaos-qa/</link>
        <guid isPermaLink="true">http://www.94geek.com/blog/2017/chaos-qa/</guid>
      </item>
    
      <item>
        <title>gdb线上crash调试-记一次装逼失败的教训</title>
        <description>&lt;p&gt;可惜这是一次完完全全的装逼不成反被X的典型例子。&lt;/p&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;有一天早晨刚到公司，运维小帅哥突然通知我，我们的dfs在平稳运行了一年时间后，在没有任何异常波动、没有任何资源报警、没有任何升级，也没有任何违规操作的情况下，毫无征兆的crash了。&lt;br /&gt;
小帅哥一头雾水，我一脸懵逼。&lt;br /&gt;
dfs是我们的核心服务，绝对不能down机的，所以就先紧急把它拉了起来。命好的是，起来后程序又平稳运行了，既不crash也不拒绝服务，服务和性能又都是杠杠的。这就让我更懵逼了。&lt;/p&gt;

&lt;h2 id=&quot;怀疑&quot;&gt;怀疑&lt;/h2&gt;
&lt;p&gt;首先怀疑的是内存泄漏一类的资源泄漏问题。毕竟dfs是c写的，内存、fd、locker等等的资源处理太多太杂了。特别是内存，几乎每个函数内都会出现。所以重点对象就是它。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;找运维查看一下报警系统是不是有没有发出来的报警？查了一下没有。&lt;/li&gt;
  &lt;li&gt;自己还是不放心，直接看了一下线上产生的core文件，大小也只有mb级别，确定确实没有溢出。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来，怀疑是fd或者locker。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;先说locker。dfs是我们自己设计的无锁处理算法，根本不存在locker的资源操作，所以这个也被排除了。&lt;/li&gt;
  &lt;li&gt;fd，文件描述符。如果fd有溢出，我们也对fd加了报警，报警系统是不会不报的。就算漏了，fd溢出的现象也不应该是进程直接crash，而是会无响应才对。而且去查看了一下log，并没有发现执行close有错误的迹象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;到目前为止，所有所能想到的原因全部不成立，线索全部中断。那么如果非要弄清楚这次crash到底为了什么，唯一的办法就是去看程序的runtimes。&lt;/p&gt;

&lt;h2 id=&quot;碰碰运气&quot;&gt;碰碰运气&lt;/h2&gt;
&lt;p&gt;反正线上的core文件都已经生成了，不玩白不玩。通知运维把core给拿下来，我非得去看看到底为啥就crash了？不看不要紧，一看就自己打了自己的脸啊！&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;加载core文件，发现程序是因为收到信号6的原因进程被退出的。如下图：
&lt;img src=&quot;1.png&quot; alt=&quot;single 6&quot; /&gt;
信号6，也就是SIGABRT，Linux的man解释：由调用abort函数生成的信号。引起这个信号的可能性有很多，所以这一点没啥用。&lt;/li&gt;
  &lt;li&gt;加载可执行文件，然后看看crash的一瞬间的堆栈是一个什么情况，好做一个大概的判断：哪一行代码可能出现了问题。
&lt;img src=&quot;2.png&quot; alt=&quot;load file&quot; /&gt;
执行bt命令后，显示出来的stack信息全是？？，出现这种情况的可能性有2个：
    &lt;ul&gt;
      &lt;li&gt;可执行被重新编译了，导致了新的可执行文件的元数据和core文件中的元数据对不上，这个首先被排除，我们的可执行文件都是从线上直接拖下来的，所以不可能出现这种情况（这里也要告诫大家，千万要保留运行时程序的可执行文件版本，包括.o文件等）；&lt;/li&gt;
      &lt;li&gt;stack已经被破坏了。这种情况很容易就会发生。程序在运行的过程中因为stack，array等溢出的问题没有第一时间被crash，接着在执行命令的时候，产生的core文件stack可能就会被破坏；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;目前来看，我们所能拿到的信息都已经指向了线索中断。操作系统给出的信号不能定位问题，使用gdb调试core因为stack被破坏无法再进一步。那么还有没有别的办法呢？&lt;/p&gt;

&lt;h2 id=&quot;再进一步&quot;&gt;再进一步&lt;/h2&gt;
&lt;p&gt;竟然stack已经被破坏，gdb也无法认出，按照正常的路子是解决不了这个问题了。所以这时候“野路子”（其实是更合理更深层次的解决方案）就上场了。既然被破坏，那就恢复它或者是想办法绕过它。&lt;br /&gt;
恢复stack的难度有点大，你首先得知道core文件所有的元数据信息，然后和可执行文件的元数据信息一一合并，还要考虑程序在runtime状态下的内存状态，难度确实是相当的大。所以这一步首先被排除了。&lt;br /&gt;
那就绕过它。考验计算机操作系统原理和计算机运行原理的时刻来了（所以要多读书）。&lt;br /&gt;
首先我们知道所有的程序都是由cpu来执行机器指令的，和cpu执行指令相互配合的是寄存器，其中有几个寄存器记录了当前程序runtime状态下的地址，比如esp/rsp，ebp/rbp等寄存器。也就是说我如果知道程序crash的时候寄存器的值，可能就有希望能复原当时的stack。
方针已经制定，就看执行了。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;首先看一下各个寄存器的值，如下图:
&lt;img src=&quot;3.png&quot; alt=&quot;regediter&quot; /&gt;
别的都不用看，只要看一下rbp和rsp的值就可以了。
    &lt;ul&gt;
      &lt;li&gt;rsp表示是当时程序runtime的时候栈顶的地址值；&lt;/li&gt;
      &lt;li&gt;rbp表示当时程序执行到的指令的地址值；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;再看一下执行到rbp的指令的时候，程序前面都执行了什么指令，如下图：
&lt;img src=&quot;4.png&quot; alt=&quot;rbp&quot; /&gt;
哈哈，终于看到函数了。spx_socket_connect_nb和ydb_storage_heartbeat_send。按照stack的FILO的原理，是执行到spx_socket_connect_nb的时候程序发生了问题。具体的地址在函数的地址+611处。先看一下汇编，查一下地址看看能不能看出来一点什么？如图：
&lt;img src=&quot;5.png&quot; alt=&quot;code&quot; /&gt;
好像没啥，前面就是给connect构造结构体，后面就是调用connect。但是问题确实是在connect之前就crash了啊。查看一下代码:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; err_t spx_socket_connect_nb(int fd,string_t ip,int port,u32_t timeout){
     struct sockaddr_in addr;
     bzero(&amp;amp;addr,sizeof(addr));
     addr.sin_family = AF_INET;
     addr.sin_port=htons(port);
     addr.sin_addr.s_addr = inet_addr(ip);
     err_t err = 0;
     err_t rc = 0;
     if(0 &amp;gt; connect(fd,(struct sockaddr *) &amp;amp;addr,sizeof(addr))){
         //filter this errno,
         //socket is not connect to server and return at once
         if (EINPROGRESS == errno) {
             struct timeval tv;
             SpxZero(tv);
             tv.tv_sec = timeout;
             tv.tv_usec = 0;
             fd_set frd;
             FD_ZERO(&amp;amp;frd);
             FD_SET(fd,&amp;amp;frd);
             socklen_t len = sizeof(err);
             if (0 &amp;lt; (rc = select (fd+1 , NULL,&amp;amp;frd,NULL,&amp;amp;tv))) {
                 if(0 &amp;gt; getsockopt(fd,SOL_SOCKET,SO_ERROR,(void*)(&amp;amp;err),&amp;amp;len)) {
                     err = errno;
                     return err;
                 }
                 if (0 != err) {
                     return err;
                 }
             } else if(0 == rc) {
                 err = ETIMEDOUT;
                 return err;
             } else {
                 err = EXDEV;
                 return err;
             }
             SpxErrReset;
             return 0;
         } else {
             return errno;
         }
     }
     return 0;
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;确实前面我们就构建了一个struct sockaddr_in的结构体，然后我们就直接connect了。貌似不会出问题，而且代码也已经运行了很久很久了。但是突然间，有种预感冥冥中就出来了。nm可能就这里出问题了。去看一下配置文件，其中的配置项：
&lt;code class=&quot;highlighter-rouge&quot;&gt;stacksize = 64kb&lt;/code&gt;
直刺眼睛啊！火辣辣的。&lt;br /&gt;
这个配置项用来做什么的？其实这个配置项是用来限制系统的stack大小的。也许很多同学都没有听过东东，但是如果你在linux上运行一下命令：
&lt;code class=&quot;highlighter-rouge&quot;&gt;ulimit -a&lt;/code&gt;
&lt;img src=&quot;6.png&quot; alt=&quot;ulimit -a&quot; /&gt;
会出来如上图的一排设置，其中红色框框圈出来的就是这个stacksize的值。在这台机器上默认的是8mb。stacksize的设置在每种linux发行版上的值可能都是不同的。当初就是为了“装逼”，显示自己的编程水平，将stacksize设置成了64kb，这样程序中每个线程最大的stack可用大小就是64kb，你看看我控制系统资源控制的多好？！结果，当碰上一不小心不注意的时候，stack的size马上就超出了64kb，这样stack就溢出了。当然程序就会crash，stack也当然的被破坏了。&lt;br /&gt;
那么为什么我们的会出现这个问题呢？&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;sockaddr_in的结构体其实并不是很大，但是它申请的是stack的内存，原来使用的内存大小+sockaddr_in的大小应该正好碰上临界点；所以sockaddr_in的申请应该是最后一根稻草；&lt;/li&gt;
  &lt;li&gt;ydb_storage_heartbeat_send这个函数是在heartbeat线程中运行的，heartbeat线程是一个常驻线程，由timer事件来触发，每次都会向tracker发送心跳数据，所以可能会存在stack因为某些原因，导致了再一次运行中申请的内存比较多，比如log记日志的时候；&lt;/li&gt;
  &lt;li&gt;那么为什么不起来就出现这个问题呢，而是要在运行了一段时间后呢？这个问题其实没办法确定申请stack的时间点，比如因为网络的问题我需要记录日志，然而又不是时时刻刻网络不行的，正好在某个瞬间网络不行，申请stack内存记录日志，这样没有释放正好被抓到；&lt;/li&gt;
  &lt;li&gt;又因为heartbeat是常驻线程，所以stack基本上不太会被第一时间回收，肯定要在事件处理的最后被回收，所以在一次事件处理内一定要确保有适当的大小来满足程序对于stack的需求；&lt;br /&gt;
原因也找到了，怎么解决这个问题呢？有几种办法：&lt;/li&gt;
  &lt;li&gt;不要装逼了，直接这个项不用设置。我们的程序使用的是事件模型，并不是像java一样的每个connection一个处理线程，dfs是一个线程对应着多个connection，所以线程数并不多，就算是每个线程最大的stacksize是8mb，也用不了多少的内存；&lt;/li&gt;
  &lt;li&gt;把配置文件中的stacksize改大一点，比如1024kb什么的就可以了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;经验教训&quot;&gt;经验教训&lt;/h2&gt;
&lt;p&gt;因为stacksize这个项的设置导致了出问题的人我不是第一个，也不会是最后一个，仅仅在dfs出了这个问题的时候，我就知道还有别人因为同样的问题导致程序被crash，只是当时程序跑的好好的我就没有多加注意。所以在这里诚恳的告诫大家：&lt;br /&gt;
莫装逼，装逼遭雷劈;&lt;br /&gt;
莫装帅，装帅遭人踹;&lt;br /&gt;
莫装吊，装吊遭狗咬…&lt;/p&gt;
</description>
        <pubDate>Tue, 27 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://www.94geek.com/blog/2017/gdb-stacksize/</link>
        <guid isPermaLink="true">http://www.94geek.com/blog/2017/gdb-stacksize/</guid>
      </item>
    
      <item>
        <title>如何更好的做一堂技术topic分享的套路</title>
        <description>&lt;p&gt;很荣幸的被csdn选中担任sdcc2017深圳架构场的出品人。更荣幸的是，我推荐团队一个小伙伴的技术topic也被选中，将在sdcc20017深圳场和大家分享。但这位小伙伴是第一次作为讲师参加技术topic这样的活动，所以培训小伙伴的事情就成了当务之急。作为一个经常出入技术topic、已经无所谓脸皮不脸皮的过来人，对做一堂还算相对“和谐与靠谱”的技术topic到底有多少的套路呢？&lt;/p&gt;

&lt;p&gt;总的来说， 一堂技术topic的套路分为几个部分：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;PPT&lt;/li&gt;
  &lt;li&gt;前期准备&lt;/li&gt;
  &lt;li&gt;分享中&lt;/li&gt;
  &lt;li&gt;结束&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;ppt&quot;&gt;PPT&lt;/h2&gt;
&lt;p&gt;PPT永远是一马当先的部分！ppt在整个的topic中占的比重应该是最大的。原因有几个：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;前期主办方唯一需要并且讲师唯一能证明自己的东西；&lt;/li&gt;
  &lt;li&gt;你所要表达的思想和内容都在这张PPT中；&lt;/li&gt;
  &lt;li&gt;在分享中，PPT也是你主要依赖的对象，是你控制整个topic的主线轴；&lt;/li&gt;
  &lt;li&gt;ppt会被主办方以各种形式下发，以确保影响力；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以我们需要更加重视的对待ppt。按照我目前参加技术topic的讲师经验和这次的出品人经验，总结讲师在做PPT时候注意点有以下几个：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;字体。ppt中的字体要尽量的大。有的同学会问我：具体要多大？能不能给一个明确的号数？答案是然后并没有。但如果可以的话，把字体设置成所能设置的最大号。大到你觉得这页PPT不好看了，就像“老人手机屏幕”一样了，基本上就可以了。也有很多同学不理解，为什么好好的一页PPT字体要那么大呢？作为讲师你必须要考虑现场，ppt的字体小了，topic现场后面的同学看不见。而讲师在做PPT的时候通常是没察觉的，因为讲师做完PPT预览的时候都是在自己的电脑屏幕上进行的，所以并没有现实的距离感。&lt;/li&gt;
  &lt;li&gt;色彩。这里推荐的色彩是“暗色系的底、亮色系的字”。这样的设定可以最大程度的提高对比度，以帮助现场的同学尽可能清楚的看清楚ppt上的内容。在制作ppt的过程中，尽量不要使用中色系的颜色，也不要使用晃眼的亮色系，比如黄色等等颜色，使用晃眼的亮色系颜色在现场再加上投影或者是LED的光源，不仅仅是看不清的问题，而是眼睛会很疼。&lt;/li&gt;
  &lt;li&gt;背景。一般主办方会给你一个他们设定的母版页来作为你整个ppt的基调。但是请大家注意，如果对方给的母版页的背景是很花里胡哨的、或者是背景图画部分特别多（占到整张PPT的25%以上的），这样的就需要讲师自己权衡一下了。要么你自己做母版页自己设定背景，要么就不要背景，直接白色。其实依照我的经验，你拿到的母版页不和你口味的比率占到99%以上。所以在可能得情况下，尽量的自己做背景，而对于技术的topic，强烈推荐纯白色背景。&lt;/li&gt;
  &lt;li&gt;分辨率。目前国内的投影器或者是led屏幕，大部分都是4:3的分辨率，而我们的电脑基本上都是16:9，所以请各位在制作ppt的时候一定要事先和主办方或者是出品人沟通好，现场的ppt屏幕比例到底是多少，然后再开始你的ppt。特别是对于有特效的同学，当你的显示比例不对的时候，动画的效果会很差很差。&lt;/li&gt;
  &lt;li&gt;内容。内容主要分以下几块：
    &lt;ul&gt;
      &lt;li&gt;个人介绍. 个人介绍一般都是必不可少的。毕竟你又不是什么人尽皆知的大人物，在开场的时候做个个人介绍还是很有必要的，一来可以让大家先认识一下你，知道你在哪里做什么工作；二来如果你可以在这个阶段加入一些你公司的产品介绍就更好了，在增加人家对你印象的同时顺便给公司做了一个“软广”。&lt;/li&gt;
      &lt;li&gt;目录。这部分很简单，一般也是必不可少的。&lt;/li&gt;
      &lt;li&gt;正文。正文需要说几个注意点：
        &lt;ul&gt;
          &lt;li&gt;字。在ppt中尽量避免一大段一大段文字的情况。这种大段大段的文字基本上没人看。如果要出现这种文字，首先考虑是不是可以图形化，其次考虑是不是可以用list或者table的方式来表达；&lt;/li&gt;
          &lt;li&gt;图。图除了色彩搭配和上面提到的一样需要注意外还需要注意2个问题。图尽量的大，并且尽量的不要失真。第二，尽量不要使用截图，特别是网页截图。这种截图往往很难拉伸，ppt的展示效果比较差；&lt;/li&gt;
          &lt;li&gt;动态效果。在技术ppt中，动态效果不宜过多（PS：我指的是一页中），一般除非需要表示数据流等动态流程图，否则应该尽量少的使用动态效果。动态效果用的好是画龙点睛，用的不好就是画蛇添足。而对于技术性的讲师来说，往往是后者。所以宁愿不用也不要错用；&lt;/li&gt;
          &lt;li&gt;广告。这是一个非常严肃又非常值得讨论的问题。大多数的讲师都会在ppt中加入广告，99%的讲师会加入招聘广告，虽然大家都知道通过这种方式成功的概率微乎其微，但还是在做。正是印证了一句广告界的名言：99%的广告打下去都是没结果的。但是为什么大家都在打呢？因为不知道那1%是在哪里！这里要提醒各位的是，做广告可以，但是吃相不要太难看。比如在topic上写上别人家的活动报名方式什么的，这种就有点夸张了。至少也要尊重一下本次的主办方吗；第二，广告尽量使用“软广”的方式，那种硬性植入就能免则免，太欠缺水平了，也没有情怀和b格；第三，大家可以把Q&amp;amp;A页利用起来，上面放一个公司或者你自己的开源github二维码、公众号二维码之类的图片，让大家觉得你不是在做广告，而是在增加联系。归根结底一句话：广告要做的有水平，不要让人家一眼就看出来你这是在做广告，要有b格和情怀，要有b格和情怀，要有b格和情怀！重要的事情说3遍。&lt;/li&gt;
          &lt;li&gt;页数。 一场topic大概用时一般在45分钟，很少有1个小时的，也很少有低于45分钟的。所以对于讲师来说，你真正拥有的时间大概在30-40分钟之间。那也就是意味着你的ppt页数不能太多，也不能太少。基本上控制在有效页数在15-18页，最多不超过20页、不要少于12页就可以了。虽然我也见过50页ppt半小时讲完的，或者是3页ppt讲2个小时的，但是这种人毕竟是少数。我自认为你不是这种人。有效ppt，是指你真正讲内容的ppt。中间有一些穿插的标题、不展开的结论、ppt转换等这些都属于一带而过的，所以它们并不是有效ppt。那么除了这些，剩下的的ppt，包括了topic大部分真正内容的页，这些都是有效ppt。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pdf。一般做完ppt后也要同时提供一份pdf给主办方，作为主办方现场或者是会后发放的内容。这份pdf大家一定要注意，一定要脱敏，特别是公司的一些数据，个人的信息等等。一定要进行脱敏处理后再发送给主办方。&lt;/li&gt;
  &lt;li&gt;交稿时间。一般都是认为越早越好，但我觉得不是。最好的时间应该是开始前2个星期开始做ppt，花几天构思，然后花1天完成。这样可以安排在最后期限的前一个星期这个时间点上提交你的ppt。这个时间点的好处是，首先你至少不会到了现场忘记了ppt，也不会因为你要参加topic影响你的工作；第二，你也需要给出品人一点时间来审核你ppt；第三，你还给了你自己一点时间来修改和完善你的ppt。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;前期准备&quot;&gt;前期准备&lt;/h2&gt;
&lt;p&gt;等交稿一个星期后，基本上你的技术topic分享也要开始了，在分享的过程中，也需要几个注意点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;到达时间。建议大家尽量提前达到topic举办的城市。一般也不用提前太多，前一天晚上到，第二天分享就可以了。通常主办发会在topic举办的酒店或者就近酒店给你开房间，所以你去了以后尽可能的先去现场转转，特别是你要分享的分会场现场，去看看大体的布局、投影的效果、讲台的位置等等。这样至少能做到前期心中有数。&lt;/li&gt;
  &lt;li&gt;设备问题。建议大家最好能自己带上笔记本，如果有条件的话可以自己带好演讲笔。这个不是必要条件，但以防万一。特别是技术同学，现在很多技术同学使用的都是mac，经常提交的是keynote，而国内目前windows还是非常的通用，所以现场可能会出现ppt放不出来或者ppt有问题等等。不过就算你用的windowns+ppt，有的时候也会因为系统或者ppt的版本不同而发生问题，所以最好还是带好自己的笔记本，出现问题的时候可以立即就解决。&lt;/li&gt;
  &lt;li&gt;最后一眼。在分享的前一天晚上，或者你的topic安排在下午的话就是当天上午，尽量抽时间最后看几眼ppt，查漏补缺一下。这是在分享前最后更新ppt和分享知识的机会，也可以再一次熟悉一下自己要讲的ppt和要讲的内容。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;分享中&quot;&gt;分享中&lt;/h2&gt;
&lt;p&gt;就要来到分享现场了，大家是不是有点紧张？这里就来讲讲分享现场需要注意的问题。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;紧张。首当其冲的就是紧张问题。不管你是新手还是“老司机”，其实都会紧张的。特别是马上要轮到你了，还没轮到的时候，心理都会有一些波动。这种紧张或者叫担心是很正常的。老司机可能在开始的时候就变的正常了，而新手还是会紧张。这里想和大家说的是，不要太担心，经过上面的准备后，这个环节应该不会有什么大问题。你站在讲台上，相比下面的听众，你有更多的天然优势。你分享的内容你是最熟悉的，下面的听众都没有你熟悉，所以你只要按照你前期的准备按部就班的下去就可以了。&lt;/li&gt;
  &lt;li&gt;怎么讲。这里也需要分几个部分来讲：
    &lt;ul&gt;
      &lt;li&gt;脱稿。首先是要尽量的把ppt串起来，并且在分享的过程中除了需要使用演讲笔现场指出来ppt上的部分内容外，总体上需要脱稿。这也是为什么我在上面强调的：不要太早的做完ppt的原因之一。在整个分享过程中要注意节与节之间的衔接部分，这里特别容易“卡壳”。&lt;/li&gt;
      &lt;li&gt;单页讲解。单页讲解的时候最怕的就是口语。比如很多同学喜欢用“然后”，“嗯”，“下面”，“接下来”……这种的口语化的表达方式，而且是重叠的出现这种，比如一页ppt中不停的“然后”…“然后”…“然后”…。这是很不可取的。一般一页ppt总归有个前后关系，所以最好的方式是多使用层次性的词语来表达，比如“首先”…“然后”…“其次”…“接着”…“最后”…,或者是“第一”…“第二”…“第三”…。&lt;/li&gt;
      &lt;li&gt;肢体语言。在分享的时候，一般一手拿着麦克风，一手拿着演讲笔，幸好人类没有第三只手，否则更乱了。所以很多同学都是拿着麦克风的那只手举着（没办法，至少要说话），而拿着演讲笔的那只手不知道在干嘛。有的垂的，有的乱晃，还有的直接插兜里（PS：虽然我也觉得插兜里挺帅挺个性）……，这些希望大家都不要出现。拿着演讲笔的那只手可以适当的做一些动作，不要太夸张也不要一动不动。适当的做一些动作可以让大家觉得你更融入此次的分享中，也可以让大家更加接受你分享的内容。至于这个度，需要自己把握，确实挺难。&lt;/li&gt;
      &lt;li&gt;掌控讲台。大家千万不要在讲台上一动不动的站着，从上去到下来都在一个地方；或者是直接站在演讲台那边，看着ppt在那里好像在做政府工作报告。你可以适当的在讲台上走走，你要清楚你是讲师，这个讲台在这个45分钟内是属于你一个人的，何必那么拘束呢？一般技术topic的讲台都是一个高于听众的地方，长方形，也不是特别的大。但是绝对在中间。你在讲台上适当的活动一下相比站在一个地方不动，可以照顾到下面更多的同学。可以让大家更好的融入到自己的分享中。&lt;/li&gt;
      &lt;li&gt;提问互动。关于这点公说公有理婆说婆有理的问题确实不好办。但依据我的经验，在分享的过程中尽量避免和下面的听众进行沟通和对他们提问。尽量的少问“这个问题大家知道吗？”，“这个有谁知道吗？”这种问题。首先，你对下面听众的情况不熟悉，你这么“唐突”的提问很少能拿到你想要的答案；其次，这种提问几乎都会冷场，很多最后都是讲师自己尴尬的打圆场过去，很少有人会举手回答，就算有也是你要多次的确认“有人知道吗？”；第三，这是技术分享，不是培训。这点要分开。公司内部的培训可以经常使用这种提问方式，但是演讲不太适合，培训的人数一般只有十几个甚至最多也就几十个，如果人数多了就会分批，规模上好控制，而演讲这种的一般至少100-200人吧，会场也很难控制。&lt;/li&gt;
      &lt;li&gt;段子。不要笑，这是一个很严肃的问题。特别是对于在中间分享的讲师，一定要准备3-4个段子。一般大家在长时间的集中精神后，中间有段时间特别累。其实我们自己也有感觉，你坐在下面听一下试试看，一个上午就受不了了，比上班还累。所以在分享的过程中需要穿插适当的段子来把听众的小差给开回来。当然了也不排除很多同学就是为了听你的段子来的。老罗曾经说过：我讲的题你们都没记住，我讲的段子你们倒是记得清清楚楚，过后还久久回味、栩栩如生。&lt;/li&gt;
      &lt;li&gt;时间控制。这个主持人一般都会帮你。有做的比较好的，比如csdn，会给你一个大大的ipad，给你看从开始到结束的剩余时间倒计时；没有这种ipad，也会有一个最后5分钟，最后3分钟，最后一分钟这样的倒计时提醒牌。有倒计时和没倒计时是一把双刃剑。有吧，总感觉有人在催你；没有吧，总会超时。所以归根结底这还是需要大家多加练习自己的ppt，学会控制时间。这里要说的是尽管很多时候最后肯定会拖时间，但是大家要注意，千万不要拖太多就可以了，拖一个2-3分钟没人会说你，因为主持人会灵活掌握下面同学提问的时间，但有一次我也是讲师，我前面的一个哥们拖了15分钟之久，这就太夸张了。而且TMD拖时间是因为他要做广告，这就让我很无语了。所以我对这个哥们印象很不好，大家都在这个圈子混，名字我就不说了。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;出现意外。这很正常，比如下面突然有人叫起来：这玩意那里听过，或者是这个ppt我看不清楚。出现这种情况首先是千万不要紧张，也不要不知所措。你可以先安抚一下听众，第二，赶快和主持人沟通怎么解决问题，是不是能把ppt的pdf文档下发下去之类的。这里要说一下，如果你的ppt因为公司保密原因不能下发，那么请各位讲师要和主办方、主持人事先沟通好，商量好万一出现问题的时候怎么解决。这种事情不是没有发生过，我就见过因为这个事情现场闹得不可收拾的。这样对大家都不好，特别是对讲师所在的公司名声影响很差，还不如不要出来做这次分享呢！&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;结束&quot;&gt;结束&lt;/h2&gt;
&lt;p&gt;一般分享结束后，剩下的就是听众提问和讲师解答的阶段了。到这里其实才是最考验各位讲师内功的，因为提问环节基本上你不太可能能全部掌握。就算你前面准备的再好，这部分可能最多你也就只能覆盖到70%。那么这部分会经常出现哪些问题呢？&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;问题超纲。这里的超纲是指超出了讲师的知识所掌握的范围。对于初次作为讲师的同学可能是非常容易碰到的。其实这个并不可怕。解决这个问题的本质还是要奉劝大家平时多加注意积累，多加注意同类型开源软件或者是同类型开源论文等东西，只是临时抱佛脚是解决不了这个问题的。但如果你已经站到讲台上了，碰上这种问题你再告诉是靠积累，你这确定你不是在开玩笑？所以一种办法是你确实回答不上来，那么就大方的承认这个你没考虑过，后面再看看；另外一种可能的情况是你其实知道一些，但是知道的知识并不是特别的清楚，没有十足的把握也没有那么的全。这种情况下你就找几个你有把握的，可以回答这个问题中的几个点就可以了。一般主持人看见这种情况也会帮你解围的。&lt;/li&gt;
  &lt;li&gt;一直追问。 这个是对于下面的听众来说的。如果某个哥们一直霸占着话筒怎么办？这个任务一般是主持人的。他会解决这个问题。我的经验是一般一个人提问一次后我就收走话筒了，一来可以给另外的同学更多的提问机会；二来，还可以兼得保护讲师。但是如果主持人也无动于衷，那你就可能需要自己解决这个问题。在回答完他的问题后，你可以带一句“这位同学，下去了我们微信交流，希望现场能有更多的同学提问”这样的话来结束这个同学的提问。&lt;/li&gt;
  &lt;li&gt;一人多问。这个也很正常。一般一个人的记忆力是有限的，所以你可以一个一个的来回答他的问题。但是一般首先强调一下一次提问最好不要超过2个，最多不要超过3个，因为实在是记不住。如果问完了还是有问题那就私底下微信交流。&lt;/li&gt;
  &lt;li&gt;现场群。多看一下群，万一有同学问到你，如果你不回答的话就显得不太好，所以还是要照顾一下群里的反应。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;套路，都是套路。写书有写书的套路，程序有程序的套路，分享也有分享的套路。大家都是按照套路在办事情。目前根据我的经验，基本上作为一个讲师，所能想到的套路就那么多。但是套路归套路，归根结底，还是希望大家如果有志想挑战一下自己，有一天也想站上讲台的话，在套路的同时也一定要对于分享这件事情多加练习。其实每个讲师虽然会使用套路，但是私底下还是很努力练习的。这次我们上sdcc的小朋友在事前被练了一个多星期，用他的话说被练的自己都不知道怎么了。ppt在公司内部走了有4-5遍。先是我们几个内部听，提出问题、整改；然后是部门内部听，提出问题、整改；然后再是我们内部听，提出问题、再整改，以此反复。所有的好分享除了套路更多的还是建立在多加练习、熟能生巧、以勤补挫的基础上的。大家千万不要以为会了套路就会打拳了，这仅仅只是招式，内功还是要靠自己一点一点，日积月累而成的。&lt;/p&gt;

</description>
        <pubDate>Thu, 15 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://www.94geek.com/blog/2017/how-do-topic/</link>
        <guid isPermaLink="true">http://www.94geek.com/blog/2017/how-do-topic/</guid>
      </item>
    
      <item>
        <title>SDCC2017 深圳架构场前瞻</title>
        <description>&lt;p&gt;首先很荣幸的被csdn邀请为sdcc2017深圳架构场的出品人参与此次topic。作为出品人，在演讲嘉宾的筛选上就已经动了脑筋。此次sdcc2017，演讲嘉宾的阵容是非常强大的，既有腾讯、阿里、百度传统3强的分享，又有唯品会、阅文集团、sina微博等公司的强势加入。各位演讲嘉宾也都是业界的“老司机”，不管是从技术还是演讲本身来说，都是“老”的可以啊！所以sdcc2017深圳架构场的技术topic水平当然不会低，是绝对值得期待的。&lt;/p&gt;

&lt;p&gt;当出品人还有一个特权就是可以提前看到各位演讲嘉宾的PPT。此次架构topic的PPT在各位“老司机”动不动就“一言不合”加大马力“飙车”的情况下各个卓越超群，各显神通。这里我就先瞒过csdn的小编来报个料。&lt;/p&gt;

&lt;h2 id=&quot;上午&quot;&gt;上午&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;首先登场是来自阿里的中间件架构师冯嘉，他为大家带来了来自阿里中间件团队自我研发的消息队列中间件“RocketMQ”。大家都知道阿里面临的访问、流量、正确性等一系列的压力；也明白在这些压力下程序员所要面对和承担的技术困境。RocketMQ在经过阿里内部多年的开发和使用后，顶住了压力（特别是“丧（疯）心（狂）病（数）狂（钱）”的双十一）。同时也因为出色的性能表现和卓越的稳定性，RocketMQ加入了Apache基金会。此次topic，冯嘉主要为大家带来了RocketMQ的什么呢？可以用下面几点来概括：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;首先是阿里使用RocketMQ的历程，从使用开源软件到自我研发RocketMQ的煎熬和解脱；&lt;/li&gt;
  &lt;li&gt;RocketMQ的实现。此次的topic可以说是毫无保留的全部拿出来了。包括mq的内部存储结构图都一清二楚的画出来贡献给大家看了，真是印证了那句话：是骡子是马拉出来溜溜；&lt;/li&gt;
  &lt;li&gt;接着可能是大家最关心的RocketMQ具体的特性和性能。特性和性能可以让大家在选型和使用的时候更加的安心；&lt;/li&gt;
  &lt;li&gt;最后是RocketMQ的监控与后续发展。这部分可以确保大家更加方便的使用RocketMQ；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;紧接着登场的就是来自新浪微博的技术专家陈波，他为大家带来了“微博Feed的缓存架构及其演进之路”。微博的用户量亿级也是妥妥的、pv，并发更是不用讲了，大家心里都有数。所以他们在组织feed的确实也碰到了很大的困难和很多的现实问题。此次topic，陈波主要为大家带来了feed缓存的3个主要方面：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;首先是feed平台的总体架构，说明了feed在微博整体架构中所占的重要位置和实际碰到的问题；&lt;/li&gt;
  &lt;li&gt;解决feed所使用的cached的架构极其实现；&lt;/li&gt;
  &lt;li&gt;接下来是此次topic的亮点，对redis更好使用的案例。这部分应该会有很多人想一探究竟，毕竟redis几乎已经成为高性能网站的“威尔刚级” 产品了，现在还有谁敢说不用redis？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上午的最后一场topic来自于腾讯的架构平台部高级工程师陈杰，他为大家带来的是“基于空闲资源的弹性计算实践
”。弹性计算，虽然一直在说，但是对于目前的行情来说其实还算是一个比较新的领域，或者说是对普遍的大家一个比较陌生的领域。这是因为很多公司根本就没有这个精力也没有这个实力更是没有这个必要和动力去研究这个东西，但是它却是大企业或者说是云计算必须要面对的一个问题。如何更好的去利用空闲的机器已经是很多像腾讯、阿里等一样规模的大型互联网公司不得不也是必须要去面对和解决的一个问题。这次topic陈杰给大家主要从以下5个方面来讲解弹性计算：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;首先是弹性计算在企鹅内部的需求。从企鹅的实际需求出发，可以让各位清楚的知道什么情况下或者说什么状态下弹性计算是必要的；&lt;/li&gt;
  &lt;li&gt;实现弹性计算的难点。这应该是业界的一个难题，可以看看企鹅是怎么去解决这个问题的；&lt;/li&gt;
  &lt;li&gt;“4步法”解决企鹅弹性计算在线业务的质量保障。你问我哪四步？我先卖个关子；&lt;/li&gt;
  &lt;li&gt;“3步法”解决企鹅弹性计算怎么使用好。又要问我哪三步？我是想说的，但是被csdn的小编给删除了！&lt;/li&gt;
  &lt;li&gt;最后是企鹅弹性计算团队在实施弹性计算的过程中碰到的问题和其解决办法。这是企鹅弹性计算团队的知识结晶，大家不容错过啊！&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;大家可以先吃点饭，休息一下！下午更精彩哦！&lt;/p&gt;

&lt;h2 id=&quot;下午&quot;&gt;下午&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;下午首先登场的是来自唯品会的架构师薛珂，他为大家带来了唯品会内部使用的“弹性调度平台Saturn的架构设计”。Saturn说白了就是一个Job系统，但是Saturn相比其它的Job系统有它独到的地方，而且也有更多的特性，主要的亮点在于以下4个方面：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;job的无语言限制支持。可以支持目前常见的各种语言，甚至是shell脚本也可以无缝的运行；&lt;/li&gt;
  &lt;li&gt;触发机制支持事件和时间。目前市面上更多的Job基本上都只支持时间触发机制，最复杂也就是用Cron表达式，所以Saturn支持事件是一个亮点；&lt;/li&gt;
  &lt;li&gt;支持任务分片和根据机器负荷动态负载平衡。支持分片的Job很多，但是根据Job执行机器的系统运行指标来动态调整job执行的负载均衡是一个不错的想法和实现，也是Saturn的一大的亮点；&lt;br /&gt;
4.支持云部署。云是目前最火的一种架构模式，Saturn也不例外的支持了。从这点上也可以看出Saturn是走在技术架构时尚前沿的弄潮儿啊。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;虽然这时候大家可能有点困了，但是千万不要瞌睡，错过了好戏我可不负责！&lt;/p&gt;

&lt;p&gt;下面出场的是来自百度网页搜索部的资深研发工程师陶清乾，他为大家带来的是前端架构：“基于PWA的Web App前端架构探索与实践”。这是此次深圳架构场唯一一场前端架构topic的分享。他主要为大家从以下3个方面讲解百度在实际的工作中使用PWA架构移动Web App的经验：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;目前移动端web碰到的困境和百度所使用的解决方案；&lt;/li&gt;
  &lt;li&gt;PWA技术的价值与在百度使用过程中的效果。这部分大家应该可以从现在百度的部分app中就能感受出来吧？不过亲身听一下设计人员的讲解可能会更加的事半功倍！&lt;/li&gt;
  &lt;li&gt;前端架构新思路。从离线化、视图框架、异步渲染和交换感4个方面来说明前端架构设计的新思路；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第三场来自于前卷皮网架构部技术总监陈秋余，他为大家带来的是“领域模型 + 内存计算 + 微服务的协奏曲：乾坤”。这场也是此次唯一一场分享目前比较流行的“微服务” 的技术topic。领域模型是一个架构中经常会碰到的问题，也是几乎目前的系统中主要的组成部分；内存计算大家也都耳熟能详；至于微服务嘛，最近火的不要不要的。那么这3个精兵强将组合在一起能碰撞出多少的火花呢？卷皮网给出的答案就是“乾坤”系统。这场topic将从4个方面对于“乾坤的火花”进行阐述：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;特卖类电商的微服务架构。这是很多传统电商都不会碰到的问题，偶有幸（也是不幸）碰到过。很早之前在5173任职，5173虽然不属于一个传统电商网站甚至都不属于特卖类网站，但是游戏交易，几乎有和特卖类电商有着一模一样的业务和架构痛点。其痛点就两个字：“比快”。不管是特卖还是抢购，其实比的就是一样：顾客“手快”的情况下网站不down机并且快速且正确的响应！&lt;/li&gt;
  &lt;li&gt;目前主流分布式架构及其问题。这部分主要分析了特卖类网站和目前主流分布式网站架构的矛盾之处，笔者看过后满满的“惺（泪）惺（流）相（满）惜（面）”；&lt;/li&gt;
  &lt;li&gt;解决高并发争抢的性能问题：无锁排队。这种解决方案现在越来越多的被提及。我们自己开发的很多中间件也都是使用了类似的解决方案来处理这个问题。到底怎么处理？还是来听听吧！说多了你就不买票了！（这不是偶的本意，csdn小编改的，你们可以去找他）&lt;/li&gt;
  &lt;li&gt;分布式事务的一致性模型。其实大家从开始分布式架构系统开始就碰到了事务这个难题。虽然时间很长久，但是一直到现在为止，都没有一个统一的、标准的实现方案方法。基本上都是各家根据各家的实际业务模型和情况再结合2PC、3PC或者及其变种来实现解决。当然乾坤也不例外了；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后一场是来自阅文集团。这里不得不多夸奖几句阅文集团。阅文集团这几年越来越多的参与各种技术开源和技术分享，阅文集团的技术也正在慢慢变的成熟。这里也希望阅文集团能够越来越多的帮助到各位在技术上碰到的问题。（哈哈！这个不得不说，是偶“不要脸”了。的确是“硬广”，纯粹不要脸的那种“铁硬广”）。PS：小编别删了啊，看在偶半夜写文档、也没有大尺度的上二维码的份上，留点面子。另:我们开源的二维码是…&lt;/p&gt;

&lt;p&gt;言归正传，最后是来自阅文集团的架构师帅翔为大家带来的“PB级去内存化分布式缓存系统Lest的架构设计与实践”。对于帅翔偶还是比较了解的，因为天天被偶“虐”。Lest项目也是我们目前的重点项目，它主要的作用就是用来在生产环境替换掉目前阅文集团内容中心存在的大量主动缓存redis。对的，你没听错，我们准备下架一部分的redis。其实对于redis，大家也都心知肚明：随着redis的大量使用，基本上最后就是失去控制。病理表现：redis服务器或者redis内的缓存内存只加不减。那这是为啥呢？因为里面有点啥，有的时候你真的很难搞得清楚，哪怕你是一手做起来的，并且管理起来的，久而久之就这样了。这基本上也是现在很多公司共同碰到的难题之一。另外一个问题，也是一个很大的问题：redis是基于内存的，虽说现在内存白菜价，但是毕竟还是要成本。当你大量使用的时候，成本还是挺大；而且基于内存的一down或者重启，基本上就废了，有多少公司因为redis出了问题导致了站点down掉？所以用武侠来形容redis呢，我认为就是“离别钩”。不用吧不行，用吧闹不好自伤。那么我们解决这些问题的办法就是Lest！此次帅翔给大家从以下几个方面来讲述lest的前因后果：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;首先是Lest研发的原因和其总体架构。原因前面唠叨过了，这里说一下架构。相比redis，Lest增加了一层tracker来做一个统一的cached分配算法和存储的管理。这样的好处除了可以更好的管理cached内容，还能可以让业务系统和具体的分配算法隔离开，可以让业务系统更加的灵活；&lt;/li&gt;
  &lt;li&gt;数据的存储。和上面阿里的RocketMQ一样，我们也是无所保留的贡献出来所有的设计思路和方案，包括具体的磁盘存储格式。其中Lest使用的二进制协议，来自于messagepack的“阅文DIY升级版hermas”更是亮点，它既可以用来做网络通讯，又可以满足磁盘存储，lest的成功实施很大程度上是hermas的功劳；&lt;/li&gt;
  &lt;li&gt;数据的同步和性能测试。lest相比于redis就是“在尽可能少损失性能的基础上多了最后一致性和持久化”。众所周知，同步和持久化肯定会是性能的杀手，那么这部分就是讲述了lest用了什么技术和方案来去解决这个问题；&lt;/li&gt;
  &lt;li&gt;最后是lest目前所存在优点与缺点。诚恳的分析lest的先进性和目前所存在的问题，以及以后可能的发展方向，为大家以后的选型扩展了思路。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;原本小编说只要1k字就够了，结果轻描淡写的就妥妥2k+了。这是因为参加此次技术topic分享的各位“老司机”飙车实在太厉害，偶也跟着“鸡血”了一把！对于这么多位高手云集的sdcc2017深圳架构场，你是不是已经手抖的都握不住鼠标拼命要去点击“购票”了呢？我们现场见吧！&lt;/p&gt;

</description>
        <pubDate>Wed, 07 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://www.94geek.com/blog/2017/sdcc2017_%E6%B7%B1%E5%9C%B3%E6%9E%B6%E6%9E%84%E5%9C%BA%E5%89%8D%E7%9E%BB/</link>
        <guid isPermaLink="true">http://www.94geek.com/blog/2017/sdcc2017_%E6%B7%B1%E5%9C%B3%E6%9E%B6%E6%9E%84%E5%9C%BA%E5%89%8D%E7%9E%BB/</guid>
      </item>
    
      <item>
        <title>Chaos-ID生成器的前世今生</title>
        <description>&lt;p&gt;从mongodb的objectid到twitter的snowflake，目前国内的几个互联网大厂也开始重视到了分布式系统中数据id，甚至一些大厂已经公开了它们关于id生成器的设计和实现。我们当然也注意到了分布式系统中id的重要性，并且在系统开始开发的时候就设计并且实现了一个id生成器，我们称之为：Chaos。Chaos目前已经在我们内部运行了2年之久，在这2年内故障率为惊人0，可靠性达到不可思议的100%。那么我们为什么要设计Chaos呢？Chaos又和别人家的id生成器有什么不同呢？这些问题，首先得从我们以往的经验开始。&lt;/p&gt;

&lt;h2 id=&quot;过往使用id的经验&quot;&gt;过往使用id的经验&lt;/h2&gt;

&lt;h3 id=&quot;int自增&quot;&gt;int自增&lt;/h3&gt;
&lt;p&gt;通常情况下，说到id，我们第一个想到的就是int自增类型。它被各种“最佳实践”、教科书、论文…所推荐。然而，在现在这个信息爆炸的年代，自增id已经老态龙钟，显露颓势了！&lt;br /&gt;
从学校到社会；从教科书到实践；从办公自动化到erp再到现在的互联网和大数据，不管什么时候，不管什么年代，我们接受到对于数据id的设计原则都来源于《数据库原理》这本书：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;唯一标识，确保不重复；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;确保主键是无意义的；&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;首推采用int作为主键值；&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;减少主键的变动；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在单机、单数据库、dal+proc的年代，这些原则是可取的、现实的最佳实践。依照这些原则我们也一直用的很好。直到有一天，数据猛增，单表破千万甚至上亿，需要考虑拆分表甚至拆分库的时候，问题来了：&lt;br /&gt;
&lt;strong&gt;每个表的主键都是自增，数据库扩容怎么玩？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;int-mdb.png&quot; alt=&quot;int自增多表示意图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进过一番寻找，在数据库的int自增中找到一个属性：步长。可以根据数据表的个数来设置步长，这样就不会重复了。比如将一个单表分成3个表，那么就把步长设置为3，3个表的id就会按照如下的方式来增长：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;table-1 : 0,3,6,9,12…&lt;/li&gt;
  &lt;li&gt;table-2 : 1,4,7,10,13…&lt;/li&gt;
  &lt;li&gt;table-3 : 2,5,8,11,14…&lt;br /&gt;
这种办法确实解决了id可能重复的问题，但是同时带来了一个很让人抓狂的问题：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;每次扩容，都需要根据数据库表的数量来定义步长，一旦有疏忽，整个数据将会受到灾难性的破坏，最严重的情况下，数据根本无法重新平衡&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所以int自增只能在单表的情况下才有最好的表现，一旦数据超过单表的最大限度，扩容是一件很麻烦的事情。&lt;/p&gt;

&lt;h3 id=&quot;string类型&quot;&gt;String类型&lt;/h3&gt;
&lt;p&gt;因为int自增id相当难扩容，我们想起了string。其实当时不是没有想过用int来自己组合一个id，但是因为那个年代普遍还是x32机器，x64刚刚开始起来，很多系统还没升级到x64，所以对于当时的系统来说，int的值太小了。一个id需要包含很多的信息，特别对于分布式系统来说，&lt;strong&gt;包含业务信息简直就是一定需要的&lt;/strong&gt;，（PS：这里不得不说一下：我们的教材很多时候不能与时俱进。各位谨记：理论是理论，实践是实践。）所以我们第一想到了GUID（UUID）。&lt;/p&gt;

&lt;h4 id=&quot;guiduuid&quot;&gt;GUID/UUID&lt;/h4&gt;

&lt;p&gt;GUID作为id确实规避了int自增的一些问题，对于GUID来说：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;肯定是唯一的，几乎不太可能碰见碰撞的问题；&lt;/li&gt;
  &lt;li&gt;也没有业务的意义，都是根据统一的规则（并非业务规则）生成；&lt;br /&gt;
看上去倒是一个很好的id解决办法，确实也有很多公司在使用它，但是GUID也存在几个问题：&lt;/li&gt;
  &lt;li&gt;表的切分貌似只能有一种方法来确定：hash（guid）% table-count；&lt;/li&gt;
  &lt;li&gt;无法排序，对表的主键并不友好；&lt;/li&gt;
  &lt;li&gt;因为无业务意义，所以人类的识别度不高；&lt;br /&gt;
那么这些问题怎么解决呢？既然GUID的字符串都可以，那我们把字符串变成自定义的不就妥了嘛？&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;自定义string&quot;&gt;自定义String&lt;/h4&gt;
&lt;p&gt;自定义String是我们当时的解决方案。相比于GUID，自定义String有太多的优势：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;自定义的string可以塞入任何你想要的信息，可定制性很强；&lt;/li&gt;
  &lt;li&gt;轻松的实现分库分表运算，并且不仅仅限制在hash算法；&lt;/li&gt;
  &lt;li&gt;人类的识别度很高，可以用字符串明确的标识；&lt;/li&gt;
  &lt;li&gt;可以使用本地生成，根本无延时；&lt;br /&gt;
虽然string的id优势明显，也解决掉了切分方法和识别度的重要问题，但最重要的几个缺点还存在：&lt;/li&gt;
  &lt;li&gt;string太长，且对于的运算过慢；&lt;/li&gt;
  &lt;li&gt;对排序和索引支持很不友好，对主键的索引块是破坏性的；&lt;br /&gt;
就这些缺点来说，在当时还是可以接受。但是在现在这个时代，已经不可能了，那我们到底要什么样的id呢？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;重要但很少考虑的问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里主要说一下id对于数据库索引的支持不友好问题！众所周知，我们目前使用的数据库，不管是sqlserver，oracle还是mysql，数据库的索引几乎都是清一色的btree或者是其衍生版。&lt;br /&gt;
在数据库的主键中，当插入数据的时候（假设我们从来不会更新主键信息，一般也确实不会更新），db会主动维护一个btree结构，这个结构最终会序列化磁盘上，在磁盘上，索引的格式我们简化如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;string-pk-1.png&quot; alt=&quot;btree磁盘结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每一小块表示一个id对应的信息，每一大块表示磁盘的文件块大小，每个索引最后都会被像这样子连接起来。如图看起来好像没问题，那么问题来了，如果我要插入一个id=15的值呢？结果就会像下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;string-pk-2.png&quot; alt=&quot;btree插入磁盘结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因为前后的索引磁盘块都已经占满（或者是到一个阀值），数据库就会主动将原来的索引链断开，插入新数据，再连接上彼此的上下级索引。这种操作相比依次的插入，会带来更多的磁盘io。&lt;br /&gt;
然而，如果使用string类型的id（特别是guid），因为没办法确定顺序，所以拆开索引-插入索引的操作将会经常发生，性能当然会有问题了。&lt;/p&gt;

&lt;h2 id=&quot;初涉id&quot;&gt;初涉id&lt;/h2&gt;

&lt;h3 id=&quot;基本分析&quot;&gt;基本分析&lt;/h3&gt;

&lt;p&gt;在业务系统中，很多地方都会用到id，主要的地方有几种：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;书、卷、章节等id；&lt;/li&gt;
  &lt;li&gt;分布式系统中，系统调用的错误码；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于id的几个需求：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;最基本：作为数据库记录的主键；&lt;/li&gt;
  &lt;li&gt;加强型：被索引，对索引友好；&lt;/li&gt;
  &lt;li&gt;附带价值：作为分库分表的依据；&lt;/li&gt;
  &lt;li&gt;扩展功能：对象唯一标识，比如sessionid、批号、错误号；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体的分析一下在业务规则下的id，它必须具有以下的一些特性：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;分库分表：因为分库分表的方式各种各样，并且会随着业务的变化而变化，所以对于id来说，它必须要包括时间戳、随机数、类型位、数据库标识等几种最基本的属性，以供各种分库分表的方法使用；&lt;/li&gt;
  &lt;li&gt;高可用性：机器位，这是为了分布式系统中id必须唯一而设置的；&lt;/li&gt;
  &lt;li&gt;数据可读性必须强；&lt;/li&gt;
  &lt;li&gt;递增还是随机？每秒递增？？累加递增？？&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;基本诉求&quot;&gt;基本诉求&lt;/h3&gt;
&lt;p&gt;必须要具备以下一些功能或者说特性：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;唯一，必须唯一；&lt;/li&gt;
  &lt;li&gt;短，尽可能的短；&lt;/li&gt;
  &lt;li&gt;生成速度足够快；&lt;/li&gt;
  &lt;li&gt;运算足够简单，快速；&lt;/li&gt;
  &lt;li&gt;附带实体业务信息，比如时间、类型等；&lt;/li&gt;
  &lt;li&gt;部分信息可以自定义，比如路由信息；&lt;/li&gt;
  &lt;li&gt;不仅机器能识别，人类也可以识别；&lt;/li&gt;
  &lt;li&gt;对索引友好；&lt;/li&gt;
  &lt;li&gt;根据业务规则，能自定义排序等业务规则；&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;基本方向&quot;&gt;基本方向&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;必须足够短，最好是uint32，最长uint64；&lt;/li&gt;
  &lt;li&gt;必须系统原生支持，不需要扩展类型；&lt;/li&gt;
  &lt;li&gt;比较运算足够快；&lt;/li&gt;
  &lt;li&gt;必须递增，可排序并对索引友好；&lt;/li&gt;
  &lt;li&gt;id必须带业务性质，符合望文生义原则，通过id可以知道这个数据存在的数据库、表等信息，如果是错误号，必须能知道所发生的服务器；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;id的水还是很深的&quot;&gt;id的水还是很深的&lt;/h2&gt;

&lt;h3 id=&quot;snowflake&quot;&gt;snowflake&lt;/h3&gt;

&lt;p&gt;考虑实现id，twitter的snowflake算法是一个无法回避的问题，分析snowflake的算法，它有几个重要的特点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;首先：snowflake由时间戳-机器位-随机数组成，分别是41位、10位、12位&lt;/li&gt;
  &lt;li&gt;其次：snowflake选择了使用uint64类型，所以在这个算法下，最大值就是0XFFFF FFFF FFFF FFFF；&lt;br /&gt;
来看一个例子，比如有一个数：&lt;br /&gt;
&lt;strong&gt;9223  3720 3257 7650 688&lt;/strong&gt;  &lt;br /&gt;
这个数代表了什么意思呢？首先得分析它的二进制，这个数的二进制是：&lt;br /&gt;
&lt;strong&gt;0111 1111 1111 1111 1111 1111 1111 1111 0000 0001 0001 0000 0100 0000 0000 0000&lt;/strong&gt; &lt;br /&gt;
然后通过snowflake的组成机制，算得这个数的真实要代表的数：&lt;br /&gt;
&lt;strong&gt;2199023251472-264-0&lt;/strong&gt;&lt;br /&gt;
不得不说，这种二进制移位的方法对于机器来说非常的简单、运算也更快，但是对于程序员来说，简直就是天书。所以snowflake算法我们并不满意，对于snowflake不满意的并不仅仅“把技术人员不当人”这一项，还有2个业务的问题snowflake也无法解决：
    &lt;ol&gt;
      &lt;li&gt;没有类型信息；&lt;/li&gt;
      &lt;li&gt;分库分表没有数据库定位信息；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chaos的设计&quot;&gt;Chaos的设计&lt;/h3&gt;

&lt;h4 id=&quot;场景&quot;&gt;场景&lt;/h4&gt;

&lt;p&gt;Chaos首先确定的就是放弃二进制而选用十进制。使用十进制最主要就是id的特殊场景。一般来说，id对于一个对象就像是身份证对于你一样，如果不去办银行卡、订酒店、订机票…，在日常生活中，身份证永远都是安静的躺在你的钱包里面；同理映射到技术人员的开发日常，当程序员要注意一个id的时候，就是当且仅当系统出问题了，需要排查。如果排错的时候，使用的还是snowflake这种二进制移位方法生成的id，同时领导、同事催促的电话频繁响起（往往这时候老板的电话特别多），然后第一句就是：怎么又出问题了？一身汗的同时你能第一时间确定这个id到底来自哪里？什么类型？用处是什么？… 这种情况下，你除了想打人已经没有别的想法了！&lt;/p&gt;

&lt;h4 id=&quot;组成&quot;&gt;组成&lt;/h4&gt;

&lt;p&gt;Chaos也和snowflake一样，选用了uint64类型，但是因为Chaos是10进制，所以对于Chaos，uint64的最大值是&lt;br /&gt;
&lt;strong&gt;1844 6744 0737 0955 1656&lt;/strong&gt;&lt;br /&gt;
那么Chaos最大值只能是&lt;br /&gt;
&lt;strong&gt;9999 9999 9999 9999 999&lt;/strong&gt;&lt;br /&gt;
直观来看，就是Chaos的id少了一位。这又是为什么呢？接着来看：&lt;br /&gt;
和snowklake一样，Chaos也是选择了使用指定位数来确定业务信息，不同的是Chaos的位数是10进制位数。我们的算法：&lt;br /&gt;
&lt;strong&gt;时间戳-随机数位-类型位-机器位-数据库标识&lt;/strong&gt; ，10位 + 4位 + 2位 + 1位 + 2位&lt;br /&gt;
这里就可以解释为什么Chaos的id会少一位了！Chaos的id最前面的几位是时间戳，而u64的最大值最前面的数值是1，如果坚持原定的位数Chaos生成id的时间戳就可能会溢出。所以Chaos的id干脆少一位，这样不管最前面的数值多大，就算是9，因为少了一位，所以肯定不会溢出。&lt;/p&gt;

&lt;h4 id=&quot;序列号&quot;&gt;序列号&lt;/h4&gt;

&lt;p&gt;在Chaos中，选择了序列号而并不是随机数来解决数的唯一性问题。之所以不选择随机数，是因为随机数在5位数的情况下，万分之一的碰撞概率对于10k qps的压力来说还是挺大的，所以随机数在Chaos的需求下并不是一个很好的方案。&lt;br /&gt;
序列号就是一个计数器，从0-9999计数，9999后直接归0.这种累加方式在Chaos中被称之为累加递增。还有一些业务确实需要每次都是从0开始的数，这种情况下的递增在Chaos中被称之为每秒递增。&lt;br /&gt;
从方案上来说，结合业务，累加递增可以让id更加均衡，id可以被更加均匀的分配到每个库和每个表中，所以它更适合用来做分库分表；而每秒递增更适合于重排序的情况。&lt;/p&gt;

&lt;h4 id=&quot;递增性分析&quot;&gt;递增性分析&lt;/h4&gt;
&lt;p&gt;上面讲到的序列号递增方法，因为序列号是id的一部分，所以序列号的递增性其实决定了整个id的递增性。也就是说，序列号决定了id的递增性。例如：&lt;br /&gt;
&lt;strong&gt;累加递增：秒内进位&lt;/strong&gt;&lt;br /&gt;
429497-9998-01-1-00&lt;br /&gt;
429498-9999-01-1-00&lt;br /&gt;
429498-0000-01-1-00&lt;br /&gt;
&lt;strong&gt;每秒递增：设计成每秒10k个，超过不会放出id&lt;/strong&gt; &lt;br /&gt;
429496-0000-01-1-00&lt;br /&gt;
429497-0000-01-1-00&lt;br /&gt;
429498-0000-01-1-00&lt;/p&gt;

&lt;p&gt;所以查看这上面的id，我们可以总结如下：
&lt;img src=&quot;id-3.png&quot; alt=&quot;id趋势&quot; /&gt;
累加递增：长时间（2s内）内保证单调递增，短时间（1s内）内不保证单调递增&lt;br /&gt;
每秒递增：它肯定是递增的，因为每秒都会从0开始，单位时间内都是单调递增&lt;/p&gt;

&lt;h4 id=&quot;id的使用&quot;&gt;id的使用&lt;/h4&gt;
&lt;p&gt;对于分库分表的使用，chaos生成的id使用示意如下：&lt;br /&gt;
&lt;img src=&quot;id-5.png&quot; alt=&quot;id router&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于错误号的使用，chaos生成的id使用示意如下：
&lt;img src=&quot;id-6.png&quot; alt=&quot;id error&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;服务器设计&quot;&gt;服务器设计&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;id-4.png&quot; alt=&quot;id server&quot; /&gt;
chaos采用了水平的分布式设计。服务器都是无状态的，也是去中心化的。这样的设计可以更好的来适应后面压力增大后对于服务器的需求。目前Chaos只支持一个集群中最多有10台服务器提供id服务。是不是感觉少了一些，其实够用了。按照chaos的设计需求，10台chaos每秒可以生成：10(台) * 100(类型数) * 10000(每秒最大数量）= 1000 0000个id。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;id，其实就是一个19位的数字。对于id来说，技术含量不在于纯技术，而在于对系统的架构控制，更是在于提升id对业务系统的最大化作用和控制。&lt;/p&gt;

</description>
        <pubDate>Wed, 31 May 2017 00:00:00 +0800</pubDate>
        <link>http://www.94geek.com/blog/2017/idcreator-chaos/</link>
        <guid isPermaLink="true">http://www.94geek.com/blog/2017/idcreator-chaos/</guid>
      </item>
    
      <item>
        <title>libev 中文手册</title>
        <description>&lt;p&gt;本文是libev英文版使用手册的中文翻译版。&lt;br /&gt;
大概在2年前，在我第一次使用libev的时候，我发现关于libev的中文手册和中文使用说明很少，所以我就试着给作者发mail，希望作者能授权给我翻译中文手册的资格，但是至今未收到回音。所以我想做几点声明，如下：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;此文的原始版权归原作者（libev的e文作者），而本文的任何权利都和e文文档的权利相同，包括开源协议；&lt;/li&gt;
  &lt;li&gt;本人不享有授权任何人分发（包括但不仅限于印刷、出版等）此文档的权利；&lt;/li&gt;
  &lt;li&gt;需要出版此文档必须经过原e文文档的同意；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;特此说明：&lt;br /&gt;
对于一个e文极烂，4级都没有分数的人来说，翻译纯粹是靠毅力在支撑，但是水平有限是
现实问题，所以在翻译的过程中难免会有错误，请大家海涵，并且希望大家能在发现问题的
时候第一时间联系我。&lt;/p&gt;

&lt;h2 id=&quot;libev&quot;&gt;libev&lt;/h2&gt;

&lt;p&gt;libev - a high performance full-featured event loop written in C.&lt;br /&gt;
libev-一个用c写成的全功能事件循环库（PS：event loop不知道怎么翻译好）。&lt;/p&gt;

&lt;h2 id=&quot;synopsis-简介&quot;&gt;SYNOPSIS 简介&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    #include &amp;lt;ev.h&amp;gt;
    EXAMPLE PROGRAM
    示例程序

    // a single header file is required
    //需要包含ev.h头文件
    #include &amp;lt;ev.h&amp;gt;

    #include &amp;lt;stdio.h&amp;gt; // for puts

    // every watcher type has its own typedef'd struct
    // with the name ev_TYPE
    //每一个观察者（watcher，以下还是用watcher吧，这种名称用中文很别扭）都有一个自己的结构体，结构体名称形如ev_TYPE

    ev_io stdin_watcher;
    ev_timer timeout_watcher;

    // all watcher callbacks have a similar signature
    // this callback is called when data is readable on stdin
    //所有的watcher回调函数也都有同样的函数签名
    //当stdin可读的时候，执行回调函数
    static void
    stdin_cb (EV_P_ ev_io *w, int revents)
    {
        puts (&quot;stdin ready&quot;);
        // for one-shot events, one must manually stop the watcher
        // with its corresponding stop function.
        // 对于只发生一次的事件来说，我们必须使用watcher的相应停止函数来手动停止这个watcher
        //译者注：它的意思是对于只需要触发一次的事件，我们必须使用不同类型相应的函数来停止这个watcher在loop中继续被监视
       //PS: 对于IO事件就是ev_io_stop,对于time事件  就是ev_time_stop
        ev_io_stop (EV_A_ w);

        // this causes all nested ev_run's to stop iterating
        //停止loop的运行，释放全部的watcher
        ev_break (EV_A_ EVBREAK_ALL);
    }

    // another callback, this time for a time-out
    //另外一个回调函数，是时间过期调用的
    static void
    timeout_cb (EV_P_ ev_timer *w, int revents)
    {
        puts (&quot;timeout&quot;);
        // this causes the innermost ev_run to stop iterating
        //停止当前loop循环
        ev_break (EV_A_ EVBREAK_ONE);
    }

    int
    main (void)
    {
        // use the default event loop unless you have special needs
        //除非你有特别的需求,一般使用默认的event loop即可
        struct ev_loop *loop = EV_DEFAULT;

        // initialise an io watcher, then start it
        // this one will watch for stdin to become readable
        //初始化一个io watcher，将事件和loop关联
        //这个watcher监视stdin是否可读
        ev_io_init (&amp;amp;stdin_watcher, stdin_cb, /*STDIN_FILENO*/ 0, EV_READ);
        ev_io_start (loop, &amp;amp;stdin_watcher);

        // initialise a timer watcher, then start it
        // simple non-repeating 5.5 second timeout
        //初始化一个超时watcher，并将事件和loop关联
        //简单的非重复5.5s超时
        ev_timer_init (&amp;amp;timeout_watcher, timeout_cb, 5.5, 0.);
        ev_timer_start (loop, &amp;amp;timeout_watcher);

        // now wait for events to arrive
        //开始监听事件
        ev_run (loop, 0);

        // break was called, so exit
        return 0;
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;about-this-document-关于这个文档&quot;&gt;ABOUT THIS DOCUMENT 关于这个文档&lt;/h2&gt;

&lt;p&gt;This document documents the libev software package.&lt;br /&gt;
这份文档记录了libev这个软件开发包。&lt;/p&gt;

&lt;p&gt;The newest version of this document is also available as an html-formatted web page you might find easier to navigate when reading it for the first time: http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod.&lt;br /&gt;
这个文档最新的版本是一个html，你可以在这里找到它：&lt;a href=&quot;http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod.&quot;&gt;最新的e文文档&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;While this document tries to be as complete as possible in documenting libev, its usage and the rationale behind its design, it is not a tutorial on event-based programming, nor will it introduce event-based programming with libev.&lt;br /&gt;
这篇文档试着尽可能详细的说明libev的使用方法及其背后的设计理念，所以这不是一个基于事件编程的教程，也不会使用libev来教导事件编程.&lt;/p&gt;

&lt;p&gt;Familiarity with event based programming techniques in general is assumed throughout this document.&lt;br /&gt;
这篇文档假定你已经熟悉基于事件的编程技术&lt;/p&gt;

&lt;h2 id=&quot;what-to-read-when-in-a-hurry&quot;&gt;WHAT TO READ WHEN IN A HURRY&lt;/h2&gt;

&lt;p&gt;This manual tries to be very detailed, but unfortunately, this also makes it very long. If you just want to know the basics of libev, I suggest reading ANATOMY OF A WATCHER, then the EXAMPLE PROGRAM above and look up the missing functions in GLOBAL FUNCTIONS and the ev_io and ev_timer sections in WATCHER TYPES.&lt;br /&gt;
这个手册试着说明的非常详细，但不幸的是，这也将让它变的很长。如果你只是想了解libev的基础知识，我建议读ANATOMY OF A WATCHER章节。示例程序在它上面，缺少的函数在GLOBAL FUNCTIONS章节中找，ev_io和ev_timer部分在WATCHER TYPES章节&lt;/p&gt;

&lt;h2 id=&quot;about-libev-关于libev&quot;&gt;ABOUT LIBEV 关于libev&lt;/h2&gt;

&lt;p&gt;Libev is an event loop: you register interest in certain events (such as a file descriptor being readable or a timeout occurring), and it will manage these event sources and provide your program with events.&lt;br /&gt;
libev是一个事件循环（event loop看上去还是舒服一些），你可以注册一些你感兴趣的事件（比如一个文件描述符可读事件或者一个超时事件），它可以管理这些事件源并且调用你的事件处理函数（其实就是callback你注册的事件处理函数).&lt;/p&gt;

&lt;p&gt;To do this, it must take more or less complete control over your process (or thread) by executing the event loop handler, and will then communicate events via a callback mechanism.&lt;br /&gt;
要达到这样的目的，必须通过一个event loop事件句柄尽可能的完全控制你的进程（或者线程），然后通过一个回调机制通知事件处理函数。&lt;/p&gt;

&lt;p&gt;You register interest in certain events by registering so-called event watchers, which are relatively small C structures you initialise with the details of the event, and then hand it over to libev by starting the watcher.&lt;br /&gt;
你通过注册所谓的事件观察者（event watcher）来注册一些你感兴趣的事件，这些watcher是一些你使用事件的详细信息来初始化的相对较小的c结构体，然后你通过开始watcher把它交给libev管理。&lt;/p&gt;

&lt;h2 id=&quot;features-特性&quot;&gt;FEATURES 特性&lt;/h2&gt;

&lt;p&gt;Libev supports select, poll, the Linux-specific epoll, the BSD-specific kqueue and the Solaris-specific event port mechanisms for file descriptor events (ev_io), the Linux inotify interface (for ev_stat), Linux eventfd/signalfd (for faster and cleaner inter-thread wakeup (ev_async)/signal handling (ev_signal)) relative timers (ev_timer), absolute timers with customised rescheduling (ev_periodic), synchronous signals (ev_signal), process status change events (ev_child), and event watchers dealing with the event loop mechanism itself (ev_idle, ev_embed, ev_prepare and ev_check watchers) as well as file watchers (ev_stat) and even limited support for fork events (ev_fork).&lt;br /&gt;
libev为文件描述符事件（ev_io）提供select，poll，linux特有的epoll，bsd特有的kqueue和solaris特有的event port机制，ev_stat使用的是linux的inotify接口（是不是别的平台就不提供？），linux eventfd/signalfd（为了更快更简洁（这里cleaner翻译成简洁应该更好）的线程间唤醒（ev_async）/信号事件（ev_signal)，相对的定时器（ev_timer），可自定义的绝对定时器（ev_periodic），同步信号（ev_signal)，进程状态的改变事件（ev_child），和一些event loop机制处理event watcher时自己带有的一些事件（ev_idle,ev_embed,ev_prepare和ev_check watcher)以及文件状态的watcher和fork一个子进程。&lt;br /&gt;
译者注：其实这段就是告诉你libev有哪一些事件，有点啰嗦，来一个简单&lt;br /&gt;
ev_io // IO可读可写&lt;br /&gt;
ev_stat // 文件属性变化&lt;br /&gt;
ev_async // 激活线程&lt;br /&gt;
ev_signal // 信号处理&lt;br /&gt;
ev_timer // 定时器&lt;br /&gt;
ev_periodic // 周期任务&lt;br /&gt;
ev_child // 子进程状态变化&lt;br /&gt;
ev_fork // 开辟进程&lt;br /&gt;
ev_cleanup // event loop退出触发事件&lt;br /&gt;
ev_idle // 每次event loop空闲触发事件&lt;br /&gt;
ev_embed // 用于将一个事件循环嵌套到另一个中，当事件循环处理事件的时候被调用&lt;br /&gt;
ev_prepare // 每次event loop之前事件&lt;br /&gt;
ev_check // 每次event loop之后事件&lt;/p&gt;

&lt;p&gt;It also is quite fast (see this benchmark comparing it to libevent for example).&lt;br /&gt;
libev也是相当快的（可以见以libevent为例的基准比较）&lt;/p&gt;

&lt;h2 id=&quot;conventions-约定&quot;&gt;CONVENTIONS 约定&lt;/h2&gt;

&lt;p&gt;Libev is very configurable. In this manual the default (and most common) configuration will be described, which supports multiple event loops. For more info about various configuration options please have a look at EMBED section in this manual. If libev was configured without support for multiple event loops, then all functions taking an initial argument of name loop (which is always of type struct ev_loop *) will not have this argument.&lt;br /&gt;
libev是很容易配置的，在这份手册中，默认（也是最常见的）的配置将会被说明，libev也支持多个event loop。需要更多关于各种配置文件的选项，请查看手册的EMBED部分。如果libev被配置成不支持多个event loop，那么所有函数如果有一个名字为loop的参数，那么这个参数将不存在。（译者注：其实就是进程中只有一个event loop的话，event loop将会是一个常量，不需要在函数间传来传去，故这个参数将不存在）。&lt;/p&gt;

&lt;h2 id=&quot;time-representation&quot;&gt;TIME REPRESENTATION&lt;/h2&gt;

&lt;p&gt;Libev represents time as a single floating point number, representing the (fractional) number of seconds since the (POSIX) epoch (in practice somewhere near the beginning of 1970, details are complicated, don’t ask). This type is called ev_tstamp, which is what you should use too. It usually aliases to the double type in C. When you need to do any calculations on it, you should treat it as some floating point value.&lt;br /&gt;
libev使用一个有符号（这里的single是译做单精度呢？还是译做单个呢？还是译做有符号？）的浮点数表示时间，表示至unix时间点（其实就是posix的标准时间点，在实践中差不多使用1970年开始的，详细的算法很复杂，不要多问）以来经过的秒数。这种时间类型被叫做ev_tstamp，也是你将要使用的类型。这种类型在c中经常被叫做double，当你需要使用它做任何计算的时候，你应该把他作为浮点数对待。&lt;/p&gt;

&lt;p&gt;Unlike the name component stamp might indicate, it is also used for time differences (e.g. delays) throughout libev.&lt;br /&gt;
不像’stamp’这个名称所指出的那样，ev_tstamp也可以用来表示时间差（这句来自左手）&lt;br /&gt;
译者注：这句话不知道怎么翻译，可能是他要表示libev使用ev_tstamp表示libev的时间间隔。&lt;/p&gt;

&lt;h2 id=&quot;error-handling-错误处理&quot;&gt;ERROR HANDLING 错误处理&lt;/h2&gt;

&lt;p&gt;Libev knows three classes of errors: operating system errors, usage errors and internal errors (bugs).&lt;br /&gt;
libev知道3种错误：系统错误，用法错误和内部错误。&lt;/p&gt;

&lt;p&gt;When libev catches an operating system error it cannot handle (for example a system call indicating a condition libev cannot fix), it calls the callback set via ev_set_syserr_cb, which is supposed to fix the problem or abort. The default is to print a diagnostic message and to call abort ().&lt;br /&gt;
当libev捕获一个它不能处理的系统错误时（例如一个系统调用说明一个条件，libev不能处理它。这句怪怪的，其实就是一个libev不能处理的系统调用），libev就会调用一个你通过sv_set_syserr_sb设置的回调函数，这个回调函数提供处理这个错误的方法或者终止libev，libev默认的回调函数是打印错误消息，并且调用abort函数。&lt;/p&gt;

&lt;p&gt;When libev detects a usage error such as a negative timer interval, then it will print a diagnostic message and abort (via the assert mechanism, so NDEBUG will disable this checking): these are programming errors in the libev caller and need to be fixed there.&lt;br /&gt;
当libev检测到一个错误的使用方法时，比如一个负的时间间隔（从现实生活角度出发，貌似负的时间间隔应该可以啊？），libev会打印一个诊断消息并且终止程序（通过assert机制，NODEBUG将会关闭这个检查）；这些都是libev的调用者的编程错误（其实就是来自于程序员的），这些错误必须要防止它。&lt;/p&gt;

&lt;p&gt;Libev also has a few internal error-checking assertions, and also has extensive consistency checking code. These do not trigger under normal circumstances, as they indicate either a bug in libev or worse.&lt;br /&gt;
libev也有一些内部错误检查的机制，并且拥有广泛的一致性检查代码，他们不会在正常情况下触发，当他们触发时就表明libev发生了一个bug或者是更糟的情况。&lt;/p&gt;

&lt;h2 id=&quot;global-functions-全局函数&quot;&gt;GLOBAL FUNCTIONS 全局函数&lt;/h2&gt;

&lt;p&gt;These functions can be called anytime, even before initialising the library in any way.&lt;br /&gt;
这些函数可以在任何时候被调用，甚至在libev这个库初始化之前（应该是在libev的事件驱动初始化之前吧）。&lt;/p&gt;

&lt;h3 id=&quot;ev_tstamp-ev_time-&quot;&gt;ev_tstamp ev_time ()&lt;/h3&gt;
&lt;p&gt;Returns the current time as libev would use it. Please note that the ev_now function is usually faster and also often returns the timestamp you actually want to know. Also interesting is the combination of ev_now_update and ev_now.&lt;br /&gt;
当libev调用它的时候返回当前的时间。请注意：ev_now函数经常会更快，并且它也经常返回你真正需要的时间戳。更有趣的是ev_now_update和ev_now的组合。（译者注：和nginx一样，libev有一个自己的时间管理机制，你在调用ev_now之前先调用一下ev_now_update这样会得到更加精确的时间）。&lt;/p&gt;

&lt;h3 id=&quot;ev_sleep-ev_tstamp-interval&quot;&gt;ev_sleep (ev_tstamp interval)&lt;/h3&gt;
&lt;p&gt;Sleep for the given interval: The current thread will be blocked until either it is interrupted or the given time interval has passed (approximately - it might return a bit earlier even if not interrupted). Returns immediately if interval &amp;lt;= 0.&lt;br /&gt;
休眠给定的时间。当前线程将会被阻塞直到它被中断或者给定的时间到。（大概的，如果线程没有被中断，它可能会比规定时间早醒来一些）。如果给定时间小于0，立即返回。&lt;/p&gt;

&lt;p&gt;Basically this is a sub-second-resolution sleep ().&lt;br /&gt;
基本上，这是一个低精度的休眠。&lt;/p&gt;

&lt;p&gt;The range of the interval is limited - libev only guarantees to work with sleep times of up to one day (interval &amp;lt;= 86400).&lt;br /&gt;
规定的时间是有限制的，libev只保证最多一天的线程休眠时间。&lt;/p&gt;

&lt;h3 id=&quot;int-ev_version_major-&quot;&gt;int ev_version_major ().&lt;/h3&gt;
&lt;h3 id=&quot;int-ev_version_minor-&quot;&gt;int ev_version_minor ()&lt;/h3&gt;
&lt;p&gt;You can find out the major and minor ABI version numbers of the library you linked against by calling the functions ev_version_major and ev_version_minor. If you want, you can compare against the global symbols EV_VERSION_MAJOR and EV_VERSION_MINOR, which specify the version of the library your program was compiled against.&lt;br /&gt;
通过调用ev_version_major和ev_version_minor函数，你可以知道你所连接的libev库的主要和次要版本号。如果你想要，你可以和EV_VERSION_MAJOR和EV_VERSION_MINOR比较版本号。这两个指定你编译的库的版本号。&lt;/p&gt;

&lt;p&gt;These version numbers refer to the ABI version of the library, not the release version.&lt;br /&gt;
这些版本号是指库的ABI版本，不是发行版的版本。&lt;/p&gt;

&lt;p&gt;Usually, it’s a good idea to terminate if the major versions mismatch, as this indicates an incompatible change. Minor versions are usually compatible to older versions, so a larger minor version alone is usually not a problem.&lt;br /&gt;
通常，如果主版本号不同，终止程序是一个好的办法。因为这表明有不兼容的代码变更。子版本号经常会兼容老版本，所以一些更大的子版本号通常都不是一个问题。&lt;/p&gt;

&lt;p&gt;Example: Make sure we haven’t accidentally been linked against the wrong version (note, however, that this will not detect other ABI mismatches, such as LFS or reentrancy).&lt;br /&gt;
例如：你要确保我们没有意外的连接错误的版本号（注意，不管怎么样，这些不能检测到其他的ABI不匹配，比如LFS和重入性等等）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    assert ((&quot;libev version mismatch&quot;,
    ev_version_major () == EV_VERSION_MAJOR
    &amp;amp;&amp;amp; ev_version_minor () &amp;gt;= EV_VERSION_MINOR));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;unsigned-int-ev_supported_backends-&quot;&gt;unsigned int ev_supported_backends ()&lt;/h3&gt;
&lt;p&gt;Return the set of all backends (i.e. their corresponding EV_BACKEND_* value) compiled into this binary of libev (independent of their availability on the system you are running on). See ev_default_loop for a description of the set values.&lt;br /&gt;
返回编译到libev中的loop支持的所有的后台处理器集合（它们就是EV_BACKEND_ *的值）。具体请查看ev_DEFAULT_loop设置值说明。&lt;/p&gt;

&lt;p&gt;Example: make sure we have the epoll method, because yeah this is cool and a must have and can we have a torrent of it please!!!&lt;br /&gt;
例如：请确保我们有epoll方法，因为epoll非常酷并且必须有也可以让我们有epoll的并发能力。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;assert ((&quot;sorry, no epoll, no sex&quot;,
ev_supported_backends () &amp;amp; EVBACKEND_EPOLL));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;unsigned-int-ev_recommended_backends-&quot;&gt;unsigned int ev_recommended_backends ()&lt;/h3&gt;
&lt;p&gt;Return the set of all backends compiled into this binary of libev and also recommended for this platform, meaning it will work for most file descriptor types. This set is often smaller than the one returned by ev_supported_backends, as for example kqueue is broken on most BSDs and will not be auto-detected unless you explicitly request it (assuming you know what you are doing). This is the set of backends that libev will probe for if you specify no backends explicitly.&lt;br /&gt;
返回所有编译进当前libev中并且推荐给当前操作系统平台为大多数文件描述符工作的后台集合。这个集合经常小于ev_supported_backends的返回值。例如：kqueue是被大多数BSDs排斥的，并且不会被自动的检测到除非你现实的说明需要它（假设你知道你自己在做什么）（译者注：其实很奇怪，kqueue不是就是BSDs系支持的嘛？为什么不会被自动的探测到？而是要自己显示的手动设置？）。这个后端集合就是libev将要探测的并且不是你显示的指定的。&lt;/p&gt;

&lt;h3 id=&quot;unsigned-int-ev_embeddable_backends-&quot;&gt;unsigned int ev_embeddable_backends ()&lt;/h3&gt;
&lt;p&gt;Returns the set of backends that are embeddable in other event loops. This value is platform-specific but can include backends not available on the current system. To find which embeddable backends might be supported on the current system, you would need to look at ev_embeddable_backends () &amp;amp; ev_supported_backends (), likewise for recommended ones.&lt;br /&gt;
返回嵌入在其他event loop中的后台集合。这个值是特定于平台的，但是可以包括那些当前平台没有的后台。若要查找那些嵌入的后台可能会被当前系统提供，你需要你看ev_embeddable_backends () &amp;amp; ev_supported_backends ()。同样，这也是推荐使用的。&lt;/p&gt;

&lt;p&gt;See the description of ev_embed watchers for more info.&lt;br /&gt;
请参阅ev_embed watcher获取更多的信息。&lt;/p&gt;

&lt;h3 id=&quot;ev_set_allocator-size-throw-&quot;&gt;ev_set_allocator (size) throw ()&lt;/h3&gt;
&lt;p&gt;Sets the allocation function to use (the prototype is similar - the semantics are identical to the realloc C89/SuS/POSIX function). It is used to allocate and free memory (no surprises here). If it returns zero when memory needs to be allocated (size != 0), the library might abort or take some potentially destructive action.&lt;br /&gt;
设置要使用的内存分配函数（原型和语义都是和C89/Sus/POSIX的realloc函数完全相同）。他被用来申请和释放内存（这里没有特殊）。如果当函数需要分配（size ！＝0）的内存时返回0，libev将会被终止或者就会有一些潜在的破坏错误会发生。&lt;/p&gt;

&lt;p&gt;Since some systems (at least OpenBSD and Darwin) fail to implement correct realloc semantics, libev will use a wrapper around the system realloc and free functions by default.&lt;br /&gt;
由于某些系统（至少OpenBSD和Darwin）没有实现语义完全正确（译者注：应该是和POSIX标准相同）的realloc函数，libev会默认使用系统realloc和free函数的包装。&lt;/p&gt;

&lt;p&gt;You could override this function in high-availability programs to, say, free some memory if it cannot allocate memory, to use a special allocator, or even to sleep a while and retry until some memory is available.&lt;br /&gt;
你可以在高性能程序中重写这个函数。如果它不能申请内存就先释放一下，使用一个特殊的分配器或者休眠一会儿然后重试，直到申请内存成功。&lt;/p&gt;

&lt;p&gt;Example: Replace the libev allocator with one that waits a bit and then retries (example requires a standards-compliant realloc).&lt;br /&gt;
例子：使用短暂休眠和重试分配（例如需要一个符合规范的分配器）的替换libev的分配器。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void *
persistent_realloc (void *ptr, size_t size) {
    for (;;) {
        void *newptr = realloc (ptr, size);
        if (newptr)
            return newptr;
        sleep (60);
    }
}
...
ev_set_allocator (persistent_realloc);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ev_set_syserr_cb-void-cbconst-char-msg-throw-&quot;&gt;ev_set_syserr_cb (void (*cb)(const char *msg) throw ())&lt;/h3&gt;
&lt;p&gt;Set the callback function to call on a retryable system call error (such as failed select, poll, epoll_wait). The message is a printable string indicating the system call or subsystem causing the problem. If this callback is set, then libev will expect it to remedy the situation, no matter what, when it returns. That is, libev will generally retry the requested operation, or, if the condition doesn’t go away, do bad stuff (such as abort).&lt;br /&gt;
设置一个系统调用被调用出错时可以调用的打印回调函数（比如错误的select，poll，epoll_wait）。
消息是一个可打印的字符串，其说明了系统调用或者是子系统调用所发生的问题。如果设置了这个回调，libev不管在什么情况下，当它返回的时候都会期望这个函数可以用来补救错误。通常，libev会重试请求操作，但是如果条件不再可以执行，程序就会出错（比如终止程序）。&lt;/p&gt;

&lt;p&gt;Example: This is basically the same thing that libev does internally, too.&lt;br /&gt;
例如：这也是libev内部基本的处理方案。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void
fatal_error (const char *msg) {
    perror (msg);
    abort ();
}

...
ev_set_syserr_cb (fatal_error);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ev_feed_signal-int-signum&quot;&gt;ev_feed_signal (int signum)&lt;/h3&gt;
&lt;p&gt;This function can be used to “simulate” a signal receive. It is completely safe to call this function at any time, from any context, including signal handlers or random threads.&lt;br /&gt;
可以使用这个函数来模拟接收信号。任何时候，任何程序上下文（context），包括信号处理事件和随便哪一个线程中调用这个函数都是完完全全安全的。&lt;/p&gt;

&lt;p&gt;Its main use is to customise signal handling in your process, especially in the presence of threads. For example, you could block signals by default in all threads (and specifying EVFLAG_NOSIGMASK when creating any loops), and in one thread, use sigwait or any other mechanism to wait for signals, then “deliver” them to libev by calling ev_feed_signal.&lt;br /&gt;
它主要用来在进程中处理客户自定义的信号处理程序，尤其是涉及到多线程的信号处理。例如：默认的，你可以在所有线程中（和当你创建loop时指定EVFLAG_NOSIGMASK的信号）阻塞信号，在一个线程中，使用sigwait或者另外别的机制来等待信号。然后使用ev_feed_signal通知到libev。&lt;/p&gt;

&lt;h2 id=&quot;functions-controlling-event-loops--控制event-loops的函数&quot;&gt;FUNCTIONS CONTROLLING EVENT LOOPS  控制event loops的函数&lt;/h2&gt;

&lt;p&gt;An event loop is described by a struct ev_loop * (the struct is not optional in this case unless libev 3 compatibility is disabled, as libev 3 had an ev_loop function colliding with the struct name).&lt;br /&gt;
通过一个ev_loop结构体的指针来描述一个event loop。（通常情况下，这个结构体不是可选的，除非把libev 3的兼容性禁止掉，因为libev 3有一个ev_loop的函数和这个结构体重名。）&lt;/p&gt;

&lt;p&gt;The library knows two types of such loops, the default loop, which supports child process events, and dynamically created event loops which do not.&lt;br /&gt;
libev支持两种类型的loop，默认的loop，支持子进程事件；动态创建的则不支持子进程事件。&lt;/p&gt;

&lt;h3 id=&quot;struct-ev_loop-ev_default_loop-unsigned-int-flags&quot;&gt;struct ev_loop *ev_default_loop (unsigned int flags)&lt;/h3&gt;
&lt;p&gt;This returns the “default” event loop object, which is what you should normally use when you just need “the event loop”. Event loop objects and the flags parameter are described in more detail in the entry for ev_loop_new.&lt;br /&gt;
该函数返回默认的event loop对象，这个默认的设置通常就是你所需要使用的。event loop对象的状态参数和详细描述请参阅ev_loop_new函数。&lt;/p&gt;

&lt;p&gt;If the default loop is already initialised then this function simply returns it (and ignores the flags. If that is troubling you, check ev_backend () afterwards). Otherwise it will create it with the given flags, which should almost always be 0, unless the caller is also the one calling ev_run or otherwise qualifies as “the main program”.&lt;br /&gt;
当函数无参数调用返回的时候，默认的loop就已经初始化了（忽略一切设置，只是简单的调用此函数，如果你不放心，后续可以调用ev_backend（）函数检查）。否则此函数将按照给定的flag创建loop，其实这些flag通常都是设置为0，除非调用者也调用ev_run，也就是说是主程序调用。（译者注：主程序有什么差别吗？）&lt;/p&gt;

&lt;p&gt;If you don’t know what event loop to use, use the one returned from this function (or via the EV_DEFAULT macro).&lt;br /&gt;
如果你不知道到底用什么来初始化你的event loop，那么就使用这个函数默认返回的（或者通过EV_DEFAULT宏）。&lt;/p&gt;

&lt;p&gt;Note that this function is not thread-safe, so if you want to use it from multiple threads, you have to employ some kind of mutex (note also that this case is unlikely, as loops cannot be shared easily between threads anyway).&lt;br /&gt;
注意：此函数不是线程安全的，所以如果你想在多线程环境中使用，你需要使用某种mutex的锁（还要注意：在线程间简单的共享这个loop是不可能的）。&lt;/p&gt;

&lt;p&gt;The default loop is the only loop that can handle ev_child watchers, and to do this, it always registers a handler for SIGCHLD. If this is a problem for your application you can either create a dynamic loop with ev_loop_new which doesn’t do that, or you can simply overwrite the SIGCHLD signal handler after calling ev_default_init.&lt;br /&gt;
默认的loop是全局唯一的，此loop也可以处理ev_child的watchers（其实就是处理子进程的事件），要实现这个功能，通常要先注册一个SIGCHLD信号事件。如果对于你的应用程序全局loop有问题的话，你可以在调用ev_default_init函数后重写一下SIGCHLD信号处理函数。&lt;/p&gt;

&lt;p&gt;Example: This is the most typical usage.&lt;br /&gt;
示例：这是最典型的用法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (!ev_default_loop (0))
fatal (&quot;could not initialise libev, bad $LIBEV_FLAGS in environment?&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Example: Restrict libev to the select and poll backends, and do not allow environment settings to be taken into account:&lt;br /&gt;
示例：限制loop使用select和poll作为后端，并且不允许更改这个账号的环境设置。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ev_default_loop (EVBACKEND_POLL | EVBACKEND_SELECT | EVFLAG_NOENV);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;struct-ev_loop-ev_loop_new-unsigned-int-flags&quot;&gt;struct ev_loop *ev_loop_new (unsigned int flags)&lt;/h3&gt;
&lt;p&gt;This will create and initialise a new event loop object. If the loop could not be initialised, returns false.&lt;br /&gt;
此函数将创建并且初始化一个新的event loop对象。如果loop不能被初始化，函数返回false。&lt;/p&gt;

&lt;p&gt;This function is thread-safe, and one common way to use libev with threads is indeed to create one loop per thread, and using the default loop in the “main” or “initial” thread.&lt;br /&gt;
此函数是线程安全的，是一个在多线程环境中通常使用libev的方式：每一个线程创建一个loop，然后在主线程或者初始化线程中使用默认的loop。&lt;/p&gt;

&lt;p&gt;The flags argument can be used to specify special behaviour or specific backends to use, and is usually specified as 0 (or EVFLAG_AUTO).&lt;br /&gt;
flag参数可以被用来指定特殊的行为或者指定使用的后台，通常，flag设置成0（或者EVFLAG_AUTO)。&lt;/p&gt;

&lt;p&gt;The following flags are supported:&lt;br /&gt;
这些flags提供的选项：&lt;/p&gt;

&lt;h4 id=&quot;evflag_auto&quot;&gt;EVFLAG_AUTO&lt;/h4&gt;
&lt;p&gt;The default flags value. Use this if you have no clue (it’s the right thing, believe me).&lt;br /&gt;
默认的值，如果你没有什么特殊的要求，就用这个选项（相信我，这是对的）。&lt;/p&gt;

&lt;h4 id=&quot;evflag_noenv&quot;&gt;EVFLAG_NOENV&lt;/h4&gt;
&lt;p&gt;If this flag bit is or’ed into the flag value (or the program runs setuid or setgid) then libev will not look at the environment variable LIBEV_FLAGS. Otherwise (the default), this environment variable will override the flags completely if it is found in the environment. This is useful to try out specific backends to test their performance, to work around bugs, or to make libev threadsafe (accessing environment variables cannot be done in a threadsafe way, but usually it works if no other thread modifies them).&lt;br /&gt;
如果flag位被设置（或者程序执行setuid或者setgid），libev将不会去查看LIBEV_FLAGS这个环境变量。否则（默认的），如果这个环境变量被找到，它将会完整的覆盖这个flag位。对于设置指定的后台来测试性能、解决bug、或者让libev线程安全（访问环境变量是线程不安全的，但是如果别的线程不更改他们，他们通常一切ok），这很有用。&lt;/p&gt;

&lt;h4 id=&quot;evflag_forkcheck&quot;&gt;EVFLAG_FORKCHECK&lt;/h4&gt;
&lt;p&gt;Instead of calling ev_loop_fork manually after a fork, you can also make libev check for a fork in each iteration by enabling this flag.&lt;br /&gt;
通常你需要在fork函数后显式的调用ev_loop_fork函数，但是你也可以通过设置这个flag来使libev在每次迭代的时候检查fork（）。&lt;/p&gt;

&lt;p&gt;This works by calling getpid () on every iteration of the loop, and thus this might slow down your event loop if you do a lot of loop iterations and little real work, but is usually not noticeable (on my GNU/Linux system for example, getpid is actually a simple 5-insn sequence without a system call and thus very fast, but my GNU/Linux system also has pthread_atfork which is even faster).&lt;br /&gt;
这是通过在loop的每次迭代中调用getpid（）来实现的。因此，如果你大部分在做loop的迭代，小部分在做业务操作，它将会减慢一点event loop的速度。但是这通常是不需要担心的（以在我的GNU/LINUX系统上为例，getpid通常在没有系统调用的情况下被连续执行5次，这是很快的，我的GNU/LINUX系统也有pthread_atfork，它更快）。&lt;/p&gt;

&lt;p&gt;The big advantage of this flag is that you can forget about fork (and forget about forgetting to tell libev about forking) when you use this flag.&lt;br /&gt;
当你使用这个flag位的时候，最大的好处是你可以忘记fork（忘掉忘记了告诉libev forking）。&lt;/p&gt;

&lt;p&gt;This flag setting cannot be overridden or specified in the LIBEV_FLAGS environment variable.&lt;br /&gt;
设置这个flag不能覆盖或者指定LIBEV_FLAGS环境变量。&lt;/p&gt;

&lt;h4 id=&quot;evflag_noinotify&quot;&gt;EVFLAG_NOINOTIFY&lt;/h4&gt;
&lt;p&gt;When this flag is specified, then libev will not attempt to use the inotify API for its ev_stat watchers. Apart from debugging and testing, this flag can be useful to conserve inotify file descriptors, as otherwise each loop using ev_stat watchers consumes one inotify handle.&lt;br /&gt;
如果指定这个flag。libev将不会尝试使用inotify api来作为其ev_stat的watchers。除了调试和测试，这个flag将会用来节约inotify的文件描述符，否则每个loop使用ev_stat watchers消耗一个inotify句柄。（译者注：这里应该是每个loop一个描述符而不是每次迭代一个吧？）&lt;/p&gt;

&lt;h4 id=&quot;evflag_signalfd&quot;&gt;EVFLAG_SIGNALFD&lt;/h4&gt;
&lt;p&gt;When this flag is specified, then libev will attempt to use the signalfd API for its ev_signal (and ev_child) watchers. This API delivers signals synchronously, which makes it both faster and might make it possible to get the queued signal data. It can also simplify signal handling with threads, as long as you properly block signals in your threads that are not interested in handling them.&lt;br /&gt;
当此flag被设置时，libev尝试为它的ev_signal（和ev_child）使用signalfd API。这个API提供信号同步，并且让它更快，也可能可以得到排列的信号数据（译者注：是得到信号通知嘛？）它也可以简化线程的信号处理，只要你正确的在你的线程间阻塞你的信号就不会去处理他们。（译者注：这句话怎么怪怪的，有更好的翻译嘛？）&lt;/p&gt;

&lt;p&gt;Signalfd will not be used by default as this changes your signal mask, and there are a lot of shoddy libraries and programs (glib’s threadpool for example) that can’t properly initialise their signal masks.&lt;br /&gt;
默认情况下，signalfd将不会被使用，因为这会更改你的信号掩码。有很多的劣质库和程序（比如glib的线程池）不能正确的初始化他们的信号掩码。&lt;/p&gt;

&lt;h4 id=&quot;evflag_nosigmask&quot;&gt;EVFLAG_NOSIGMASK&lt;/h4&gt;
&lt;p&gt;When this flag is specified, then libev will avoid to modify the signal mask. Specifically, this means you have to make sure signals are unblocked when you want to receive them.&lt;br /&gt;
当设置这个flag时，libev将不会修改信号掩码。具体来说，这意味着你必须在想要接收它们是，确保信号没有被阻塞。&lt;/p&gt;

&lt;p&gt;This behaviour is useful when you want to do your own signal handling, or want to handle signals only in specific threads and want to avoid libev unblocking the signals.&lt;br /&gt;
当你想要自己处理信号，或者想要在特定的线程中处理信号和想要避免让libev疏导信号时，这种行为很有用。&lt;/p&gt;

&lt;p&gt;It’s also required by POSIX in a threaded program, as libev calls sigprocmask, whose behaviour is officially unspecified.&lt;br /&gt;
在一个POSIX多线程程序中这是必须的，当libev调用sigprocmask，其行为是未定义的。&lt;/p&gt;

&lt;p&gt;This flag’s behaviour will become the default in future versions of libev.&lt;br /&gt;
这个flag的行为将来在libev中将会变成默认的。&lt;/p&gt;

&lt;h4 id=&quot;evbackend_select-value-1-portable-select-backend--轻量级后台&quot;&gt;EVBACKEND_SELECT (value 1, portable select backend)  轻量级后台&lt;/h4&gt;
&lt;p&gt;This is your standard select(2) backend. Not completely standard, as libev tries to roll its own fd_set with no limits on the number of fds, but if that fails, expect a fairly low limit on the number of fds when using this backend. It doesn’t scale too well (O(highest_fd)), but its usually the fastest backend for a low number of (low-numbered :) fds.&lt;br /&gt;
这是标准的select（2）后台，不完全标准的，因为libev试着推行自己的不带fds数量限制的fd_set。但是如果失败，当使用这个后台的时候，预计fds会有很小数量的限制。它通常不能很好的扩展，但是如果fds非常小，它通常是最快的后台。&lt;/p&gt;

&lt;p&gt;To get good performance out of this backend you need a high amount of parallelism (most of the file descriptors should be busy). If you are writing a server, you should accept () in a loop to accept as many connections as possible during one iteration. You might also want to have a look at ev_set_io_collect_interval () to increase the amount of readiness notifications you get per iteration.&lt;/p&gt;

&lt;p&gt;This backend maps EV_READ to the readfds set and EV_WRITE to the writefds set (and to work around Microsoft Windows bugs, also onto the exceptfds set on that platform).&lt;br /&gt;
为了得到这个后台更好的性能，你需要大量的并行运行（大多数的文件描述符是忙碌的）。如果你正在写一个服务器，你必须在loop中调用accept来在一次迭代中尽可能多的接收更多的连接。你可能还需要看看ev_set_io_collect_interval（）来增加每次迭代中准备通知的数量。
这个后台映射EV_READ到readfds集合，映射EV_WRITE到writefds集合（并解决MS win平台上的bugs，也可以在别的平台上映射)&lt;/p&gt;

&lt;h4 id=&quot;evbackend_poll-value-2-poll-backend-available-everywhere-except-on-windows--value-2除win以外的所有平台&quot;&gt;EVBACKEND_POLL (value 2, poll backend, available everywhere except on windows)  （value 2，除win以外的所有平台）&lt;/h4&gt;
&lt;p&gt;And this is your standard poll(2) backend. It’s more complicated than select, but handles sparse fds better and has no artificial limit on the number of fds you can use (except it will slow down considerably with a lot of inactive fds). It scales similarly to select, i.e. O(total_fds). See the entry for EVBACKEND_SELECT, above, for performance tips.&lt;br /&gt;
这是标准的poll后台，它比select更复杂，但是处理量小的fds更好选择，并且没有人为的可用fds数量限制（除了他会减慢很多不活动的fdfs）。它的复杂度和select是一样的，即O（total_fds）。请参见上面EVBACKEND_SELECT条目，及其性能小技巧。&lt;/p&gt;

&lt;p&gt;This backend maps EV_READ to POLLIN | POLLERR | POLLHUP, and EV_WRITE to POLLOUT | POLLERR | POLLHUP.&lt;br /&gt;
这个后台映射EV_READ到POLLIN | POLLERR | POLLHUP，映射EV_WRITE到POLLOUT | POLLERR | POLLHUP。&lt;/p&gt;

&lt;h4 id=&quot;evbackend_epoll-value-4-linux&quot;&gt;EVBACKEND_EPOLL (value 4, Linux)&lt;/h4&gt;
&lt;p&gt;Use the linux-specific epoll(7) interface (for both pre- and post-2.6.9 kernels).&lt;br /&gt;
使用linux特有的epoll（7）接口（支持2.6.9内核以上）。&lt;/p&gt;

&lt;p&gt;For few fds, this backend is a bit little slower than poll and select, but it scales phenomenally better. While poll and select usually scale like O(total_fds) where total_fds is the total number of fds (or the highest fd), epoll scales either O(1) or O(active_fds).&lt;br /&gt;
对于一些文件描述符，这个后台相比poll和select是相对会慢一些，但是他的扩展性惊人的好。poll和select的复杂度经常是O（total_fds），total_fds是所有文件描述符的总数（或者是值最大的那个文件描述符），epoll复杂度是O（1）或者O（active_fds：活动的文件描述符）。&lt;/p&gt;

&lt;p&gt;The epoll mechanism deserves honorable mention as the most misdesigned of the more advanced event mechanisms: mere annoyances include silently dropping file descriptors, requiring a system call per change per file descriptor (and unnecessary guessing of parameters), problems with dup, returning before the timeout value, resulting in additional iterations (and only giving 5ms accuracy while select on the same platform gives 0.1ms) and so on. The biggest issue is fork races, however - if a program forks then both parent and child process have to recreate the epoll set, which can take considerable time (one syscall per file descriptor) and is of course hard to detect.&lt;br /&gt;
作为在众多高级event机制中设计最失误的事件机制，epoll机制是值得拥有该”荣誉“的。失误仅仅包括：文件描述符默默的退出；每次更改一个文件描述符都需要一个系统调用（参数不必要的猜测），dup问题；在超时前返回值，从而导致更多的迭代（只有5ms的精确性，如果使用select，精度可以达到0.1ms），等等。最大的问题是交叉fork，如果程序fork，父子进程都需要重新设置epoll，这需要花费很多时间（每个文件描述符都需要一次系统调用），这当然是很难应对的。&lt;/p&gt;

&lt;p&gt;Epoll is also notoriously buggy - embedding epoll fds should work, but of course doesn’t, and epoll just loves to report events for totally different file descriptors (even already closed ones, so one cannot even remove them from the set) than registered in the set (especially on SMP systems). Libev tries to counter these spurious notifications by employing an additional generation counter and comparing that against the events to filter out spurious ones, recreating the set when required. Epoll also erroneously rounds down timeouts, but gives you no way to know when and by how much, so sometimes you have to busy-wait because epoll returns immediately despite a nonzero timeout. And last not least, it also refuses to work with some file descriptors which work perfectly fine with select (files, many character devices…).&lt;br /&gt;
epoll当然也是多bug的。设置到epoll的文件描述符应该是可以正常运行的，但是，当然也有不正常的时候，epoll只是喜欢报告注册在epoll（特别是指SMP系统上）中的那些完全不同的文件描述符事件（甚至包括已经关闭的文件描述符，所以，我们不能从设置集中移除他们）。epoll通过增加一个代计数器并且比较他们来过滤掉那些来自epoll报告的虚通知，重新建立那些报告的文件描述符集合，从而试图解决虚通知的问题。epoll还错误的向下舍入超时时间，但是不给你任何方法知道何时发生向下舍入和有多少文件描述符受影响，所以有的时候你不得不忙碌的等待着，因为epoll会立即返回超时的非零文件描述符。而最后的一点，它有的时候不支持那些能正常使用select机制的文件描述符（文件，很多的字符设备驱动）。&lt;/p&gt;

&lt;p&gt;Epoll is truly the train wreck among event poll mechanisms, a frankenpoll, cobbled together in a hurry, no thought to design or interaction with others. Oh, the pain, will it ever stop…&lt;br /&gt;
epoll在事件机制中是真正的投票机制，一个基因改造的poll。epoll在匆忙中拼凑起来，没有设计和考虑和别的配合。oh，无语了。（这段怎么纯粹是作者的吐槽？看样子被折磨的不清）&lt;/p&gt;

&lt;p&gt;While stopping, setting and starting an I/O watcher in the same iteration will result in some caching, there is still a system call per such incident (because the same file descriptor could point to a different file description now), so its best to avoid that. Also, dup ()’ed file descriptors might not work very well if you register events for both file descriptors.&lt;br /&gt;
当在同一个迭代中停止、设置和开始一个IO watcher时会导致一些缓存。这仍旧是每个这样的事件一个系统调用（因为现在相同的文件描述符可以指向不同的文件描述了），所以我们最好要避免这些。如果你注册两个相同的文件描述符事件，dup（）的文件描述符事件可能会不能正常运行。&lt;/p&gt;

&lt;p&gt;Best performance from this backend is achieved by not unregistering all watchers for a file descriptor until it has been closed, if possible, i.e. keep at least one watcher active per fd at all times. Stopping and starting a watcher (without re-setting it) also usually doesn’t cause extra overhead. A fork can both result in spurious notifications as well as in libev having to destroy and recreate the epoll object, which can take considerable time and thus should be avoided.&lt;br /&gt;
这个后台的最佳性能是通过不注销所有文件描述符的watchers直到他们被关闭来实现的。如果可能的话，尽可能的保证任何时候每个fd至少一个watcher。停止和启动watcher（必须要重新设置它）一般也不会造成额外的开销。在libev中，fork既可以导致虚通知，又导致libev不得不释放和重新创建epoll对象，这是非常耗时的，所以尽量避免。&lt;/p&gt;

&lt;p&gt;All this means that, in practice, EVBACKEND_SELECT can be as fast or faster than epoll for maybe up to a hundred file descriptors, depending on the usage. So sad.&lt;br /&gt;
所有的这些都表明，在实践中，EVBACKEND_SELECT是可以快的，或者在100个文件描述符之内相比epoll更快，具体取决于实际情况，不要对select太悲观。&lt;/p&gt;

&lt;p&gt;While nominally embeddable in other event loops, this feature is broken in all kernel versions tested so far.&lt;br /&gt;
当显式的设置到另外一个event loop时，这些功能到目前为止是在任何内核版本中都是被禁止的。&lt;/p&gt;

&lt;p&gt;This backend maps EV_READ and EV_WRITE in the same way as EVBACKEND_POLL.&lt;br /&gt;
后台把EV_READ和EV_WRITE全部映射到EVBACKEND_POLL。&lt;/p&gt;

&lt;h4 id=&quot;evbackend_kqueue-value-8-most-bsd-clones&quot;&gt;EVBACKEND_KQUEUE (value 8, most BSD clones)&lt;/h4&gt;
&lt;p&gt;Kqueue deserves special mention, as at the time of this writing, it was broken on all BSDs except NetBSD (usually it doesn’t work reliably with anything but sockets and pipes, except on Darwin, where of course it’s completely useless). Unlike epoll, however, whose brokenness is by design, these kqueue bugs can (and eventually will) be fixed without API changes to existing programs. For this reason it’s not being “auto-detected” unless you explicitly specify it in the flags (i.e. using EVBACKEND_KQUEUE) or libev was compiled on a known-to-be-good (-enough) system like NetBSD.&lt;br /&gt;
写这篇文章的时候，kqueue是特别值得一提的，kqueue在除了NetBSD的所有BSD系统上都会出现问题。（通常kqueue不能可靠的运行，但是sockets和pipes除外。除了在Darwin上，kqueue是完全没有用处的。译者注：这tmd到底要表达意思？）。不像epoll，kqueue的问题是因为设计，不管怎么说，这些kqueue的bugs是可以（或者最终可以）通过不改变现有程序的API解决掉的。因为这些原因，kqueue不是”自动检测“的，除非你特意指定这个flags（例如使用EVBACKEND_KQUEUE)或者libev在一个像NetBSD这样已知将不会出现问题的系统中编译。&lt;/p&gt;

&lt;p&gt;You still can embed kqueue into a normal poll or select backend and use it only for sockets (after having made sure that sockets work with kqueue on the target platform). See ev_embed watchers for more info.&lt;br /&gt;
你仍旧可以把kqueue嵌入到一个正常的poll或者select的后台，并且只用它来处理sockets（请先确认sockets是否使用kqueue运行在目标平台上）。请查阅ev_embed watchers得到更多的信息。&lt;/p&gt;

&lt;p&gt;It scales in the same way as the epoll backend, but the interface to the kernel is more efficient (which says nothing about its actual speed, of course). While stopping, setting and starting an I/O watcher does never cause an extra system call as with EVBACKEND_EPOLL, it still adds up to two event changes per incident. Support for fork () is very bad (you might have to leak fd’s on fork, but it’s more sane than epoll) and it drops fds silently in similarly hard-to-detect cases.&lt;br /&gt;
kqueue的伸缩性和epoll后台是一样的，但接口调用kernel的效率更高（当然，这没有实际的速度）。和epoll相比，当停止、设置和开始一个IO watcher时也不会引起额外的系统调用。它仍然每个事件变动增加2个event变动。支持fork（）是非常糟糕的（你可能会在fork时有fd泄漏，但是它比epoll少很多），他会在难以检测的情况下悄无声息的泄露fds。&lt;/p&gt;

&lt;p&gt;This backend usually performs well under most conditions.&lt;br /&gt;
这个后台在多数情况下表现良好。&lt;/p&gt;

&lt;p&gt;While nominally embeddable in other event loops, this doesn’t work everywhere, so you might need to test for this. And since it is broken almost everywhere, you should only use it when you have a lot of sockets (for which it usually works), by embedding it into another event loop (e.g. EVBACKEND_SELECT or EVBACKEND_POLL (but poll is of course also broken on OS X)) and, did I mention it, using it only for sockets.&lt;br /&gt;
当名义上将kqueue嵌入到别的event loop时，它都是不能正常运行的，所以你必须要检测它。而且你由于它几乎无处不能运行，你只能在有很多sockets的情况下通过嵌入到另外一个event loop（例如：EVBACKEND_SELECT or EVBACKEND_POLL，当然在OS X上poll也是有问题的。）使用它（这也是它经常做的）。当我提到它的时候，它通常只被sockets使用。&lt;/p&gt;

&lt;p&gt;This backend maps EV_READ into an EVFILT_READ kevent with NOTE_EOF, and EV_WRITE into an EVFILT_WRITE kevent with NOTE_EOF.&lt;br /&gt;
这个后台映射EV_READ到一个带有NOTE_EOF的EVFILT_READ，EV_WRITE映射到带有NOTE_EOF的EVFILT_WRITE。&lt;/p&gt;

&lt;h4 id=&quot;evbackend_devpoll-value-16-solaris-8&quot;&gt;EVBACKEND_DEVPOLL (value 16, Solaris 8)&lt;/h4&gt;
&lt;p&gt;This is not implemented yet (and might never be, unless you send me an implementation). According to reports, /dev/poll only supports sockets and is not embeddable, which would limit the usefulness of this backend immensely.&lt;br /&gt;
这尚未实现 （可能永远不会实现，除非你给我一个实现）。据报道，/dev/poll 只支持套接字并且不能被嵌入，这将极大的限制这个后台的用处。&lt;/p&gt;

&lt;h4 id=&quot;evbackend_port-value-32-solaris-10&quot;&gt;EVBACKEND_PORT (value 32, Solaris 10)&lt;/h4&gt;
&lt;p&gt;This uses the Solaris 10 event port mechanism. As with everything on Solaris, it’s really slow, but it still scales very well (O(active_fds)).&lt;br /&gt;
EVBACKEND_PORT使用solaris 10的event port机制。和一切基于solairs一样，它非常慢，但是它的扩展性非常好（O（active_fds））。&lt;/p&gt;

&lt;p&gt;While this backend scales well, it requires one system call per active file descriptor per loop iteration. For small and medium numbers of file descriptors a “slow” EVBACKEND_SELECT or EVBACKEND_POLL backend might perform better.&lt;br /&gt;
虽然它的扩展性很好，但是每次迭代每个活动的文件描述符都需要一次系统调用。对于中小数量的文件描述符，一个慢的EVBACKEND_SELECT或者EVBACKEND_POLL后台可能表现更好。&lt;/p&gt;

&lt;p&gt;On the positive side, this backend actually performed fully to specification in all tests and is fully embeddable, which is a rare feat among the OS-specific backends (I vastly prefer correctness over speed hacks).&lt;br /&gt;
积极的一面，这个后台实际执行完全符合所有测试的规定，并且完全嵌入。这是操作系统特定的后台之间的一个罕见的壮举（我大大喜欢正确性超过执行速度）。&lt;/p&gt;

&lt;p&gt;On the negative side, the interface is bizarre - so bizarre that even sun itself gets it wrong in their code examples: The event polling function sometimes returns events to the caller even though an error occurred, but with no indication whether it has done so or not (yes, it’s even documented that way) - deadly for edge-triggered interfaces where you absolutely have to know whether an event occurred or not because you have to re-arm the watcher.&lt;br /&gt;
消极的一面，接口非常奇怪-是如此的离奇以至于即使是sun它自己也写了错误的示例程序：事件轮询功能有时返回的事件给调用者，即使发生错误，但没有迹象表明它是否已经这样做了，或不（是的，它甚至记录了这样） - 致命的边沿触发接口，你绝对必须知道是否有事件发生与否，因为你必须重新设置的watcher。&lt;/p&gt;

&lt;p&gt;Fortunately libev seems to be able to work around these idiocies.&lt;br /&gt;
幸运的libev似乎能够解决这些白痴行为。&lt;/p&gt;

&lt;p&gt;This backend maps EV_READ and EV_WRITE in the same way as EVBACKEND_POLL.&lt;br /&gt;
这个后端映射EV_READ和EV_WRITE到相同的方式EVBACKEND_POLL。&lt;/p&gt;

&lt;h4 id=&quot;evbackend_all&quot;&gt;EVBACKEND_ALL&lt;/h4&gt;
&lt;p&gt;Try all backends (even potentially broken ones that wouldn’t be tried with EVFLAG_AUTO). Since this is a mask, you can do stuff such as EVBACKEND_ALL &amp;amp; ~EVBACKEND_KQUEUE.&lt;br /&gt;
尝试所有的后台（甚至可能是那些经过EVFLAG_AUTO尝试而被拒绝的）。由于这是一个mark，你可以设置成EVBACKEND_ALL &amp;amp; ~EVBACKEND_KQUEUE.&lt;/p&gt;

&lt;p&gt;It is definitely not recommended to use this flag, use whatever ev_recommended_backends () returns, or simply do not specify a backend at all.&lt;br /&gt;
这是一个绝对不建议使用的标志位。应该使用ev_recommended_backends（）的返回值或者干脆不指定后台。&lt;/p&gt;

&lt;h4 id=&quot;evbackend_mask&quot;&gt;EVBACKEND_MASK&lt;/h4&gt;
&lt;p&gt;Not a backend at all, but a mask to select all backend bits from a flags value, in case you want to mask out any backends from a flags value (e.g. when modifying the LIBEV_FLAGS environment variable).&lt;br /&gt;
这不是一个后台，但是一个mask从一个flags值中选择所有的后台位，如果你想从flags值中屏蔽掉所有的后台（例如：修改LIBEV_FLAGS环境变量）。&lt;/p&gt;

&lt;p&gt;If one or more of the backend flags are or’ed into the flags value, then only these backends will be tried (in the reverse order as listed here). If none are specified, all backends in ev_recommended_backends () will be tried.&lt;br /&gt;
如果一个后端或多个标志逻辑或运算压入标志值，那么只有这些后台将尝试（如在这里列出的顺序相反）。如果没有指定，在ev_recommended_backends所有的后台（）将被尝试。&lt;/p&gt;

&lt;p&gt;Example: Try to create a event loop that uses epoll and nothing else.&lt;br /&gt;
例如：尝试使用epoll来创建一个event loop。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct ev_loop *epoller = ev_loop_new (EVBACKEND_EPOLL | EVFLAG_NOENV);
if (!epoller)
fatal (&quot;no epoll found here, maybe it hides under your chair&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Example: Use whatever libev has to offer, but make sure that kqueue is used if available.&lt;br /&gt;
例如：使用任何libev所提供的后端，但要确保kqueue的使用（如果可用）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct ev_loop *loop = ev_loop_new (ev_recommended_backends () | EVBACKEND_KQUEUE);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;ev_loop_destroy-loop&quot;&gt;ev_loop_destroy (loop)&lt;/h4&gt;
&lt;p&gt;Destroys an event loop object (frees all memory and kernel state etc.). None of the active event watchers will be stopped in the normal sense, so e.g. ev_is_active might still return true. It is your responsibility to either stop all watchers cleanly yourself before calling this function, or cope with the fact afterwards (which is usually the easiest thing, you can just ignore the watchers and/or free () them for example). &lt;br /&gt;
释放一个event loop对象（释放所有的内存和内核状态等）。通常情况下，没有任何一个活动的event watcher将会停止，所以例如ev_is_active可能仍然返回true。所以要么你在调用这个函数之前停止所有的watchers，要么在调用这个函数之后做相应的处理（通常最简单的解决方案就是忽略watchers的free（）），这是你的职责。&lt;/p&gt;

&lt;p&gt;Note that certain global state, such as signal state (and installed signal handlers), will not be freed by this function, and related watchers (such as signal and child watchers) would need to be stopped manually. &lt;br /&gt;
注意：某些全局变量，比如信号量状态（并且已经注册了信号处理函数的），将不会被这个函数释放掉，这些相关的watchers将需要你手工的停止掉（比如信号和child的watchers）。&lt;/p&gt;

&lt;p&gt;This function is normally used on loop objects allocated by ev_loop_new, but it can also be used on the default loop returned by ev_default_loop, in which case it is not thread-safe. &lt;br /&gt;
这个函数经常被用来释放由ev_loop_new函数分配的event loop对象。但是它也可以被用来释放由ev_default_loop函数分配的默认event loop对象。当然，这样的话，它就不是线程安全的。&lt;/p&gt;

&lt;p&gt;Note that it is not advisable to call this function on the default loop except in the rare occasion where you really need to free its resources. If you need dynamically allocated loops it is better to use ev_loop_new and ev_loop_destroy. &lt;br /&gt;
注意：在默认的loop上调用这个函数是不被推荐的，除非在极少数情况下我们真的需要释放它的资源。如果你想要动态的分配loops，调用ev_loop_new和ev_loop_destroy会更好。&lt;/p&gt;

&lt;h4 id=&quot;ev_loop_fork-loop&quot;&gt;ev_loop_fork (loop)&lt;/h4&gt;
&lt;p&gt;This function sets a flag that causes subsequent ev_run iterations to reinitialise the kernel state for backends that have one. Despite the name, you can call it anytime you are allowed to start or stop watchers (except inside an ev_prepare callback), but it makes most sense after forking, in the child process. You must call it (or use EVFLAG_FORKCHECK) in the child before resuming or calling ev_run.&lt;br /&gt;
这个函数设置一个标志来使后续rv_run迭代重新初始化内核状态（应该是event loop的状态吧？）来得到一个后台。（这句不太有把握，但是应该是这样的）。不用理会这个函数的名字，其实你可以在任何你被允许开始或者停止watchers的时候（除了在一个ev_prepare回调中）调用它，但是它最大的意义在于调用创建子进程之后，在子进程中，你必须在恢复和调用ev_run之前调用它（或者使用EVFLAG_FORKCHECK）。&lt;/p&gt;

&lt;p&gt;Again, you have to call it on any loop that you want to re-use after a fork, even if you do not plan to use the loop in the parent. This is because some kernel interfaces &lt;em&gt;cough&lt;/em&gt; kqueue &lt;em&gt;cough&lt;/em&gt; do funny things during fork.&lt;br /&gt;
即使你不想在父进程中使用这个loop，你也同样需要在fork之后为了重新使用这个loop而调用这个函数。这是因为一些内核接口在fork之中会做一些事情（ &lt;em&gt;cough&lt;/em&gt; kqueue &lt;em&gt;cough&lt;/em&gt;  这是嘛意思？其实这个句话就是在fork的时候会改变libev的loop，所以需要重新设置）。&lt;/p&gt;

&lt;p&gt;On the other hand, you only need to call this function in the child process if and only if you want to use the event loop in the child. If you just fork+exec or create a new loop in the child, you don’t have to call it at all (in fact, epoll is so badly broken that it makes a difference, but libev will usually detect this case on its own and do a costly reset of the backend).&lt;br /&gt;
另一方面，假如你仅仅想在子进程中使用这个event loop，你只要在子进程中调用这个函数。如果你只是使用fork+exec的方式或者是在子进程中创建一个新的loop，那么你不需要调用这个函数。（事实上，epoll是如此的糟糕以至于是如此的与众不同，但是libev通常会自己监测到这种情况并且对这个后台做代价昂贵的复位）。&lt;/p&gt;

&lt;p&gt;The function itself is quite fast and it’s usually not a problem to call it just in case after a fork.&lt;br /&gt;
这个函数是非常快的，在fork之后调用它通常不是一个问题。&lt;/p&gt;

&lt;p&gt;Example: Automate calling ev_loop_fork on the default loop when using pthreads.&lt;br /&gt;
示例：当使用pthreads时，默认的loop自动调用ev_loop_fork&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void
post_fork_child (void)
{
    ev_loop_fork (EV_DEFAULT);
}

...
pthread_atfork (0, 0, post_fork_child);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;int-ev_is_default_loop-loop&quot;&gt;int ev_is_default_loop (loop)&lt;/h4&gt;
&lt;p&gt;Returns true when the given loop is, in fact, the default loop, and false otherwise.&lt;br /&gt;
当给定的loop事实上是默认的loop时返回true，否则返回false。&lt;/p&gt;

&lt;h4 id=&quot;unsigned-int-ev_iteration-loop&quot;&gt;unsigned int ev_iteration (loop)&lt;/h4&gt;
&lt;p&gt;Returns the current iteration count for the event loop, which is identical to the number of times libev did poll for new events. It starts at 0 and happily wraps around with enough iterations.&lt;br /&gt;
返回当前event loop的迭代次数，它和libev为了新的events做poll的次数是相同的。它从0开始并且包含有足够的迭代。&lt;/p&gt;

&lt;p&gt;This value can sometimes be useful as a generation counter of sorts (it “ticks” the number of loop iterations), as it roughly corresponds with ev_prepare and ev_check calls - and is incremented between the prepare and check phases.&lt;br /&gt;
这个值作为各种各样的一代计数器时可能会非常有用（它驱动loop的迭代次数），因为它大致和ev_prepare和ev_check的调用次数相同，并且它在prepare和check的中间阶段递增。&lt;/p&gt;

&lt;h4 id=&quot;unsigned-int-ev_depth-loop&quot;&gt;unsigned int ev_depth (loop)&lt;/h4&gt;
&lt;p&gt;Returns the number of times ev_run was entered minus the number of times ev_run was exited normally, in other words, the recursion depth.&lt;br /&gt;
返回ev_run进入的次数减去ev_run正常退出的次数，换句话说，是递归的深度。&lt;/p&gt;

&lt;p&gt;Outside ev_run, this number is zero. In a callback, this number is 1, unless ev_run was invoked recursively (or from another thread), in which case it is higher.&lt;br /&gt;
在ev_run范围之外，这个值是0，在一个回调中，这个值是1，除非ev_run被递归的调用（或者从另外一个线程调用），在这种情况下，这个值会更高。&lt;/p&gt;

&lt;p&gt;Leaving ev_run abnormally (setjmp/longjmp, cancelling the thread, throwing an exception etc.), doesn’t count as “exit” - consider this as a hint to avoid such ungentleman-like behaviour unless it’s really convenient, in which case it is fully supported.&lt;br /&gt;
异常的退出ev_run（setjmp/longjmp，取消这个线程，抛出一个异常等等）不能算作是正常退出。把它看成一个避免类似的下三滥行为的提示，除非它真的很方便，在这种情况下，它是被支持的。&lt;/p&gt;

&lt;h4 id=&quot;unsigned-int-ev_backend-loop&quot;&gt;unsigned int ev_backend (loop)&lt;/h4&gt;
&lt;p&gt;Returns one of the EVBACKEND_* flags indicating the event backend in use.&lt;br /&gt;
返回EVBACKEND_*之一，说明那个event backed正在使用。&lt;/p&gt;

&lt;h4 id=&quot;ev_tstamp-ev_now-loop&quot;&gt;ev_tstamp ev_now (loop)&lt;/h4&gt;
&lt;p&gt;Returns the current “event loop time”, which is the time the event loop received events and started processing them. This timestamp does not change as long as callbacks are being processed, and this is also the base time used for relative timers. You can treat it as the timestamp of the event occurring (or more correctly, libev finding out about it).&lt;br /&gt;
返回当前“event loop”的时间，它是接收到事件并且开始处理它们的时间。在回调被处理的时候，这个时间戳不会被改变，并且这也是用于相对定时器的基准时间。你可以把它看成事件发生的时间戳（或者更正确的说，libev找不到它）（译者注：最后一句libev找不到它什么意思？）&lt;/p&gt;

&lt;h4 id=&quot;ev_now_update-loop&quot;&gt;ev_now_update (loop)&lt;/h4&gt;
&lt;p&gt;Establishes the current time by querying the kernel, updating the time returned by ev_now () in the progress. This is a costly operation and is usually done automatically within ev_run ().&lt;br /&gt;
通过查询内核，更新进程中由ev_now()返回的当前时间。这个操作很昂贵，并且这个操作一般都是由ev_run自动实现。&lt;/p&gt;

&lt;p&gt;This function is rarely useful, but when some event callback runs for a very long time without entering the event loop, updating libev’s idea of the current time is a good idea.&lt;br /&gt;
这个函数很少有用，但是当一些event的回调运行很长时间并且没有进入event loop时，更新libev的当前时间是一个好主意。&lt;/p&gt;

&lt;p&gt;See also The special problem of time updates in the ev_timer section.&lt;br /&gt;
请参阅ev_timer部分更新时间的特别问题。&lt;/p&gt;

&lt;h4 id=&quot;ev_suspend-loop&quot;&gt;ev_suspend (loop)&lt;/h4&gt;
&lt;h4 id=&quot;ev_resume-loop&quot;&gt;ev_resume (loop)&lt;/h4&gt;
&lt;p&gt;These two functions suspend and resume an event loop, for use when the loop is not used for a while and timeouts should not be processed.&lt;br /&gt;
这2个函数暂停和恢复一个event loop。当loop已经很长时间没被使用的时候，不用处理过期时间。&lt;/p&gt;

&lt;p&gt;A typical use case would be an interactive program such as a game: When the user presses ^Z to suspend the game and resumes it an hour later it would be best to handle timeouts as if no time had actually passed while the program was suspended. This can be achieved by calling ev_suspend in your SIGTSTP handler, sending yourself a SIGSTOP and calling ev_resume directly afterwards to resume timer processing.&lt;br /&gt;
一个典型的使用场景是一个交互程序，例如游戏：当用处按下 ^Z来暂停游戏并且在一个小时后候恢复，那么最好处理过期时间，就像在程序暂停的时候真正的时间没有过去一样。这可以通过在SIGTSTP信号处理函数中调用ev_suspend，给自己发送SIGSTOP信号并且调用ev_resume直接事后恢复定时器处理来实现。&lt;/p&gt;

&lt;p&gt;Effectively, all ev_timer watchers will be delayed by the time spend between ev_suspend and ev_resume, and all ev_periodic watchers will be rescheduled (that is, they will lose any events that would have occurred while suspended).&lt;br /&gt;
事实上，所有的ev_timer都会被通过在ev_suspend和ev_resume之间花费时间而被延迟，而所有的ev_periodic watchers将会被重新安排（即，他们将会丢失掉一些在暂停的时候已经发生的事件）。&lt;/p&gt;

&lt;p&gt;After calling ev_suspend you must not call any function on the given loop other than ev_resume, and you must not call ev_resume without a previous call to ev_suspend.&lt;br /&gt;
在调用ev_suspend之后，你不能在这个loop上调用除了ev_resume之外的函数，并且你不能在没有调用ev_suspend之前调用ev_resume。&lt;/p&gt;

&lt;p&gt;Calling ev_suspend/ev_resume has the side effect of updating the event loop time (see ev_now_update).&lt;br /&gt;
调用ev_suspend/ev_resume将会对更新event loop时间有副作用.(请查看ev_now_update）。&lt;/p&gt;

&lt;h4 id=&quot;bool-ev_run-loop-int-flags&quot;&gt;bool ev_run (loop, int flags)&lt;/h4&gt;
&lt;p&gt;Finally, this is it, the event handler. This function usually is called after you have initialised all your watchers and you want to start handling events. It will ask the operating system for any new events, call the watcher callbacks, and then repeat the whole process indefinitely: This is why event loops are called loops.&lt;br /&gt;
最后，这就是事件处理程序。这个函数通常在你已经初始化你所有的watchers和你想开始处理events时调用。它将会询问操作系统任何新的events，调用watcher的回调函数，并且无限制的重复整个过程：这就是为什么event loop被称作循环。&lt;/p&gt;

&lt;p&gt;If the flags argument is specified as 0, it will keep handling events until either no event watchers are active anymore or ev_break was called.&lt;br /&gt;
如果标志位参数被设置成0，他将会继续处理事件，直到没有活跃的event watchers或者ev_break被调用。&lt;/p&gt;

&lt;p&gt;The return value is false if there are no more active watchers (which usually means “all jobs done” or “deadlock”), and true in all other cases (which usually means “ you should call ev_run again”).&lt;br /&gt;
如果没有更多的活跃watchers（通常意味着所有的工作都完成了或者是死锁了）将会返回false，在其他情况下返回true（这通常意味着你需要再一次调用ev_run）。&lt;/p&gt;

&lt;p&gt;Please note that an explicit ev_break is usually better than relying on all watchers to be stopped when deciding when a program has finished (especially in interactive programs), but having a program that automatically loops as long as it has to and no longer by virtue of relying on its watchers stopping correctly, that is truly a thing of beauty.&lt;br /&gt;
请注意：一个明确的ev_break调用要好于依赖所有的watchers被停止来决定完成一个程序（特别是交互式程序）。有一些程序只要它必须并且仍然相信所有的watcers可以正确的停止。这才是真正美妙的事情。（译者注：这句话就是可能真正美好的程序就是event loop自动的可以依靠event全部完成而自行结束？）。&lt;/p&gt;

&lt;p&gt;This function is mostly exception-safe - you can break out of a ev_run call by calling longjmp in a callback, throwing a C++ exception and so on. This does not decrement the ev_depth value, nor will it clear any outstanding EVBREAK_ONE breaks.&lt;br /&gt;
这个函数主要是“异常安全”的，你可以通过在回调中调用longjmp，抛出一个cxx的异常或者等等方法来跳出ev_run，这不会减少ev_depth的值，也不会清除任何没有解决的EVBREAK_ONE.&lt;/p&gt;

&lt;p&gt;A flags value of EVRUN_NOWAIT will look for new events, will handle those events and any already outstanding ones, but will not wait and block your process in case there are no events and will return after one iteration of the loop. This is sometimes useful to poll and handle new events while doing lengthy calculations, to keep the program responsive.&lt;br /&gt;
EVRUN_NOWAIT这个标志值将会寻找新的事件，并且处理这些事件和那些已经未解决的事件，但是在没有事件的情况下，它不会等待并且阻塞你的进程，并且在一次loop迭代后返回。这个标志值在poll和处理新事件时需要长时间计算来保持程序相应的时候通常是有用的。&lt;/p&gt;

&lt;p&gt;A flags value of EVRUN_ONCE will look for new events (waiting if necessary) and will handle those and any already outstanding ones. It will block your process until at least one new event arrives (which could be an event internal to libev itself, so there is no guarantee that a user-registered callback will be called), and will return after one iteration of the loop.&lt;br /&gt;
EVRUN_ONCE这个标志值将会寻找新的时间（如果有必要将会等待新的事件），并且处理这些事件和那些已经未解决的事件，它将会阻塞你的进程直到至少一个新的事件到达（这个事件可能是libev自己的内部事件，所以不能保证用户注册的回调将会被调用），并且在一次loop迭代后返回；&lt;/p&gt;

&lt;p&gt;This is useful if you are waiting for some external event in conjunction with something not expressible using other libev watchers (i.e. “roll your own ev_run”). However, a pair of ev_prepare/ev_check watchers is usually a better approach for this kind of thing.&lt;br /&gt;
如果你正在等待外部事件并且并没有使用另外的libev watcher，这是非常有用的（例如：循环你自己的ev_run)，但是，一对ev_prepare/ev_check watchers通常是这种事情更好的方法。&lt;/p&gt;

&lt;p&gt;Here are the gory details of what ev_run does (this is for your understanding, not a guarantee that things will work exactly like this in future versions):&lt;br /&gt;
这是吐血推荐的ev_run的细节（这是给你理解用的，并不能保证在将来的版本中也会这样运行）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Increment loop depth.&lt;br /&gt;
  增加loop的深度（是不是循环次数？）&lt;/li&gt;
  &lt;li&gt;Reset the ev_break status.&lt;br /&gt;
  重置ev_break的状态&lt;/li&gt;
  &lt;li&gt;Before the first iteration, call any pending watchers.&lt;br /&gt;
  在首次循环之前，调用pending watchers。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;loop&quot;&gt;LOOP:&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;If EVFLAG_FORKCHECK was used, check for a fork.&lt;br /&gt;
  如果EVFLAG_FORKCHECK被使用，检查fork。&lt;/li&gt;
  &lt;li&gt;If a fork was detected (by any means), queue and call all fork watchers.&lt;br /&gt;
  如果fork被检测到（不管使用任何方法），排队并且调用所有的fork watchers。&lt;/li&gt;
  &lt;li&gt;Queue and call all prepare watchers.&lt;br /&gt;
  排队并且调用所有的前期准备watchers。&lt;/li&gt;
  &lt;li&gt;If ev_break was called, goto FINISH.&lt;br /&gt;
  如果ev_break被调用，直接运行FINISH。&lt;/li&gt;
  &lt;li&gt;If we have been forked, detach and recreate the kernel state
  as to not disturb the other process.&lt;br /&gt;
  如果fork被调用，分离并且重新创建内核状态，来达到不干扰其他进程的目的。&lt;/li&gt;
  &lt;li&gt;Update the kernel state with all outstanding changes.&lt;br /&gt;
  使用未完成的改变来更新内核状态。&lt;/li&gt;
  &lt;li&gt;Update the “event loop time” (ev_now ()).&lt;br /&gt;
  更新event loop时间（ev_now（））。&lt;/li&gt;
  &lt;li&gt;Calculate for how long to sleep or block, if at all
  (active idle watchers, EVRUN_NOWAIT or not having
  any active watchers at all will result in not sleeping).&lt;br /&gt;
  休眠或者究竟阻塞了多长时间，（主动闲置的watchers，EVRUN_NOWAIT或者没有任何活动的watchers导致不会睡眠。）（PS：这句话很别扭）。&lt;/li&gt;
  &lt;li&gt;Sleep if the I/O and timer collect interval say so.&lt;br /&gt;
  在IO和timer的时间间隔区休眠&lt;/li&gt;
  &lt;li&gt;Increment loop iteration counter.&lt;br /&gt;
  增加循环迭代计数&lt;/li&gt;
  &lt;li&gt;Block the process, waiting for any events.&lt;br /&gt;
  阻塞进程，等待任何events&lt;/li&gt;
  &lt;li&gt;Queue all outstanding I/O (fd) events.&lt;br /&gt;
  排队所有未完成的IO事件（fd）&lt;/li&gt;
  &lt;li&gt;Update the “event loop time” (ev_now ()), and do time jump adjustments.&lt;br /&gt;
    - 更新“事件循环时间”（ev_now（）），并做一次大的调整。&lt;/li&gt;
  &lt;li&gt;Queue all expired timers.&lt;br /&gt;
  队列中的所有过期的计时器&lt;/li&gt;
  &lt;li&gt;Queue all expired periodics.&lt;br /&gt;
  队列中的所有过期periodics。&lt;/li&gt;
  &lt;li&gt;Queue all idle watchers with priority higher than that of pending events.&lt;br /&gt;
  队列中的所有空闲的watchers优先级高于挂起事件。&lt;/li&gt;
  &lt;li&gt;Queue all check watchers.&lt;br /&gt;
  排队所有check watchers。&lt;/li&gt;
  &lt;li&gt;Call all queued watchers in reverse order (i.e. check watchers first).
  Signals and child watchers are implemented as I/O watchers, and will
  be handled here by queueing them when their watcher gets executed.&lt;br /&gt;
  以倒序调用所有排列后的watchers（例如，首先是check watchers）。
  信号和子程序 watchers被当作io watchers实现，并且当他们的watchers被执行时会被在这里排序处理。&lt;/li&gt;
  &lt;li&gt;If ev_break has been called, or EVRUN_ONCE or EVRUN_NOWAIT&lt;br /&gt;
  were used, or there are no active watchers, goto FINISH, otherwise
  continue with step LOOP.&lt;br /&gt;
  如果ev_break被调用，或者EVRUN_ONCE或者EVRUN_NOWAIT被使用，或者没有活动的watchers，直接运行FINISH；否则继续loop步骤。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;finish&quot;&gt;FINISH:&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;Reset the ev_break status iff it was EVBREAK_ONE.&lt;br /&gt;
  当且仅当它是EVBREAK_ONE时，充值EV_BREAK&lt;/li&gt;
  &lt;li&gt;Decrement the loop depth.&lt;br /&gt;
  减少loop的层次&lt;/li&gt;
  &lt;li&gt;Return.&lt;br /&gt;
  返回&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Example: Queue some jobs and then loop until no events are outstanding anymore.
    排列一些jobs，然后循环直到没有事件被凸显出来。

    ... queue jobs here, make sure they register event watchers as long
    ... as they still have work to do (even an idle watcher will do..)
    ev_run (my_loop, 0);
    ... jobs done or somebody called break. yeah!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;ev_break-loop-how&quot;&gt;ev_break (loop, how)&lt;/h4&gt;
&lt;p&gt;Can be used to make a call to ev_run return early (but only after it has processed all outstanding events). The how argument must be either EVBREAK_ONE, which will make the innermost ev_run call return, or EVBREAK_ALL, which will make all nested ev_run calls return.&lt;br /&gt;
调用此函数可以让ev_run结束并且返回（但是必须在处理完未决的事件）。how参数可能是EVBREAK_ONE，这将使ev_run最里面的循环返回，或者是EVBREAK_ALL，这将使得所有的循环嵌套返回。&lt;/p&gt;

&lt;p&gt;This “break state” will be cleared on the next call to ev_run.&lt;br /&gt;
这种break状态将会在ev_run的下一次调用中清除。&lt;/p&gt;

&lt;p&gt;It is safe to call ev_break from outside any ev_run calls, too, in which case it will have no effect.&lt;br /&gt;
在ev_run调用之外调用ev_break是安全的，在这种情况下，调用将没有任何效果。&lt;/p&gt;

&lt;h4 id=&quot;ev_ref-loop&quot;&gt;ev_ref (loop)&lt;/h4&gt;
&lt;h4 id=&quot;ev_unref-loop&quot;&gt;ev_unref (loop)&lt;/h4&gt;
&lt;p&gt;Ref/unref can be used to add or remove a reference count on the event loop: Every watcher keeps one reference, and as long as the reference count is nonzero, ev_run will not return on its own.&lt;br /&gt;
ref/unref被用来增加或者删除一个event loop的引用计数，每一个watcher都保存了一个引用，只要引用计数不为零，ev_run就不会自行返回。&lt;/p&gt;

&lt;p&gt;This is useful when you have a watcher that you never intend to unregister, but that nevertheless should not keep ev_run from returning. In such a case, call ev_unref after starting, and ev_ref before stopping it.&lt;br /&gt;
当你有一个从来没有打算注销的watcher，但仍然不想让ev_run无法返回的时候，这是非常有用的。在这种情况下，你可以在开始之后调用ev_unref和在停止之前调用ev_ref。&lt;/p&gt;

&lt;p&gt;As an example, libev itself uses this for its internal signal pipe: It is not visible to the libev user and should not keep ev_run from exiting if no event watchers registered by it are active. It is also an excellent way to do this for generic recurring timers or from within third-party libraries. Just remember to unref after start and ref before stop (but only if the watcher wasn’t active before, or was active before, respectively. Note also that libev might stop watchers itself (e.g. non-repeating timers) in which case you have to ev_ref in the callback).&lt;br /&gt;
作为一个例子，libev自己内部使用这些函数来处理signal pipe（这里是不是翻译成SIGPIPE这个信号啊？），它对于最终的libev用户来说是不可见的，并且如果没有event watchers被注册成活跃的，它不应该让ev_run退出。对于一般性的定时器和第三方的程序库，这也是一个很好的方法。只需要记住在开始的时候unref，并且在stop之前ref（但是仅当分别在watcher不活跃之前，或者已经活跃之前）也要注意在某些你需要在回调中ev_ref的情况下，libev将会自己停止watchers（例如：不重复的定时器）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Example: Create a signal watcher, but keep it from keeping ev_run running when nothing else is active.
    示例：创建一个信号watcher，并且保证它在没有任何另外活跃的事件的时候，保持ev_run运行。

    ev_signal exitsig;
    ev_signal_init (&amp;amp;exitsig, sig_cb, SIGINT);
    ev_signal_start (loop, &amp;amp;exitsig);
    ev_unref (loop);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Example: For some weird reason, unregister the above signal handler again.
    例如：对于一些奇怪的原因，再注销上面的信号事件处理程序。

    ev_ref (loop);
    ev_signal_stop (loop, &amp;amp;exitsig);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;ev_set_io_collect_interval-loop-ev_tstamp-interval&quot;&gt;ev_set_io_collect_interval (loop, ev_tstamp interval)&lt;/h4&gt;
&lt;h4 id=&quot;ev_set_timeout_collect_interval-loop-ev_tstamp-interval&quot;&gt;ev_set_timeout_collect_interval (loop, ev_tstamp interval)&lt;/h4&gt;
&lt;p&gt;These advanced functions influence the time that libev will spend waiting for events. Both time intervals are by default 0, meaning that libev will try to invoke timer/periodic callbacks and I/O callbacks with minimum latency. &lt;br /&gt;
这些高级功能会影响libev将会花在等待events的时间。两者的时间间隔默认为0.意味着libev将会试着以最小的延迟来调用timer/periodic的回调和io的回调。&lt;/p&gt;

&lt;p&gt;Setting these to a higher value (the interval must be &amp;gt;= 0) allows libev to delay invocation of I/O and timer/periodic callbacks to increase efficiency of loop iterations (or to increase power-saving opportunities).&lt;br /&gt;
把这些值设置的大一点（时间间隔必须大于0）将会允许libev延迟调用io和timer、peroodic的回调函数，来增加loop循环调用的效率（或者增加省电的机会）。&lt;/p&gt;

&lt;p&gt;The idea is that sometimes your program runs just fast enough to handle one (or very few) event(s) per loop iteration. While this makes the program responsive, it also wastes a lot of CPU time to poll for new events, especially with backends like select () which have a high overhead for the actual polling but can deliver many events at once.&lt;br /&gt;
libev的假设是有的时候，你的程序将会运行的很快，快到足够每次循环来处理一个事件（或者很少的事件），虽然这样可以让程序保持了高响应，但是也浪费了很多的CPU时间来轮训新的事件，特别是当后台使用像select（）这种需要高系统开销的实际的轮流检测，但是可以立刻发现很多事件。&lt;/p&gt;

&lt;p&gt;By setting a higher io collect interval you allow libev to spend more time collecting I/O events, so you can handle more events per iteration, at the cost of increasing latency. Timeouts (both ev_periodic and ev_timer) will not be affected. Setting this to a non-null value will introduce an additional ev_sleep () call into most loop iterations. The sleep time ensures that libev will not poll for I/O events more often then once per this interval, on average (as long as the host time resolution is good enough).&lt;br /&gt;
通过设置一个较高的io collect时间间隔，你将会允许libev花更多的时间来发现IO事件，所以你可以通过增加延迟的成本来一次迭代处理多个事件。时间过期（包括ev_periodic和ev_timer）将不会受到影响。设置这个值为“非空”，将会在大多数的loop迭代中增加一个ev_sleep调用。休眠时间确保libev将不会多余每次的时间间隔来循环触发IO事件。&lt;/p&gt;

&lt;p&gt;Likewise, by setting a higher timeout collect interval you allow libev to spend more time collecting timeouts, at the expense of increased latency/jitter/inexactness (the watcher callback will be called later). ev_io watchers will not be affected. Setting this to a non-null value will not introduce any overhead in libev.&lt;br /&gt;
同样，通过设置一个较高的超时时间间隔，你将会允许libev花很多的时间来触发超时，这将会增加延迟/抖动/不精确（watchers的回调将在后面调用）的开销。ev_io watchers将不会收到影响。将其设置为一个“非空”值将不会增加libev任何的开销。&lt;/p&gt;

&lt;p&gt;Many (busy) programs can usually benefit by setting the I/O collect interval to a value near 0.1 or so, which is often enough for interactive servers (of course not for games), likewise for timeouts. It usually doesn’t make much sense to set it to a lower value than 0.01, as this approaches the timing granularity of most systems. Note that if you do transactions with the outside world and you can’t increase the parallelity, then this setting will limit your transaction rate (if you need to poll once per transaction and the I/O collect interval is 0.01, then you can’t do more than 100 transactions per second). &lt;br /&gt;
很多（繁忙）的程序通常可以通过设置IO触发间隔为0.1左右来受益（效率最大化嘛？）同样的超时时间经常满足一些交互式服务器（当然不能满足游戏。PS：游戏设置多好合适？，貌似没说）。通常，将其设置为一个小于0.01的数将会失去意义，因为0.01通常是大多数系统的时间精度。注意：如果你这样和外界的接口通讯，那么你将不能增加程序的并行性，则这样的设置将会限制你的成功率（如果你需要轮训每次事务，并且IO collect 时间间隔是0.01.你最大的吞吐量也就是100/s）。&lt;/p&gt;

&lt;p&gt;Setting the timeout collect interval can improve the opportunity for saving power, as the program will “bundle” timer callback invocations that are “near” in time together, by delaying some, thus reducing the number of times the process sleeps and wakes up again. Another useful technique to reduce iterations/wake-ups is to use ev_periodic watchers and make sure they fire on, say, one-second boundaries only.&lt;br /&gt;
设置这个超时时间间隔将会改善省电的机会（PS：效率变慢了？），程序将会捆绑的调用那些超时时间接近的回调函数，通过一些延迟，减少了进程休眠的次数和唤醒的次数，另外一个有用的技术是在使用ev_periodic watchers的时候减少迭代和唤醒的次数，并且确保他们被触发，也就是说，只有一秒钟的时间间隔。（PS：最后一个一秒的界限是什么意思？）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Example: we only need 0.1s timeout granularity, and we wish not to poll more often than 100 times per second:
    示例：我们仅仅需要0.1s的超时精度，并且我们希望迭代少于100次/s。

    ev_set_timeout_collect_interval (EV_DEFAULT_UC_ 0.1);
    ev_set_io_collect_interval (EV_DEFAULT_UC_ 0.01);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;ev_invoke_pending-loop&quot;&gt;ev_invoke_pending (loop)&lt;/h4&gt;
&lt;p&gt;This call will simply invoke all pending watchers while resetting their pending state. Normally, ev_run does this automatically when required, but when overriding the invoke callback this call comes handy. This function can be invoked from a watcher - this can be useful for example when you want to do some lengthy calculation and want to pass further event handling to another thread (you still have to make sure only one thread executes within ev_invoke_pending or ev_run of course).&lt;br /&gt;
这个调用将会简单的调用所有未触发的watchers并且重置它们的未触发状态。通常，ev_run在需要的情况下自动的做这些，但是当覆盖这个回调调用的时候，ev_invoke_pending将会变得得心应手。这个函数将可以在一个watcher中被调用，例如对于你想做一些耗时的计算并且希望另外一个线程进一步的处理来说将会是非常有用的。（当然，你仍然必须保证只有一个线程执行e_invoke_pending或者ev_run）。&lt;/p&gt;

&lt;h4 id=&quot;int-ev_pending_count-loop&quot;&gt;int ev_pending_count (loop)&lt;/h4&gt;
&lt;p&gt;Returns the number of pending watchers - zero indicates that no watchers are pending.&lt;br /&gt;
返回未被触发的watchers数目-0表示没有未触发的watchers。&lt;/p&gt;

&lt;h4 id=&quot;ev_set_invoke_pending_cb-loop-void-invoke_pending_cbev_p&quot;&gt;ev_set_invoke_pending_cb (loop, void (*invoke_pending_cb)(EV_P))&lt;/h4&gt;
&lt;p&gt;This overrides the invoke pending functionality of the loop: Instead of invoking all pending watchers when there are any, ev_run will call this callback instead. This is useful, for example, when you want to invoke the actual watchers inside another context (another thread etc.).&lt;br /&gt;
这将重写loop的调用未触发函数：当它存在的时候，将会代替调用所有的未触发watchers，ev_run将会调用这个回调替代。例如对于你想调用真实的watchers在另外一个上下文环境中（另外一个线程等等）将会是非常有用的。&lt;/p&gt;

&lt;p&gt;If you want to reset the callback, use ev_invoke_pending as new callback.&lt;br /&gt;
如果你想重置这个回调，使用ev_invoke_penging作为新的回调。&lt;/p&gt;

&lt;h4 id=&quot;ev_set_loop_release_cb-loop-void-releaseev_p-throw--void-acquireev_p-throw-&quot;&gt;ev_set_loop_release_cb (loop, void (&lt;em&gt;release)(EV_P) throw (), void (&lt;/em&gt;acquire)(EV_P) throw ())&lt;/h4&gt;
&lt;p&gt;Sometimes you want to share the same loop between multiple threads. This can be done relatively simply by putting mutex_lock/unlock calls around each call to a libev function.&lt;br /&gt;
有时你想在多个线程中共享同一个loop。这将可以通过在libev的函数中放置mutex的lock/unlock来简单的实现。&lt;/p&gt;

&lt;p&gt;However, ev_run can run an indefinite time, so it is not feasible to wait for it to return. One way around this is to wake up the event loop via ev_break and ev_async_send, another way is to set these release and acquire callbacks on the loop.&lt;br /&gt;
然而，ev_run是在一个不确定的时间运行的，所以要等待它返回是不可行的。一种解决办法就是通过ev_break和ev_async_send来唤醒event loop，另外一种解决方法就是在循环的时候设置Release和acquire回调。&lt;/p&gt;

&lt;p&gt;When set, then release will be called just before the thread is suspended waiting for new events, and acquire is called just afterwards.&lt;br /&gt;
当设置Release和acquire的时候，Release将会在线程被挂起等待新事件之前被调用，acquire将会在等到新事件后被调用。&lt;/p&gt;

&lt;p&gt;Ideally, release will just call your mutex_unlock function, and acquire will just call the mutex_lock function again.&lt;br /&gt;
理想情况下，Release将会只调用你的mutex的unlock函数，而acquire将只调用mutex的lock函数。&lt;/p&gt;

&lt;p&gt;While event loop modifications are allowed between invocations of release and acquire (that’s their only purpose after all), no modifications done will affect the event loop, i.e. adding watchers will have no effect on the set of file descriptors being watched, or the time waited. Use an ev_async watcher to wake up ev_run when you want it to take note of any changes you made.&lt;br /&gt;
在Release和acquire调用之间修改event loop是被允许的（毕竟这是它们唯一的目的），没有修改完成将会影响event loop，例如：加入的那些watchers 在那些被监视的文件描述符或者时间等待上没有效果。当你想注意那些你制造的任何更改时，使用ev_async watcher来唤醒ev_run。&lt;/p&gt;

&lt;p&gt;In theory, threads executing ev_run will be async-cancel safe between invocations of release and acquire.&lt;br /&gt;
理论上，在Release和acquire调用之间，线程执行ev_run将不是异步安全的。&lt;/p&gt;

&lt;p&gt;See also the locking example in the THREADS section later in this document.&lt;br /&gt;
请参阅本文档后面在THREADS章节的有关于说的示例。&lt;/p&gt;

&lt;h4 id=&quot;ev_set_userdata-loop-void-data&quot;&gt;ev_set_userdata (loop, void *data)&lt;/h4&gt;
&lt;h4 id=&quot;void-ev_userdata-loop&quot;&gt;void *ev_userdata (loop)&lt;/h4&gt;
&lt;p&gt;Set and retrieve a single void * associated with a loop. When ev_set_userdata has never been called, then ev_userdata returns 0.&lt;br /&gt;
设置和获取一个和loop相关联的void *（PS：译为对象可能会好一些）。当ev_set_userdata没有被调用的时候，ev_userdata将会返回0.&lt;/p&gt;

&lt;p&gt;These two functions can be used to associate arbitrary data with a loop, and are intended solely for the invoke_pending_cb, release and acquire callbacks described above, but of course can be (ab-)used for any other purpose as well.&lt;br /&gt;
这两个函数用来和loop关联任何数据，并且仅仅在invoke_pending_cb，Release和acquire回调之中可以被获取，但是当然也可以被用于其他目的。&lt;/p&gt;

&lt;h4 id=&quot;ev_verify-loop&quot;&gt;ev_verify (loop)&lt;/h4&gt;
&lt;p&gt;This function only does something when EV_VERIFY support has been compiled in, which is the default for non-minimal builds. It tries to go through all internal structures and checks them for validity. If anything is found to be inconsistent, it will print an error message to standard error and call abort ().&lt;br /&gt;
当EV_VERIFY被开启并且被编译的时候，这个函数才会有作用，这是默认的非最小版本（PS：不明白什么意思），它试图检查所有的内部结构体和检查他们的有效性。如果发现任何的不一致，它将会打印一个错误的消息并且调用abort终止程序。&lt;/p&gt;

&lt;p&gt;This can be used to catch bugs inside libev itself: under normal circumstances, this function will never abort as of course libev keeps its data structures consistent.&lt;br /&gt;
这可以被用来捕捉内部libev本身的错误：在正常情况下，当libev保持它的数据结构是一致的时候，这个函数将永远不会abort。&lt;/p&gt;

&lt;h3 id=&quot;anatomy-of-a-watcher-watcher的详细说明&quot;&gt;ANATOMY OF A WATCHER watcher的详细说明&lt;/h3&gt;

&lt;p&gt;In the following description, uppercase TYPE in names stands for the watcher type, e.g. ev_TYPE_start can mean ev_timer_start for timer watchers and ev_io_start for I/O watchers.&lt;br /&gt;
在下面的描述中，名称中大写的TYPE表示watcher的类型。例如ev_TYPE_start可以表示用于定时器的ev_timer_start，也可以表示用于IO watchers的ev_io_start。&lt;/p&gt;

&lt;p&gt;A watcher is an opaque structure that you allocate and register to record your interest in some event. To make a concrete example, imagine you want to wait for STDIN to become readable, you would create an ev_io watcher for that:&lt;br /&gt;
watcher是一个你创建并且注册到你感兴趣的event的不透明的结构体，举个具体的例子，假设你想要等到你的STDIN变得可读，你将创建如下的一个watcher：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void my_cb (struct ev_loop *loop, ev_io *w, int revents)
{
    ev_io_stop (w);
    ev_break (loop, EVBREAK_ALL);
}

struct ev_loop *loop = ev_default_loop (0);

ev_io stdin_watcher;

ev_init (&amp;amp;stdin_watcher, my_cb);
ev_io_set (&amp;amp;stdin_watcher, STDIN_FILENO, EV_READ);
ev_io_start (loop, &amp;amp;stdin_watcher);

ev_run (loop, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;As you can see, you are responsible for allocating the memory for your watcher structures (and it is usually a bad idea to do this on the stack).&lt;br /&gt;
就像你看到的，你有职责为你的watcher分配内存（通常的，使用栈内存是一个不明智的主意）。（译者注：作者的意思是你应该尽量使用堆内存）&lt;/p&gt;

&lt;p&gt;Each watcher has an associated watcher structure (called struct ev_TYPE or simply ev_TYPE, as typedefs are provided for all watcher structs).&lt;br /&gt;
每一个watcher都有相关联的结构体（称为struct ev_TYPE或者干脆使用ev_TYPE作为所有watcher的结构体定义）。&lt;/p&gt;

&lt;p&gt;Each watcher structure must be initialised by a call to ev_init (watcher *, callback), which expects a callback to be provided. This callback is invoked each time the event occurs (or, in the case of I/O watchers, each time the event loop detects that the file descriptor given is readable and/or writable).&lt;br /&gt;
每一个watcher必须提供一个回调，并且调用ev_init来初始化，这个回调将会在每次事件发生的时候被调用（或者对于IO watcher来说，event loop将会在文件描述符变得可读或者可写的情况下调用）。&lt;/p&gt;

&lt;p&gt;Each watcher type further has its own ev_TYPE_set (watcher *, …) macro to configure it, with arguments specific to the watcher type. There is also a macro to combine initialisation and setting in one call: ev_TYPE_init (watcher *, callback, …).&lt;br /&gt;
每一个watcher类型都拥有带有指定watcher类型参数的，它自己的ev_TYPE_set宏来配置它。这有一个组合了初始化和配置功能的宏供使用，它就是ev_TYPE_init。&lt;/p&gt;

&lt;p&gt;To make the watcher actually watch out for events, you have to start it with a watcher-specific start function (ev_TYPE_start (loop, watcher *)), and you can stop watching for events at any time by calling the corresponding stop function (ev_TYPE_stop (loop, watcher *).&lt;br /&gt;
为了使watcher开始监视事件，你必须使用watcher专用的开始函数ev_TYPE_start来启动它，你也可以在任何时候通过调用相应的停止函数ev_TYPE_stop来停止监视事件。&lt;/p&gt;

&lt;p&gt;As long as your watcher is active (has been started but not stopped) you must not touch the values stored in it. Most specifically you must never reinitialise it or call its ev_TYPE_set macro.&lt;br /&gt;
只要你的watcher还存活着（已经开始还没有停止），你没必要去更改它的值，最具体的，你没必要去重新初始化或者调用它的ev_TYPE_set宏。&lt;/p&gt;

&lt;p&gt;Each and every callback receives the event loop pointer as first, the registered watcher structure as second, and a bitset of received events as third argument.&lt;br /&gt;
每一个回调函数第一个参数是event loop的指针，第二个参数是已经注册的watcher结构，第三个参数是接收到的事件标志位。&lt;/p&gt;

&lt;p&gt;The received events usually include a single bit per event type received (you can receive multiple events at the same time). The possible bit masks are:&lt;br /&gt;
接受到的事件经常包括一个bit数据集（你可以同时接收到多个时间），这个标志位经常包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;EV_READ&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EV_WRITE&lt;br /&gt;
The file descriptor in the ev_io watcher has become readable and/or writable.&lt;br /&gt;
ev_io watcher中的文件描述符变得可读和/或者可写。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EV_TIMER&lt;br /&gt;
The ev_timer watcher has timed out.&lt;br /&gt;
定时器watcher超时。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EV_PERIODIC&lt;br /&gt;
The ev_periodic watcher has timed out.&lt;br /&gt;
ev_periodic watcher超时。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EV_SIGNAL&lt;br /&gt;
The signal specified in the ev_signal watcher has been received by a thread.&lt;br /&gt;
线程收到一个由ev_signal watcher指定的信号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EV_CHILD&lt;br /&gt;
The pid specified in the ev_child watcher has received a status change.&lt;br /&gt;
接收到由ev_child watcher指定的pid的进程状态的改变。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EV_STAT&lt;br /&gt;
The path specified in the ev_stat watcher changed its attributes somehow.&lt;br /&gt;
接收到由ev_stat watcher监视的path的属性被改变&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EV_IDLE&lt;br /&gt;
The ev_idle watcher has determined that you have nothing better to do.&lt;br /&gt;
ev_ide watcher确定你已经没有什么更好的事情可以做。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;EV_PREPARE&lt;/li&gt;
  &lt;li&gt;EV_CHECK&lt;br /&gt;
All ev_prepare watchers are invoked just before ev_run starts to gather new events, and all ev_check watchers are queued (not invoked) just after ev_run has gathered them, but before it queues any callbacks for any received events. That means ev_prepare watchers are the last watchers invoked before the event loop sleeps or polls for new events, and ev_check watchers will be invoked before any other watchers of the same or lower priority within an event loop iteration.&lt;br /&gt;
所有的ev_prepare watcher将会在ev_run开始收集新事件之前被调用，所有的ev_check watchers被在ev_run收集到新事件之后排队（不调用），但是在它之前，排列任意已经接收到的事件的任何回调。这意味着ev_prepare watcher是event loop休眠或者循环监视新事件之前的最后一个watcher调用，ev_check watcher将在相同或较低优先级的事件循环迭代内的任何其他watcher之前被调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Callbacks of both watcher types can start and stop as many watchers as they want, and all of them will be taken into account (for example, a ev_prepare watcher might start an idle watcher to keep ev_run from blocking).&lt;br /&gt;
两个watcher类型的回调函数都可以启动和停止他们想要的watchers，所有的watcher都将被考虑在内（例如，一个ev_prepare watcher可以启动一个idle watcher来保持ev_run阻塞）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;EV_EMBED&lt;br /&gt;
The embedded event loop specified in the ev_embed watcher needs attention.&lt;br /&gt;
在ev_embed watcher中指定植入的event loop需要注意的时候。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EV_FORK&lt;br /&gt;
The event loop has been resumed in the child process after fork (see ev_fork).&lt;br /&gt;
在fork之后的子进程中，event loop被恢复（具体查看ev_fork）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EV_CLEANUP&lt;br /&gt;
The event loop is about to be destroyed (see ev_cleanup).&lt;br /&gt;
event loop将会被释放（具体查看ev_cleanup）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EV_ASYNC&lt;br /&gt;
The given async watcher has been asynchronously notified (see ev_async).&lt;br /&gt;
给定的异步wacther已经被异步的通知（具体查看ev_async）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EV_CUSTOM&lt;br /&gt;
Not ever sent (or otherwise used) by libev itself, but can be freely used by libev users to signal watchers (e.g. via ev_feed_event).&lt;br /&gt;
libev自己没有发送过（或者说使用过），但是可以自由的用于libev的信号watcher（例如，通过ev_feed_event）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EV_ERROR&lt;br /&gt;
An unspecified error has occurred, the watcher has been stopped. This might happen because the watcher could not be properly started because libev ran out of memory, a file descriptor was found to be closed or any other problem. Libev considers these application bugs.&lt;br /&gt;
一个未指定的错误已经发生，watcher已经被停止。这个可能发生了：watcher不能正常的启动，libev耗尽内存，一个文件描述符被发现已经关闭，或者是另外的一些问题。libev认为这些是应用程序级别的bugs。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You best act on it by reporting the problem and somehow coping with the watcher being stopped. Note that well-written programs should not receive an error ever, so when your watcher receives it, this usually indicates a bug in your program.&lt;br /&gt;
这种问题你最好的处理艺术是报告这些问题，并且想办法应对这些watcher将要停止。注意：良好的程序是不会不断的收到错误的，所以，当你的watcher接受到这些错误的时候，经常表明在你的程序中有bug。&lt;/p&gt;

&lt;p&gt;Libev will usually signal a few “dummy” events together with an error, for example it might indicate that a fd is readable or writable, and if your callbacks is well-written it can just attempt the operation and cope with the error from read() or write(). This will not work in multi-threaded programs, though, as the fd could already be closed and reused for another thing, so beware.&lt;br /&gt;
libev经常会和一些错误一起标记一些假的事件。例如，libev可能会表明一个fd已经可读或者可写了，如果你的程序写的很好，回调会只是尝试去操作，并且可以应对来自read或者write的错误。这在多线程程序中将不会正常运行，不过，鉴于这个fd已经被关闭，可以给另外一些事件重复使用，所以要小心。&lt;/p&gt;

&lt;h3 id=&quot;generic-watcher-functions-watcher的通用函数&quot;&gt;GENERIC WATCHER FUNCTIONS watcher的通用函数&lt;/h3&gt;

&lt;h4 id=&quot;ev_init-ev_type-watcher-callback&quot;&gt;ev_init (ev_TYPE *watcher, callback)&lt;/h4&gt;
&lt;p&gt;This macro initialises the generic portion of a watcher. The contents of the watcher object can be arbitrary (so malloc will do). Only the generic parts of the watcher are initialised, you need to call the type-specific ev_TYPE_set macro afterwards to initialise the type-specific parts. For each type there is also a ev_TYPE_init macro which rolls both calls into one.&lt;br /&gt;
这个宏将初始化watcher的通用部分。watcher对象的内容可以是任意的（所以可以使用malloc）。只有watcher的通用部分被初始化，然后你要调用指定类型的ev_TYPE_set宏来初始化特定的部分。每一个类型都有一个ev_TYPE_init宏，它可以一次调用ev_TYPE_init和ev_TYPE_set两个宏。&lt;/p&gt;

&lt;p&gt;You can reinitialise a watcher at any time as long as it has been stopped (or never started) and there are no pending events outstanding.&lt;br /&gt;
只要watcher已经停止（或者从来没有启动），也没有未处理的事件，你可以在任何时候重新初始化watcher。&lt;/p&gt;

&lt;p&gt;The callback is always of type void (&lt;em&gt;)(struct ev_loop *loop, ev_TYPE *watcher, int revents).&lt;br /&gt;
watcher的回调函数一直被定义成 void (&lt;/em&gt;)(struct ev_loop *loop, ev_TYPE *watcher, int revents).。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Example: Initialise an ev_io watcher in two steps.
示例：两部初始化一个ev_iowatcher

ev_io w;
ev_init (&amp;amp;w, my_cb);
ev_io_set (&amp;amp;w, STDIN_FILENO, EV_READ);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;ev_type_set-ev_type-watcher-args&quot;&gt;ev_TYPE_set (ev_TYPE *watcher, [args])&lt;/h4&gt;
&lt;p&gt;This macro initialises the type-specific parts of a watcher. You need to call ev_init at least once before you call this macro, but you can call ev_TYPE_set any number of times. You must not, however, call this macro on a watcher that is active (it can be pending, however, which is a difference to the ev_init macro).&lt;br /&gt;
这个宏初始化watcher的特定部分。你在调用此宏之前必须要先至少调用一次ev_init，当然你也可以多次调用此宏。但是，你不能在这个watcher活跃的时候调用此宏（但是它可以是挂起的，这是和ev_init不一样的地方）。&lt;/p&gt;

&lt;p&gt;Although some watcher types do not have type-specific arguments (e.g. ev_prepare) you still need to call its set macro.&lt;br /&gt;
尽管某些watcher类型没有特定的参数（比如ev_prepare），但是你仍然需要调用这个宏。&lt;/p&gt;

&lt;p&gt;See ev_init, above, for an example.&lt;br /&gt;
示例请查看上面的ev_init部分。&lt;/p&gt;

&lt;h4 id=&quot;ev_type_init-ev_type-watcher-callback-args&quot;&gt;ev_TYPE_init (ev_TYPE *watcher, callback, [args])&lt;/h4&gt;
&lt;p&gt;This convenience macro rolls both ev_init and ev_TYPE_set macro calls into a single call. This is the most convenient method to initialise a watcher. The same limitations apply, of course.&lt;br /&gt;
这是一个宏调用包括了ev_init和ev_TYPE_set的简便方法。这也是大多数程序中经常使用的方法。当然，限制是一样的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Example: Initialise and set an ev_io watcher in one step.
示例：一步初始化并且设置一个ev_io watcher。

ev_io_init (&amp;amp;w, my_cb, STDIN_FILENO, EV_READ);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;ev_type_start-loop-ev_type-watcher&quot;&gt;ev_TYPE_start (loop, ev_TYPE *watcher)&lt;/h4&gt;
&lt;p&gt;Starts (activates) the given watcher. Only active watchers will receive events. If the watcher is already active nothing will happen.&lt;br /&gt;
启动（或者激活）给定的watcher。只有活跃的watchers将会接收到事件。如果watcher已经是活跃的，那么什么都不会发生。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Example: Start the ev_io watcher that is being abused as example in this whole section.
示例：启动一个ev_io watcher。这是已经在整个章节中被用烂的例子。

ev_io_start (EV_DEFAULT_UC, &amp;amp;w);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;ev_type_stop-loop-ev_type-watcher&quot;&gt;ev_TYPE_stop (loop, ev_TYPE *watcher)&lt;/h4&gt;
&lt;p&gt;Stops the given watcher if active, and clears the pending status (whether the watcher was active or not).&lt;br /&gt;
如果给定的watcher是活跃的，那么停止这个watcher。并且清除挂起状态（这个watcher是否是活跃的？）。&lt;/p&gt;

&lt;p&gt;It is possible that stopped watchers are pending - for example, non-repeating timers are being stopped when they become pending - but calling ev_TYPE_stop ensures that the watcher is neither active nor pending. If you want to free or reuse the memory used by the watcher it is therefore a good idea to always call its ev_TYPE_stop function.&lt;br /&gt;
停止一个行将发生的watchers将会有问题。例如，一个不重复的定时器在行将发生时将会停止，但是调用ev_TYPE_stop将确保watcher不会存活，也不会挂起。如果你想释放或者重用这个watcher的内存，那么调用ev_TYPE_stop将是一个好主意。&lt;/p&gt;

&lt;h4 id=&quot;bool-ev_is_active-ev_type-watcher&quot;&gt;bool ev_is_active (ev_TYPE *watcher)&lt;/h4&gt;
&lt;p&gt;Returns a true value iff the watcher is active (i.e. it has been started and not yet been stopped). As long as a watcher is active you must not modify it.&lt;br /&gt;
如果返回true，那么表示watcher还是活跃的状态（例如：watcher已经被激活并且也没有被停止）。只要watcher还处于活跃状态，那么你就不能修改它。&lt;/p&gt;

&lt;h4 id=&quot;bool-ev_is_pending-ev_type-watcher&quot;&gt;bool ev_is_pending (ev_TYPE *watcher)&lt;/h4&gt;
&lt;p&gt;Returns a true value iff the watcher is pending, (i.e. it has outstanding events but its callback has not yet been invoked). As long as a watcher is pending (but not active) you must not call an init function on it (but ev_TYPE_set is safe), you must not change its priority, and you must make sure the watcher is available to libev (e.g. you cannot free () it).&lt;br /&gt;
如果返回true，那么表示watcher处于挂起状态（例如：watcher已经有事件发生，但是还没有调用事件的回调函数进行处理）。只要watcher处于挂起状态（但是不是活跃状态），你就不能调用它的init函数（但是ev_TYPE_set是安全的），你不能改变它的优先级，并且你必须保证对于libev来说，watcher是可用的（例如：你不能调用free释放这个watcher）。&lt;/p&gt;

&lt;h4 id=&quot;callback-ev_cb-ev_type-watcher&quot;&gt;callback ev_cb (ev_TYPE *watcher)&lt;/h4&gt;
&lt;p&gt;Returns the callback currently set on the watcher.&lt;br /&gt;
返回指定watcher设置的当前回调。&lt;/p&gt;

&lt;h4 id=&quot;ev_set_cb-ev_type-watcher-callback&quot;&gt;ev_set_cb (ev_TYPE *watcher, callback)&lt;/h4&gt;
&lt;p&gt;Change the callback. You can change the callback at virtually any time (modulo threads).&lt;br /&gt;
更改回调。你可以在任何时候无形中更改回调（modulo threads？？怎么翻译）&lt;/p&gt;

&lt;h4 id=&quot;ev_set_priority-ev_type-watcher-int-priority&quot;&gt;ev_set_priority (ev_TYPE *watcher, int priority)&lt;/h4&gt;
&lt;h4 id=&quot;int-ev_priority-ev_type-watcher&quot;&gt;int ev_priority (ev_TYPE *watcher)&lt;/h4&gt;
&lt;p&gt;Set and query the priority of the watcher. The priority is a small integer between EV_MAXPRI (default: 2) and EV_MINPRI (default: -2). Pending watchers with higher priority will be invoked before watchers with lower priority, but priority will not keep watchers from being executed (except for ev_idle watchers).&lt;br /&gt;
设置或者查询watcher的优先级。这个优先级是一个在EV_MAXPRI（默认是2）和EV_MINPRI（默认是-2）之间的很小的整数。挂起的高优先级watchers将会比低优先级的watchers先调用。但是优先级不能阻止watcher被执行（除了ev_idle watcher）。&lt;/p&gt;

&lt;p&gt;If you need to suppress invocation when higher priority events are pending you need to look at ev_idle watchers, which provide this functionality.&lt;br /&gt;
如果你想在高优先级事件即将发生的时候抑制这个调用，你需要看一下ev_idle watcher，ev_idle watcher提供了这个功能。&lt;/p&gt;

&lt;p&gt;You must not change the priority of a watcher as long as it is active or pending.&lt;br /&gt;
只要watcher是活跃的或者挂起的，你就不能更改这个watcher的优先级。&lt;/p&gt;

&lt;p&gt;Setting a priority outside the range of EV_MINPRI to EV_MAXPRI is fine, as long as you do not mind that the priority value you query might or might not have been clamped to the valid range.&lt;br /&gt;
只要你不介意你查询的优先级不在有效的范围内，你把优先级设置到EV_MINPRI和EV_MAXPRI之外没有关系。&lt;/p&gt;

&lt;p&gt;The default priority used by watchers when no priority has been set is always 0, which is supposed to not be too high and not be too low :).&lt;br /&gt;
当没有设置watcher的优先级的时候，默认的值一直是0.这个值不高也不低。&lt;/p&gt;

&lt;p&gt;See WATCHER PRIORITY MODELS, below, for a more thorough treatment of priorities.&lt;br /&gt;
查看watcher的优先级模型，下面会有更详细的讲解。&lt;/p&gt;

&lt;h4 id=&quot;ev_invoke-loop-ev_type-watcher-int-revents&quot;&gt;ev_invoke (loop, ev_TYPE *watcher, int revents)&lt;/h4&gt;
&lt;p&gt;Invoke the watcher with the given loop and revents. Neither loop nor revents need to be valid as long as the watcher callback can deal with that fact, as both are simply passed through to the callback.&lt;br /&gt;
通过给定的loop和事件标志位来调用watcher。只要watcher的回调可以处理，既不需要循环也不需要事件有效发生。因为两者都是简单的调用回调而已。&lt;/p&gt;

&lt;h4 id=&quot;int-ev_clear_pending-loop-ev_type-watcher&quot;&gt;int ev_clear_pending (loop, ev_TYPE *watcher)&lt;/h4&gt;
&lt;p&gt;If the watcher is pending, this function clears its pending status and returns its revents bitset (as if its callback was invoked). If the watcher isn’t pending it does nothing and returns 0. &lt;br /&gt;
如果watcher是被挂起的，这个函数将会清空watcher的挂起状态，并且返回它的事件集标志位（就好像它的回调已经被调用过一样）。如果watcher不是被挂起的，那么此函数将什么都不做，并且返回0.&lt;/p&gt;

&lt;p&gt;Sometimes it can be useful to “poll” a watcher instead of waiting for its callback to be invoked, which can be accomplished with this function. &lt;br /&gt;
有的时候，循环一个watcher而不是等待watcher调用它的回调是有用的，这个函数就完成了这个功能。&lt;/p&gt;

&lt;h4 id=&quot;ev_feed_event-loop-ev_type-watcher-int-revents&quot;&gt;ev_feed_event (loop, ev_TYPE *watcher, int revents)&lt;/h4&gt;
&lt;p&gt;Feeds the given event set into the event loop, as if the specified event had happened for the specified watcher (which must be a pointer to an initialised but not necessarily started event watcher). Obviously you must not free the watcher as long as it has pending events.&lt;br /&gt;
订阅设置到event loop的给定的事件，好像对于执行watcher来说指定的事件已经发生了（watcher必须是一个已经初始化但是不一定已经启动的watcher指针）。显然，只要watcher还有未处理的事件，你就不能释放这个watcher指针。&lt;/p&gt;

&lt;p&gt;Stopping the watcher, letting libev invoke it, or calling ev_clear_pending will clear the pending event, even if the watcher was not started in the first place.&lt;br /&gt;
虽然没有第一时间启动watcher，但是停止watcher，让libev调用它，或者调用ev_clear_pending来清理未触发的事件。&lt;/p&gt;

&lt;p&gt;See also ev_feed_fd_event and ev_feed_signal_event for related functions that do not need a watcher.&lt;br /&gt;
另请参阅ev_feed_fd_event和ev_feed_signal_event的相关功能，它们不需要watcher参数。&lt;/p&gt;

&lt;p&gt;See also the ASSOCIATING CUSTOM DATA WITH A WATCHER and BUILDING YOUR OWN COMPOSITE WATCHERS idioms.&lt;br /&gt;
另请参阅ASSOCIATING CUSTOM DATA WITH A WATCHER（watcher关联自定义数据）和BUILDING YOUR OWN COMPOSITE WATCHERS （构建你自己的watcher）部分。&lt;/p&gt;

&lt;h3 id=&quot;watcher-states-watcher-状态&quot;&gt;WATCHER STATES watcher 状态&lt;/h3&gt;

&lt;p&gt;There are various watcher states mentioned throughout this manual - active, pending and so on. In this section these states and the rules to transition between them will be described in more detail - and while these rules might look complicated, they usually do “the right thing”.&lt;br /&gt;
这本手册中提到watcher的各种状态-活跃，挂起等等。在这节中，将更详细的面熟这些状态和转换规则，虽然这些规则看起来很复杂，但是它们通常会做正确的事情。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;initialised 已经初始化&lt;br /&gt;
Before a watcher can be registered with the event loop it has to be initialised. This can be done with a call to ev_TYPE_init, or calls to ev_init followed by the watcher-specific ev_TYPE_set function.&lt;br /&gt;
在watcher可以在event loop中注册之前，它必须被初始化。它可以使用调用ev_TYPE_init初始化，或者调用ev_init，接着调用watcher具体类型的ev_TYPE_set函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this state it is simply some block of memory that is suitable for use in an event loop. It can be moved around, freed, reused etc. at will - as long as you either keep the memory contents intact, or call ev_TYPE_init again.&lt;br /&gt;
在这种状态下，watcher只是一块可以在event loop中使用的简单的内存块。它可以根据你的意愿任意的移动，释放或者再利用等等。只要保证内存中的内容不变或者再次调用ev_TYPE_init。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;started/running/active 开始/运行/活跃&lt;br /&gt;
Once a watcher has been started with a call to ev_TYPE_start it becomes property of the event loop, and is actively waiting for events. While in this state it cannot be accessed (except in a few documented ways), moved, freed or anything else - the only legal thing is to keep a pointer to it, and call libev functions on it that are documented to work on active watchers.&lt;br /&gt;
一旦watcher使用ev_TYPE_start启动，event loop将接管它的所有权，并且将积极的等待事件。虽然在这种状态下它不能被访问（除了几个有据可查的方法外 PS：其实就是libev有几个允许访问的方法可以访问在这个状态下的watcher），移动，释放或者任何事情。唯一合法的事情就是保持一个指向它的指针，或者使用libev允许的方法来访问它。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pending 挂起（未处理）&lt;br /&gt;
If a watcher is active and libev determines that an event it is interested in has occurred (such as a timer expiring), it will become pending. It will stay in this pending state until either it is stopped or its callback is about to be invoked, so it is not normally pending inside the watcher callback.&lt;br /&gt;
如果watcher是活跃的，并且libev确定这个watcher的事件已经发生（例如定时器即将到期），那么watcher将变成挂起的（或者说是未处理的）。它将一直保持挂起状态，直到wacther被停止或者它的回调函数被调用，所以它一般不会在watcher的callback中被正常的挂起。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The watcher might or might not be active while it is pending (for example, an expired non-repeating timer can be pending but no longer active). If it is stopped, it can be freely accessed (e.g. by calling ev_TYPE_set), but it is still property of the event loop at this time, so cannot be moved, freed or reused. And if it is active the rules described in the previous item still apply.&lt;br /&gt;
当wacterh是挂起状态的时候，它是不是被激活都是有可能发生的（例如，过期并且非重复的计时器将会被挂起，但是不再是活跃的）。如果它已经被停止，那么它可以被随意的访问（例如调用ev_TYPE_set），但是这个时候，event loop仍然有这个wacther的所有权，所以不能被移动，释放，或者重用。如果这个watcher是活跃的，那么这个规则对于前一个项仍然适用。（PS：这里的item是指啥玩意？）&lt;/p&gt;

&lt;p&gt;It is also possible to feed an event on a watcher that is not active (e.g. via ev_feed_event), in which case it becomes pending without being active.&lt;br /&gt;
也可以把一个事件强行提供给一个不是活跃状态的watcher（例如通过ev_feed_event），这种情况下，watcher将会在没有经过活跃状态的情况下直接到挂起状态。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;stopped&lt;br /&gt;
A watcher can be stopped implicitly by libev (in which case it might still be pending), or explicitly by calling its ev_TYPE_stop function. The latter will clear any pending state the watcher might be in, regardless of whether it was active or not, so stopping a watcher explicitly before freeing it is often a good idea.&lt;br /&gt;
watcher可以通过libev隐式的停止（这种情况下，watcher可能仍然是挂起状态），或者通过调用ev_TYPE_stop函数显式的停止。后者将会清除watcher可能存在的挂起状态，无论他是活跃的还是不活跃的，所以在释放它之前先显式的停止它一般来说都是一个好主意。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While stopped (and not pending) the watcher is essentially in the initialised state, that is, it can be reused, moved, modified in any way you wish (but when you trash the memory block, you need to ev_TYPE_init it again).&lt;br /&gt;
在停止并且非挂起状态下，watcher基本上就是在初始化状态，也就是说，它可以按照你的想法重用，移动，更改（但是如果你释放掉这个内存块，你需要再次使用ev_TYPE_init）。&lt;/p&gt;

&lt;h3 id=&quot;watcher-priority-models-watcher的优先级模型&quot;&gt;WATCHER PRIORITY MODELS watcher的优先级模型&lt;/h3&gt;

&lt;p&gt;Many event loops support watcher priorities, which are usually small integers that influence the ordering of event callback invocation between watchers in some way, all else being equal.&lt;br /&gt;
很多事件循环框架支持watcher的优先级，它通常是一个影响同等条件的watcher的回调函数顺序的小整数。&lt;/p&gt;

&lt;p&gt;In libev, Watcher priorities can be set using ev_set_priority. See its description for the more technical details such as the actual priority range.&lt;br /&gt;
在libev中，watcher的优先级可以通过使用ev_set_priority设置。更多的细节请参阅其函数说明，例如：实际优先级值的范围&lt;/p&gt;

&lt;p&gt;There are two common ways how these these priorities are being interpreted by event loops:&lt;br /&gt;
event loops通常有两种方法来实现优先级：&lt;/p&gt;

&lt;p&gt;In the more common lock-out model, higher priorities “lock out” invocation of lower priority watchers, which means as long as higher priority watchers receive events, lower priority watchers are not being invoked.&lt;br /&gt;
在常见的锁定模式中，高优先级的watcher”锁定“低优先级watchers的调用，这意味着只要高优先级的watchers接收到事件，那么低优先级的watchers将不会被调用。&lt;/p&gt;

&lt;p&gt;The less common only-for-ordering model uses priorities solely to order callback invocation within a single event loop iteration: Higher priority watchers are invoked before lower priority ones, but they all get invoked before polling for new events.&lt;br /&gt;
不太常见是只做序模型，在一个单一的event loop循环内部，使用优先级作为唯一的排序依据，来回调watcher的调用：高优先级的watchers会在低优先级前面调用，但是它们都会在再次循环触发事件之前调用。&lt;/p&gt;

&lt;p&gt;Libev uses the second (only-for-ordering) model for all its watchers except for idle watchers (which use the lock-out model).&lt;br /&gt;
libev使用第二种模型（只排序），除了idle watcher（它使用第一种锁定模型）。&lt;/p&gt;

&lt;p&gt;The rationale behind this is that implementing the lock-out model for watchers is not well supported by most kernel interfaces, and most event libraries will just poll for the same events again and again as long as their callbacks have not been executed, which is very inefficient in the common case of one high-priority watcher locking out a mass of lower priority ones.&lt;br /&gt;
这样做的理由是，执行锁定模型，watcher不能很好的被大多数内核接口支持，并且只要它们的回调没有被执行，大多数的事件库只是一次又一次循环的触发相同的事件，在通常情况下，一个高优先级watcher锁定了大量低优先级的watcher，这效率是非常低下的。&lt;/p&gt;

&lt;p&gt;Static (ordering) priorities are most useful when you have two or more watchers handling the same resource: a typical usage example is having an ev_io watcher to receive data, and an associated ev_timer to handle timeouts. Under load, data might be received while the program handles other jobs, but since timers normally get invoked first, the timeout handler will be executed before checking for data. In that case, giving the timer a lower priority than the I/O watcher ensures that I/O will be handled first even under adverse conditions (which is usually, but not always, what you want).&lt;br /&gt;
当你有两个或者多个watchers正要处理相同资源的时候，静态（排序）优先级是非常有用的：一个典型的例子就是有一个ev_io watcher接收数据，并且一个相关的ev_timer处理超时。在负债下，数据可能会在处理其他任务的时候被接收，但是由于定时器通常先被调用，超时处理程序将在验证数据之前被调用。在这种情况下，给定时器一个比io watcher低的优先级来确保io即使在不利的情况下也会被先调用（这种就是通常的解决方案，当并非总是如此。PS：what you want？怎么翻译？作者的挑衅？）。&lt;/p&gt;

&lt;p&gt;Since idle watchers use the “lock-out” model, meaning that idle watchers will only be executed when no same or higher priority watchers have received events, they can be used to implement the “lock-out” model when required.&lt;br /&gt;
由于idle watchers使用”锁定“模型，这意味着idle watcher只有在没有相同或者更高的watcher接收到事件时才会被执行，当需要的时候，他们可以被用来实现”锁定“模型。&lt;/p&gt;

&lt;p&gt;For example, to emulate how many other event libraries handle priorities, you can associate an ev_idle watcher to each such watcher, and in the normal watcher callback, you just start the idle watcher. The real processing is done in the idle watcher callback. This causes libev to continuously poll and process kernel event data for the watcher, but when the lock-out case is known to be rare (which in turn is rare :), this is workable.&lt;br /&gt;
举个例子，仿效其他很多事件库处理优先级，你可以给每一个watcher关联一个ev_idle，并且在正常的watcher回调中，你只是启动这个idle watcher。真正的处理过程实在idle watcher的回调中调用的。这将导致libev死循环和不断的处理watcher的内核事件，但是在锁定情况下将会是很罕见的（这又是难得的），所以这是可行的。&lt;/p&gt;

&lt;p&gt;Usually, however, the lock-out model implemented that way will perform miserably under the type of load it was designed to handle. In that case, it might be preferable to stop the real watcher before starting the idle watcher, so the kernel will not have to process the event in case the actual processing will be delayed for considerable time.&lt;br /&gt;
然后，通常情况下，lock-out模型在负载类型下被设计来处理实现这种方法将会是非常糟糕的。在这种情况下，它可能最好在启动idle watcher之前先停止真实的watcher，所以在内核将不必处理这个事件的情况下，真实的处理过程将会被延迟很长时间。&lt;/p&gt;

&lt;p&gt;Here is an example of an I/O watcher that should run at a strictly lower priority than the default, and which should only process data when no other events are pending:&lt;br /&gt;
这是一个io watcher运行在比默认还低的优先级，但没有任何事件被挂起并且只能处理数据的例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ev_idle idle; // actual processing watcher
ev_io io;     // actual event watcher

static void
io_cb (EV_P_ ev_io *w, int revents)
{
    // stop the I/O watcher, we received the event, but
    // are not yet ready to handle it.
    //停止io watcher，我们接收这个事件，但是不准备处理它
    ev_io_stop (EV_A_ w);

    // start the idle watcher to handle the actual event.
    // it will not be executed as long as other watchers
    // with the default priority are receiving events.
    //开始idle watcher来处理真实的事件
    //只要另外默认优先级的watchers这在接收事件，那么将不会被执行。
    ev_idle_start (EV_A_ &amp;amp;idle);
}

static void
idle_cb (EV_P_ ev_idle *w, int revents)
{
    // actual processing
    //真实的处理过程
    read (STDIN_FILENO, ...);

    // have to start the I/O watcher again, as
    // we have handled the event
    //必须重启io watcher，因为我们可以处理这个事件
    ev_io_start (EV_P_ &amp;amp;io);
}

// initialisation
ev_idle_init (&amp;amp;idle, idle_cb);
ev_io_init (&amp;amp;io, io_cb, STDIN_FILENO, EV_READ);
ev_io_start (EV_DEFAULT_ &amp;amp;io);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In the “real” world, it might also be beneficial to start a timer, so that low-priority connections can not be locked out forever under load. This enables your program to keep a lower latency for important connections during short periods of high load, while not completely locking out less important ones.&lt;br /&gt;
在”真实“的项目中（就是在真实的项目中），启动一个定时器是有必要的，这样低优先级的连接在高负载下就不会永远被锁了。这意味着你的程序对于在短期高负载下重要的连接保持一个低延迟，而不是完全锁定那些没那么重要的连接。（也就是说先处理高优先级的，再处理低优先级的，不会只处理高优先级的）。&lt;/p&gt;

&lt;h3 id=&quot;watcher-types&quot;&gt;WATCHER TYPES&lt;/h3&gt;

&lt;p&gt;This section describes each watcher in detail, but will not repeat information given in the last section. Any initialisation/set macros, functions and members specific to the watcher type are explained.&lt;br /&gt;
本节介绍每一种watcher的细节，但是在最后一节我们不会给出重复的信息。任何初始化/set宏，函数和每种watcher特有的属性成员都会被介绍。&lt;/p&gt;

&lt;p&gt;Members are additionally marked with either [read-only], meaning that, while the watcher is active, you can look at the member and expect some sensible content, but you must not modify it (you can modify it while the watcher is stopped to your hearts content), or [read-write], which means you can expect it to have some sensible content while the watcher is active, but you can also modify it. Modifying it may not do something sensible or take immediate effect (or do anything at all), but libev will not crash or malfunction in any way.&lt;br /&gt;
加之属性成员又被标记为只读，这意味着，当watcher是活跃的时候，你可以查看一下属性成员并且得到一些明智的内容，但是你不能更改它（当你觉得watcher被停止的时候你可以更改它。PS：是不是就是说当你觉得它不再被使用的时候，你可以更改只读属性？）；或者标记为读-写，这意味着你可以在watcher活跃的时候获得它的明智内容，但是你也可以更改它。更改读写成员，特需不会做一些明智的事情，或者不能即时生效（或者根本什么都没有做），但是libev也不会死机或者发生故障。&lt;/p&gt;

&lt;h4 id=&quot;ev_io---is-this-file-descriptor-readable-or-writable--ev_io-是不是文件描述符可读或者可写事件&quot;&gt;ev_io - is this file descriptor readable or writable?  ev_IO-是不是文件描述符可读或者可写事件？&lt;/h4&gt;

&lt;p&gt;I/O watchers check whether a file descriptor is readable or writable in each iteration of the event loop, or, more precisely, when reading would not block the process and writing would at least be able to write some data. This behaviour is called level-triggering because you keep receiving events as long as the condition persists. Remember you can stop the watcher if you don’t want to act on the event and neither want to receive future events.&lt;br /&gt;
IO watchers在event loop每次迭代的时候检查文件描述符是可读还是可写的，或者更正确的说，当读不阻塞进程和写至少能写一点数据的时候。这种行为被成为水平触发，因为你只要条件允许，就保持接受事件。记住，如果你不想对事件采取行动也不想将来接受事件，你可以停止watcher。&lt;/p&gt;

&lt;p&gt;In general you can register as many read and/or write event watchers per fd as you want (as long as you don’t confuse yourself). Setting all file descriptors to non-blocking mode is also usually a good idea (but not required if you know what you are doing).&lt;br /&gt;
一般来说，每一个文件描述符你都可以注册你想注册的那些读和/或者写事件（只要你自己不要搞混）。将所有的文件描述符设置成”非阻塞“的模式也经常是一个好主意。&lt;/p&gt;

&lt;p&gt;Another thing you have to watch out for is that it is quite easy to receive “spurious” readiness notifications, that is, your callback might be called with EV_READ but a subsequent read(2) will actually block because there is no data. It is very easy to get into this situation even with a relatively standard program structure. Thus it is best to always use non-blocking I/O: An extra read(2) returning EAGAIN is far preferable to a program hanging until some data arrives.&lt;br /&gt;
另一个你需要注意的是，它很容易会收到“虚假”的准备就绪通知，也就是说，你的回调函数将会被按照EV_READ方式调用，但是随后read(2)调用将会被阻塞，因为根本就没有数据。即使程序结构很标准，这种状况也很容易发生。所以，最好的办法是使用非阻塞的IO：一个特别的read(2)返回EAGAIN相比阻塞进程到数据达到会更好。&lt;/p&gt;

&lt;p&gt;If you cannot run the fd in non-blocking mode (for example you should not play around with an Xlib connection), then you have to separately re-test whether a file descriptor is really ready with a known-to-be good interface such as poll (fortunately in the case of Xlib, it already does this on its own, so its quite safe to use). Some people additionally use SIGALRM and an interval timer, just to be sure you won’t block indefinitely.&lt;br /&gt;
如果你将文件描述符设置成非阻塞模式（例如你不应该玩Xlib的连接 PS：Xlib的链接有什么特别吗？对Xlib不熟悉），那么你必须单独的重新测试文件描述符是否已经准备好将要良好的界面，例如poll（幸运的是，Xlib在这种情况下，他已经自己这样做了，所以可以安全的使用）。有一些人还用SIGALRM和定时器，只是要确定你将不会无限期的阻塞进程。&lt;/p&gt;

&lt;p&gt;But really, best use non-blocking mode.&lt;br /&gt;
不过说真的，最好的办法还是使用非阻塞模式。&lt;/p&gt;

&lt;p&gt;The special problem of disappearing file descriptors&lt;br /&gt;
不存在的文件描述符的特殊问题&lt;/p&gt;

&lt;p&gt;Some backends (e.g. kqueue, epoll) need to be told about closing a file descriptor (either due to calling close explicitly or any other means, such as dup2). The reason is that you register interest in some file descriptor, but when it goes away, the operating system will silently drop this interest. If another file descriptor with the same number then is registered with libev, there is no efficient way to see that this is, in fact, a different file descriptor.&lt;br /&gt;
有一些后台（例如kqueue，epoll）需要被告知关闭文件描述符（不是由于显式的调用关闭就是任何其他手段，例如dup2）。这个原因是你注册的事件对一些文件描述符感兴趣，但是当这些文件描述符消失的时候，操作系统将默默的删除这些兴趣，如果另外一个文件描述符使用同样的文件描述符值在libev中注册，那么libev将没有有效的方法来区分实际上这是一个不同的文件描述符。&lt;/p&gt;

&lt;p&gt;To avoid having to explicitly tell libev about such cases, libev follows the following policy: Each time ev_io_set is being called, libev will assume that this is potentially a new file descriptor, otherwise it is assumed that the file descriptor stays the same. That means that you have to call ev_io_set (or ev_io_init) when you change the descriptor even if the file descriptor number itself did not change.&lt;br /&gt;
为了避免不得不明确的告诉libev这种情况，libev遵循以下原则：每次ev_io_set被调用，libev都假定这可能是一个新的文件描述符，否则假定文件描述符保持不变。这意味着即使文件描述符值它自己都没有改变，当你需要改变文件描述符的时候你不得不调用ev_io_set（或者是ev_io_init）。&lt;/p&gt;

&lt;p&gt;This is how one would do it normally anyway, the important point is that the libev application should not optimise around libev but should leave optimisations to libev.&lt;br /&gt;
这通常究竟是怎么做的，重要的一点是libev应用程序不应该到处优化libev，但是应该交给libev优化。&lt;/p&gt;

&lt;p&gt;The special problem of dup’ed file descriptors&lt;br /&gt;
dup文件描述符的问题&lt;/p&gt;

&lt;p&gt;Some backends (e.g. epoll), cannot register events for file descriptors, but only events for the underlying file descriptions. That means when you have dup ()’ed file descriptors or weirder constellations, and register events for them, only one file descriptor might actually receive events.&lt;br /&gt;
一些后台（例如epoll），仅对潜在的文件描述符事件，不能为这些文件描述符注册事件。这意味着当你用dup（）或者更怪异的方法生成的文件描述符，为他们注册事件，只有一个文件描述符事实上接收到事件。&lt;/p&gt;

&lt;p&gt;There is no workaround possible except not registering events for potentially dup ()’ed file descriptors, or to resort to EVBACKEND_SELECT or EVBACKEND_POLL.&lt;br /&gt;
目前没有解决方法把可能是dup生成的文件描述符排除在注册事件之外（PS：其实就是还没有办法限制dup生成的文件描述符注册到libev），或者求助于EVBACKEND_SELECT或EVBACKEND_POLL&lt;/p&gt;

&lt;p&gt;The special problem of files&lt;br /&gt;
文件的特殊问题&lt;/p&gt;

&lt;p&gt;Many people try to use select (or libev) on file descriptors representing files, and expect it to become ready when their program doesn’t block on disk accesses (which can take a long time on their own).&lt;br /&gt;
很多人都试着在文件描述符上用select（或者libev）来表现文件，并且在磁盘访问时，希望他们的程序变成就绪状态、不阻塞。&lt;/p&gt;

&lt;p&gt;However, this cannot ever work in the “expected” way - you get a readiness notification as soon as the kernel knows whether and how much data is there, and in the case of open files, that’s always the case, so you always get a readiness notification instantly, and your read (or possibly write) will still block on the disk I/O.&lt;br /&gt;
然而，在某些时候它并不能按照希望的方式工作—只要内核知道这里是否有数据或者有多少数据，你就会得到一个准备就绪的通知，并且在打开文件的情况下，通常都会是这样的。所以你通常都会瞬间得到一个准备就绪的通知，并且你的读取（也有可能是写入）将仍然阻塞在磁盘IO上。&lt;/p&gt;

&lt;p&gt;Another way to view it is that in the case of sockets, pipes, character devices and so on, there is another party (the sender) that delivers data on its own, but in the case of files, there is no such thing: the disk will not send data on its own, simply because it doesn’t know what you wish to read - you would first have to request some data.&lt;br /&gt;
另外一种方法来看待这个事情是在sockets，pipes，字符驱动设备等等情况下，它自己可能是发送数据的另外一方，但是磁盘文件的情况下，并不存在这样的事情：磁盘它自己不会发送数据，只是因为它不知道你想读–你必须首先请求一些数据。&lt;/p&gt;

&lt;p&gt;Since files are typically not-so-well supported by advanced notification mechanism, libev tries hard to emulate POSIX behaviour with respect to files, even though you should not use it. The reason for this is convenience: sometimes you want to watch STDIN or STDOUT, which is usually a tty, often a pipe, but also sometimes files or special devices (for example, epoll on Linux works with /dev/random but not with /dev/urandom), and even though the file might better be served with asynchronous I/O instead of with non-blocking I/O, it is still useful when it “just works” instead of freezing.&lt;br /&gt;
因为文件通常都不是那么友好的支持先进的通报机制，所以libev试着力图模仿POSIX尊重文件的行为，尽管你可能不会用到它。模仿文件的原因就是因为方便：有些时候，你需要关注STDIN或者是STDOUT，它们通常是一个管道实现的tty设备，但是有些时候也是文件或者是特殊的驱动设备（例如，epoll在linux上靠/dev/random工作，但是不靠/dev/urandom），尽管文件使用异步IO替代非阻塞IO可能会被更好的送达，但是当它只要工作而不是冻结的时候，它仍然非常有用。&lt;/p&gt;

&lt;p&gt;So avoid file descriptors pointing to files when you know it (e.g. use libeio), but use them when it is convenient, e.g. for STDIN/STDOUT, or when you rarely read from a file instead of from a socket, and want to reuse the same code path.&lt;br /&gt;
所以当你知道它的时候（例如使用libeio），要尽量的避免文件描述符指向文件（这里的文件应该是指磁盘文件），但是使用它们的时候很方便，例如对于标准输入/输出，或当您从文件而不是从一个socket中很好的读，并且想重用同样的代码路径。&lt;/p&gt;

&lt;p&gt;The special problem of fork&lt;br /&gt;
fork的特殊问题&lt;/p&gt;

&lt;p&gt;Some backends (epoll, kqueue) do not support fork () at all or exhibit useless behaviour. Libev fully supports fork, but needs to be told about it in the child if you want to continue to use it in the child.&lt;br /&gt;
一些后台（epoll，kqueue）根本不提供fork或者表现出没用的行为。libev完全支持fork，但是需要在子进程被告知，如果你想在子进程中继续使用libev。&lt;/p&gt;

&lt;p&gt;To support fork in your child processes, you have to call ev_loop_fork () after a fork in the child, enable EVFLAG_FORKCHECK, or resort to EVBACKEND_SELECT or EVBACKEND_POLL.&lt;br /&gt;
为了在你的子进程中支持fork，你必须在调用fork之后的子进程中调用ev_loop_fork，开启EVFLAG_FORKCHECK或者依靠EVBACKEND_SELECT或者EVBACKEND_POLL.&lt;/p&gt;

&lt;p&gt;The special problem of SIGPIPE&lt;br /&gt;
SIGPIPE信号的特殊问题&lt;/p&gt;

&lt;p&gt;While not really specific to libev, it is easy to forget about SIGPIPE: when writing to a pipe whose other end has been closed, your program gets sent a SIGPIPE, which, by default, aborts your program. For most programs this is sensible behaviour, for daemons, this is usually undesirable.&lt;br /&gt;
虽然没有明确到libev，但是也容易忽略掉SIGPIPE：当你写入数据到一个另外一端已经被关闭的管道（pipe），你的程序将会发送一个SIGPIPE信号，默认情况下，会中止你程序。对于大多数程序来说这是一个明智的行为，但是对于守护进程，这通常是不可取的。&lt;/p&gt;

&lt;p&gt;So when you encounter spurious, unexplained daemon exits, make sure you ignore SIGPIPE (and maybe make sure you log the exit status of your daemon somewhere, as that would have given you a big clue).&lt;br /&gt;
所以当你遇到假的，不明原因的守护进程退出，请确认你忽略了SIGPIPE（可能需要确认你记录的守护进程的退出状态，因为这会给你一个很大的线索）。&lt;/p&gt;

&lt;p&gt;The special problem of accept()ing when you can’t&lt;br /&gt;
当不能accept时的特殊问题&lt;/p&gt;

&lt;p&gt;Many implementations of the POSIX accept function (for example, found in post-2004 Linux) have the peculiar behaviour of not removing a connection from the pending queue in all error cases.&lt;br /&gt;
很多的POSIX accept函数的实现具有怪异的行为，它不能在错误情况下从挂起的队列中删除一个连接。&lt;/p&gt;

&lt;p&gt;For example, larger servers often run out of file descriptors (because of resource limits), causing accept to fail with ENFILE but not rejecting the connection, leading to libev signalling readiness on the next iteration again (the connection still exists after all), and typically causing the program to loop at 100% CPU usage.&lt;br /&gt;
例如大型服务器通常会达到文件描述符的限制（因为有资源限制），导致了ENFILE，从而接受失败，但不拒绝连接，导致libev在写一次循环中再一次发送准备就绪的信号（毕竟连接仍然是存在的），并且通常导致程序在loop的时候CPU使用率100%。&lt;/p&gt;

&lt;p&gt;Unfortunately, the set of errors that cause this issue differs between operating systems, there is usually little the app can do to remedy the situation, and no known thread-safe method of removing the connection to cope with overload is known (to me).&lt;br /&gt;
不幸的是，在不同操作系统之间会造成不同的错误，通常有很少的应用程序可以做到亡羊补牢​​，并且也不知道去除连接，以应付超负荷运转的线程安全的函数 （对我来说）。&lt;/p&gt;

&lt;p&gt;One of the easiest ways to handle this situation is to just ignore it - when the program encounters an overload, it will just loop until the situation is over. While this is a form of busy waiting, no OS offers an event-based way to handle this situation, so it’s the best one can do.&lt;br /&gt;
处理这种问题的其中一种办法是忽略它–当程序遇到高负载的时候，继续loop程序，直到这种情况结束。虽然忙着等待只是一个形式，当没有一个OS提供一个基于事件的处理这种情况的方法，所以，这是能做的方法中最好的一个了。&lt;/p&gt;

&lt;p&gt;A better way to handle the situation is to log any errors other than EAGAIN and EWOULDBLOCK, making sure not to flood the log with such messages, and continue as usual, which at least gives the user an idea of what could be wrong (“raise the ulimit!”). For extra points one could stop the ev_io watcher on the listening fd “for a while”, which reduces CPU usage.&lt;br /&gt;
一个更好的处理这种情况的办法是记录任何错误，除了EAGAIN和EWOULDBLOCK，确保不要使用如此的信息来填充日志，并且继续像往常一样，这至少给用户一个什么是错误的想法（“提高ulimit限制值）。另外的一点，可以在监听的文件描述符上停止ev_io watcher一会儿，这会降低cpu的使用率。&lt;/p&gt;

&lt;p&gt;If your program is single-threaded, then you could also keep a dummy file descriptor for overload situations (e.g. by opening /dev/null), and when you run into ENFILE or EMFILE, close it, run accept, close that fd, and create a new dummy fd. This will gracefully refuse clients under typical overload conditions.&lt;br /&gt;
如果你的程序是单线程的，你也可以为了过载保留一个虚拟的文件描述符（例如通过打开/dev/null),当你遇到ENFILE或者EMFILE的时候，关闭它，运行接收，关闭那个文件描述符，并且创建一个新的虚拟文件描述符。这将在典型的负载条件下，优雅地拒绝客户端。&lt;/p&gt;

&lt;p&gt;The last way to handle it is to simply log the error and exit, as is often done with malloc failures, but this results in an easy opportunity for a DoS attack.&lt;br /&gt;
最后处理它的方法是简单的记录下来error并且退出，如经常使用malloc失败做，但这也导致了给DoS攻击提供了一个简单的机会。&lt;/p&gt;

&lt;h4 id=&quot;watcher-specific-functions&quot;&gt;Watcher-Specific Functions&lt;/h4&gt;

&lt;h5 id=&quot;ev_io_init-ev_io--callback-int-fd-int-events&quot;&gt;ev_io_init (ev_io *, callback, int fd, int events)&lt;/h5&gt;
&lt;h5 id=&quot;ev_io_set-ev_io--int-fd-int-events&quot;&gt;ev_io_set (ev_io *, int fd, int events)&lt;/h5&gt;
&lt;p&gt;Configures an ev_io watcher. The fd is the file descriptor to receive events for and events is either EV_READ, EV_WRITE or EV_READ | EV_WRITE, to express the desire to receive the given events. &lt;br /&gt;
设置一个ev_io的watcher，fd是用来接收事件的文件描述符，events用来表示要接收事件的类型，分别是EV_READ，EV_WRITE或者EV_READ|EV_WRITE之一。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;int fd [read-only]&lt;br /&gt;
The file descriptor being watched.  &lt;br /&gt;
被关注的文件描述符&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;int events [read-only]&lt;br /&gt;
The events being watched.&lt;br /&gt;
被关注的事件类型&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example: Call stdin_readable_cb when STDIN_FILENO has become, well readable, but only once. Since it is likely line-buffered, you could attempt to read a whole line in the callback.&lt;br /&gt;
当STDIN_FILENO可读的时候调用stdin_readable_cb函数，但是callback只运行一次。因为STDIN_FILENO有点像”行缓存“，所以你可以尝试在对调用读取一个完整的行。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void
stdin_readable_cb (struct ev_loop *loop, ev_io *w, int revents)
{
    ev_io_stop (loop, w);
    .. read from stdin here (or from w-&amp;gt;fd) and handle any I/O errors
    //在这里从stdin中读取（或者从watcher的fd中读取），并且处理任何的IO错误
}

...
struct ev_loop *loop = ev_default_init (0);
ev_io stdin_readable;
ev_io_init (&amp;amp;stdin_readable, stdin_readable_cb, STDIN_FILENO, EV_READ);
ev_io_start (loop, &amp;amp;stdin_readable);
ev_run (loop, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;ev_timer---relative-and-optionally-repeating-timeouts-ev_timer-相对和随意的重复过期&quot;&gt;ev_timer - relative and optionally repeating timeouts ev_timer 相对和随意的重复过期&lt;/h4&gt;

&lt;p&gt;Timer watchers are simple relative timers that generate an event after a given time, and optionally repeating in regular intervals after that.&lt;br /&gt;
定时器watchers是简单的在给定时间之后产生一个事件的相对定时器，并且此后有规律的随意重复。&lt;/p&gt;

&lt;p&gt;The timers are based on real time, that is, if you register an event that times out after an hour and you reset your system clock to January last year, it will still time out after (roughly) one hour. “Roughly” because detecting time jumps is hard, and some inaccuracies are unavoidable (the monotonic clock option helps a lot here).&lt;br /&gt;
定时器基于实时的（PS：其实就是实际的时间），这意味着如果你注册一个一个小时后过期的事件，并且你重新设置你的系统时钟到去年的1月份，它仍然（大约）会在一个小时后超时。大概的原因是因为探测时间跳跃是比较苦难的，并且一些误差是无法避免的（这里单调的时钟选项帮助了很多）。&lt;/p&gt;

&lt;p&gt;The callback is guaranteed to be invoked only after its timeout has passed (not at, so on systems with very low-resolution clocks this might introduce a small delay, see “the special problem of being too early”, below). If multiple timers become ready during the same loop iteration then the ones with earlier time-out values are invoked before ones of the same priority with later time-out values (but this is no longer true when a callback calls ev_run recursively).&lt;br /&gt;
只有超时时间已经过了，回调是保证被调用的（不全是这样的，在一些时钟分辨率低的系统上，可能会有小小的延迟，详情请查阅下面的“过早的特殊问题”）。如果在同一个loop迭代中，有多个定时器变得就绪，更早超时的定时器比同优先级下晚超时的定时器早调用（但当回调递归的调用ev_run时，这个规则将不起作用）。&lt;/p&gt;

&lt;p&gt;Be smart about timeouts&lt;br /&gt;
聪明的超时&lt;/p&gt;

&lt;p&gt;Many real-world problems involve some kind of timeout, usually for error recovery. A typical example is an HTTP request - if the other side hangs, you want to raise some error after a while.&lt;br /&gt;
很多真实世界的问题涉及到某种超时，经常用于错误恢复。一个典型的例子就是一个http的请求-如果另外一边hangs，你想在一会儿后抛出错误。&lt;/p&gt;

&lt;p&gt;What follows are some ways to handle this problem, from obvious and inefficient to smart and efficient.&lt;br /&gt;
紧跟着的是一些处理这个事情的方法，这些方法从容易和无效率到聪明和有效率的。&lt;/p&gt;

&lt;p&gt;In the following, a 60 second activity timeout is assumed - a timeout that gets reset to 60 seconds each time there is activity (e.g. each time some data or other life sign was received).&lt;br /&gt;
下面假设一个60秒活跃超时的定时器-即每次活跃的时候重新设置60秒超时（例如：每次接收到一些数据或者是其他的生存信号）。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Use a timer and stop, reinitialise and start it on activity.&lt;br /&gt;
This is the most obvious, but not the most simple way: In the beginning, start the watcher:&lt;br /&gt;
让一个活跃的定时器停止，重新初始化并且启动它。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ev_timer_init (timer, callback, 60., 0.);
ev_timer_start (loop, timer);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then, each time there is some activity, ev_timer_stop it, initialise it and start it again:&lt;br /&gt;
这样，每次活跃的时候，ev_timer_stop停止它，再初始化和启动它：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ev_timer_stop (loop, timer);
ev_timer_set (timer, 60., 0.);
ev_timer_start (loop, timer);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This is relatively simple to implement, but means that each time there is some activity, libev will first have to remove the timer from its internal data structure and then add it again. Libev tries to be fast, but it’s still not a constant-time operation.&lt;br /&gt;
这相对来说是容易实现的，当这意味着每次活跃的时候，libev先必须从他的内部数据结构中移除这个定时器，然后再加上它。libev试着更快的实现，但是这仍然不是一个常数级的操作。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Use a timer and re-start it with ev_timer_again inactivity.&lt;br /&gt;
This is the easiest way, and involves using ev_timer_again instead of ev_timer_start.&lt;br /&gt;
使用定时器，并且使用ev_timer_again重启它。&lt;br /&gt;
这是简单的方法，并且涉及使用ev_timer_again替换ev_timer_start。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To implement this, configure an ev_timer with a repeat value of 60 and then call ev_timer_again at start and each time you successfully read or write some data. If you go into an idle state where you do not expect data to travel on the socket, you can ev_timer_stop the timer, and ev_timer_again will automatically restart it if need be.&lt;br /&gt;
为了实现这些，使用一个60秒重复的值来设置ev_timer，并且在开始和每次你成功的读取或者写数据的时候调用ev_timer_again。如果你进入到一个空闲的状态，你没有预料到数据会流经socket，你可以ev_timer_stop来停止定时器，并且如果需要，ev_timer_again将自动的重启定时器。&lt;/p&gt;

&lt;p&gt;That means you can ignore both the ev_timer_start function and the after argument to ev_timer_set, and only ever use the repeat member and ev_timer_again.&lt;br /&gt;
这意味着你可以忽略ev_timer_start函数和ev_timer_set的after参数。只要使用重复属性和ev_timer_again就可以。&lt;/p&gt;

&lt;p&gt;At start:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ev_init (timer, callback);
timer-&amp;gt;repeat = 60.;
ev_timer_again (loop, timer);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Each time there is some activity:&lt;br /&gt;
每次活跃的时候：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ev_timer_again (loop, timer);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;It is even possible to change the time-out on the fly, regardless of whether the watcher is active or not:&lt;br /&gt;
它甚至可能能在运行的时候改变超时的值，不管watcher是活跃的还是不活跃的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;timer-&amp;gt;repeat = 30.;
ev_timer_again (loop, timer);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This is slightly more efficient then stopping/starting the timer each time you want to modify its timeout value, as libev does not have to completely remove and re-insert the timer from/into its internal data structure.&lt;br /&gt;
当每次停止/启动定时器，你想改变这个过期时间时，这是很有效的，因为libev没有从他的内部数据结构中移除和重新插入定时器。&lt;/p&gt;

&lt;p&gt;It is, however, even simpler than the “obvious” way to do it.&lt;br /&gt;
所以不管怎么说，相比明显的方法（stop，restart）来实现它，它（使用again）是更简单的。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Let the timer time out, but then re-arm it as required.&lt;br /&gt;
设定定时器超时，但是需要的时候的重新准备。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This method is more tricky, but usually most efficient: Most timeouts are relatively long compared to the intervals between other activity - in our example, within 60 seconds, there are usually many I/O events with associated activity resets.&lt;br /&gt;
这个方式是比较投机取巧的，当通常也是效率比较高的。大多数的超时相对其他活动来说时间是比较长的-在我们的例子中，在60秒内，通常有很多IO事件已经被重置了。&lt;/p&gt;

&lt;p&gt;In this case, it would be more efficient to leave the ev_timer alone, but remember the time of last activity, and check for a real timeout only within the callback:&lt;br /&gt;
在这种情况下，让ev_timer单独出来将是比较有效率的，但是要记住最后活跃的时间，并且在callback内部检查真实的超时。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ev_tstamp timeout = 60.;
ev_tstamp last_activity; // time of last activity 最后活跃的时间
ev_timer timer;

static void
callback (EV_P_ ev_timer *w, int revents)
{
    // calculate when the timeout would happen
    //计算什么时候发生的超时
    ev_tstamp after = last_activity - ev_now (EV_A) + timeout;

    // if negative, it means we the timeout already occurred
    //如果小于0，那么表示超时已经发生
    if (after &amp;lt; 0.)
    {
        // timeout occurred, take action
    }
    else
    {
        // callback was invoked, but there was some recent 
        // activity. simply restart the timer to time out
        // after &quot;after&quot; seconds, which is the earliest time
        // the timeout can occur.
        //回调函数被调用，但是这是一些近来的活动，不是这个定时器的。
        //简单重置定时器超时时间，这个时间是超时最早可以发生的时间
        //PS:难道libev的定时器和epoll一样，有“伪信号”问题？
        ev_timer_set (w, after, 0.);
        ev_timer_start (EV_A_ w);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;To summarise the callback: first calculate in how many seconds the timeout will occur (by calculating the absolute time when it would occur, last_activity + timeout, and subtracting the current time, ev_now (EV_A) from that).&lt;br /&gt;
概述整个回调函数：首先，计算还有多少秒超时将会发生（通过就算，计算结果的绝对值就是将要发生的时间，last_activity + timeout，然后减去ev_now返回的当前时间）。&lt;/p&gt;

&lt;p&gt;If this value is negative, then we are already past the timeout, i.e. we timed out, and need to do whatever is needed in this case.&lt;br /&gt;
如果这个值是负数，我们已经比超时晚了，即我们已经超时了，在这种情况下，就要去做任何需要做的事情了。&lt;/p&gt;

&lt;p&gt;Otherwise, we now the earliest time at which the timeout would trigger, and simply start the timer with this timeout value.&lt;br /&gt;
要不然，我们现在比超时将要触发早，并且简单的使用超时时间值启动定时器。&lt;/p&gt;

&lt;p&gt;In other words, each time the callback is invoked it will check whether the timeout occurred. If not, it will simply reschedule itself to check again at the earliest time it could time out. Rinse. Repeat.&lt;br /&gt;
换句话说，每次回调被调用，都要检查超时是否已经发生。如果没有，自己简单的重新安排时间来在它可能超时的最早时间再次检查。再次重新安排，如此重复。&lt;/p&gt;

&lt;p&gt;This scheme causes more callback invocations (about one every 60 seconds minus half the average time between activity), but virtually no calls to libev to change the timeout.&lt;br /&gt;
这种策略导致更多的回调被调用（大约每60秒减去活动之间平均时间的一半），但是事实上没有调用libev来改变超时时间。&lt;/p&gt;

&lt;p&gt;To start the machinery, simply initialise the watcher and set last_activity to the current time (meaning there was some activity just now), then call the callback, which will “do the right thing” and start the timer:&lt;br /&gt;
要开始这样的体系，简单的初始化watcher，并且设置last_activity到当前时间（意味着刚刚有些一些活动），然后调用回调函数，然后做正确的事情，并且开始这个定时器：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;last_activity = ev_now (EV_A);
ev_init (&amp;amp;timer, callback);
callback (EV_A_ &amp;amp;timer, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;When there is some activity, simply store the current time in last_activity, no libev calls at all:&lt;br /&gt;
当有一些活动时，简单的把当前时间值保存到last_activity，根本没有调用libev：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (activity detected)
last_activity = ev_now (EV_A);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;When your timeout value changes, then the timeout can be changed by simply providing a new value, stopping the timer and calling the callback, which will again do the right thing (for example, time out immediately :).&lt;br /&gt;
当超时时间改变的时候，可以通过一个简单的值来更改，停止这个定时器，并且调用回调，然后再一次做正确的事情（例如：立刻超时）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;timeout = new_value;
ev_timer_stop (EV_A_ &amp;amp;timer);
callback (EV_A_ &amp;amp;timer, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This technique is slightly more complex, but in most cases where the time-out is unlikely to be triggered, much more efficient.&lt;br /&gt;
这种技巧稍微有点复杂，但是更多情况下，超时是不太可能被触发的，这样更有效率一些。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Wee, just use a double-linked list for your timeouts.&lt;br /&gt;
很早的时候超时只是使用一个双链表&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If there is not one request, but many thousands (millions…), all employing some kind of timeout with the same timeout value, then one can do even better:&lt;br /&gt;
如果这不是一个请求，而是成千上万个（数百万个），所有的同类型超时都有相同的超时值，那么这样（使用双链表）可以做的更好。&lt;/p&gt;

&lt;p&gt;When starting the timeout, calculate the timeout value and put the timeout at the end of the list.&lt;br /&gt;
当启动定时器的时候，计算超时值并且把定时器放在列表的最后面。&lt;/p&gt;

&lt;p&gt;Then use an ev_timer to fire when the timeout at the beginning of the list is expected to fire (for example, using the technique #3).&lt;br /&gt;
当列表头部的定时器希望被触发的时候，使用一个ev_timer来触发（例如，使用技巧3）。&lt;/p&gt;

&lt;p&gt;When there is some activity, remove the timer from the list, recalculate the timeout, append it to the end of the list again, and make sure to update the ev_timer if it was taken from the beginning of the list.&lt;br /&gt;
当定时器活跃的时候，从列表中移除定时器，重新计算超时时间，再次把它加到列表的最后，并且如果定时器来自列表的头部，那么确保更新ev_timer。&lt;/p&gt;

&lt;p&gt;This way, one can manage an unlimited number of timeouts in O(1) time for starting, stopping and updating the timers, at the expense of a major complication, and having to use a constant timeout. The constant timeout ensures that the list stays sorted.&lt;br /&gt;
这种方法，可以使用O（1）的算法复杂度来管理无限数量的定时器，启动，停止和更新这些定时器，最大的困难是性能开销，并且不得不使用一个固定的超时。固定的超时确保列表保持排序。&lt;/p&gt;

&lt;p&gt;So which method the best?&lt;br /&gt;
所以哪个方法是最好的？&lt;/p&gt;

&lt;p&gt;Method #2 is a simple no-brain-required solution that is adequate in most situations. Method #3 requires a bit more thinking, but handles many cases better, and isn’t very complicated either. In most case, choosing either one is fine, with #3 being better in typical situations.&lt;br /&gt;
方法2是简单的不用想的解决方案，这个方案在大多数情况下已经够用。方法3需要稍微想一下，但是在很多情况下都会处理的更好，并且也不是太复杂。在大多数情况下，选择任何一个都很好，再典型的情况下，方法3会更好。&lt;/p&gt;

&lt;p&gt;Method #1 is almost always a bad idea, and buys you nothing. Method #4 is rather complicated, but extremely efficient, something that really pays off after the first million or so of active timers, i.e. it’s usually overkill :)&lt;br /&gt;
方法1几乎都是一个挺烂的解决方案，并且带给你任何东西。方法4太复杂，但非常有效，通常百万或者同等数量的定时器没有问题（PS：根据想象翻译了，有更好的翻译嘛？）。通常，它都是比较过度的。&lt;/p&gt;

&lt;p&gt;The special problem of being too early&lt;br /&gt;
被提前超时的问题&lt;/p&gt;

&lt;p&gt;If you ask a timer to call your callback after three seconds, then you expect it to be invoked after three seconds - but of course, this cannot be guaranteed to infinite precision. Less obviously, it cannot be guaranteed to any precision by libev - imagine somebody suspending the process with a STOP signal for a few hours for example.&lt;br /&gt;
如果你想一个定时器在3秒后调用你的回调函数，那么你期望3秒过后回调函数将被调用（这不是废话？？）—当然，不能给你确保无限精度。显然，libev不能确保任何的精确性-；例如，一些人使用STOP信号挂起进程几个小时。&lt;/p&gt;

&lt;p&gt;So, libev tries to invoke your callback as soon as possible after the delay has occurred, but cannot guarantee this.&lt;br /&gt;
所以，libev试着在延时发生后尽可能快的调用回调函数，但是不能保证这一点。&lt;/p&gt;

&lt;p&gt;A less obvious failure mode is calling your callback too early: many event loops compare timestamps with a “elapsed delay &amp;gt;= requested delay”, but this can cause your callback to be invoked much earlier than you would expect.&lt;br /&gt;
一个不太明显的模式是调用你的回调函数太早了：很多event loops比较“经过延迟&amp;gt;=需要延迟”的时间戳，但是这将可能会导致比你期望更早的调用你的回调函数。&lt;/p&gt;

&lt;p&gt;To see why, imagine a system with a clock that only offers full second resolution (think windows if you can’t come up with a broken enough OS yourself). If you schedule a one-second timer at the time 500.9, then the event loop will schedule your timeout to elapse at a system time of 500 (500.9 truncated to the resolution) + 1, or 501.&lt;br /&gt;
来看看为什么，一个系统时钟只提供了2秒的精度（想想wins，如果你不能在一个自身中断足够的操作系统）。当时间在500.9的时候，如果你设置了一个1s的定时器，那么，event loop将在系统过500（500.9被截尾）+1，触发你的超时，或者是过了501.&lt;/p&gt;

&lt;p&gt;If an event library looks at the timeout 0.1s later, it will see “501 &amp;gt;= 501” and invoke the callback 0.1s after it was started, even though a one-second delay was requested - this is being “too early”, despite best intentions.&lt;br /&gt;
如果一个事件库看起来超时了0.1s，它将判断“501 &amp;gt;= 501”，并且在启动后的0.1s调用回调函数，尽管其实需要1s的延迟-这就太早了，尽管意图是好的。&lt;/p&gt;

&lt;p&gt;This is the reason why libev will never invoke the callback if the elapsed delay equals the requested delay, but only when the elapsed delay is larger than the requested delay. In the example above, libev would only invoke the callback at system time 502, or 1.1s after the timer was started.&lt;br /&gt;
这就是为什么libev永远也不会在真实的超时等于预想的超时时调用回调函数的原因，但是相比预想的回调时间只会稍微玩一会儿。在上面的示例中，libev只会在系统时间502或者在启动定时器1.1s之后调用回调函数。&lt;/p&gt;

&lt;p&gt;So, while libev cannot guarantee that your callback will be invoked exactly when requested, it can and does guarantee that the requested delay has actually elapsed, or in other words, it always errs on the “too late” side of things.&lt;br /&gt;
所以，当libev不能保证按照你的需求及时调用你的回调函数的时候，它可以并且确实保证需要的延迟已经到了，或者换句话说，对于按时回调来说，它总是犯“为时已晚”的错误。&lt;/p&gt;

&lt;p&gt;The special problem of time updates&lt;br /&gt;
更新时间的问题&lt;/p&gt;

&lt;p&gt;Establishing the current time is a costly operation (it usually takes at least one system call): EV therefore updates its idea of the current time only before and after ev_run collects new events, which causes a growing difference between ev_now () and ev_time () when handling lots of events in one iteration.&lt;br /&gt;
获取当前时间是一个代价高昂的操作（至少需要一个系统调用）：EV因此只在rv_run获取新的事件之前和之后才会更新当前时间，这意味这如果在一个迭代中处理了很多的事件，那么ev_now（）和ev_time（）的值将会不想等。&lt;/p&gt;

&lt;p&gt;The relative timeouts are calculated relative to the ev_now () time. This is usually the right thing as this timestamp refers to the time of the event triggering whatever timeout you are modifying/starting. If you suspect event processing to be delayed and you need to base the timeout on the current time, use something like the following to adjust for it:&lt;br /&gt;
相对超时时间是根据ev_now来计算的。这通常是正确的，因为这个时间戳来自于事件触发的事件，不管你更改/启动这个超时。如果你怀疑事件处理被延迟并且你需要使用基于当前时间的超时，使用如下的步骤调整它：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ev_timer_set (&amp;amp;timer, after + (ev_time () - ev_now ()), 0.);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;If the event loop is suspended for a long time, you can also force an update of the time returned by ev_now () by calling ev_now_update (), although that will push the event time of all outstanding events further into the future.&lt;br /&gt;
如果event loop被挂起很久了，你也可以强制使用ev_now_update更新时间，然后使用ev_now返回的时间，尽管这样做会把还没有处理的事件延迟的稍晚一些。&lt;/p&gt;

&lt;p&gt;The special problem of unsynchronised clocks&lt;br /&gt;
时钟不同步的问题&lt;/p&gt;

&lt;p&gt;Modern systems have a variety of clocks - libev itself uses the normal “wall clock” clock and, if available, the monotonic clock (to avoid time jumps).&lt;br /&gt;
现代系统有各种时钟-libev自己使用常见的“挂钟”时钟，如果可能，也会使用单调时钟（避免时间跳跃）。&lt;/p&gt;

&lt;p&gt;Neither of these clocks is synchronised with each other or any other clock on the system, so ev_time () might return a considerably different time than gettimeofday () or time (). On a GNU/Linux system, for example, a call to gettimeofday might return a second count that is one higher than a directly following call to time.&lt;br /&gt;
任何一个系统时钟或者时钟两两之间都是不同步的，所以ev_time的返回值可能和gettimeofday或者time返回的值完全不同。在linux系统上，例如，调用gettimeofday返回的秒数可能比接着直接调用time数值高。&lt;/p&gt;

&lt;p&gt;The moral of this is to only compare libev-related timestamps with ev_time () and ev_now (), at least if you want better precision than a second or so.&lt;br /&gt;
这样做的意义仅仅只是比较使用ev_time和ev_now返回的libev相关的时间戳，至少你可以有比一秒更好的精度。&lt;/p&gt;

&lt;p&gt;One more problem arises due to this lack of synchronisation: if libev uses the system monotonic clock and you compare timestamps from ev_time or ev_now from when you started your timer and when your callback is invoked, you will find that sometimes the callback is a bit “early”.&lt;br /&gt;
还有一个问题会由于缺乏同步出现：如果libev使用系统单调时钟并且当你启动你的定时器并且回调已经被调用时，你比较由ev_time或者ev_now返回的时间戳，你将会发现有的时候回调被早调用了。&lt;/p&gt;

&lt;p&gt;This is because ev_timers work in real time, not wall clock time, so libev makes sure your callback is not invoked before the delay happened, measured according to the real time, not the system clock.&lt;br /&gt;
这是因为ev_timer工作在真实的时间，不是时钟时间，所以libev确保在延迟到期之前不会调用你的回调函数，因为ev_timer是按照真实的时间判断，而不是按照时钟时间。&lt;/p&gt;

&lt;p&gt;If your timeouts are based on a physical timescale (e.g. “time out this connection after 100 seconds”) then this shouldn’t bother you as it is exactly the right behaviour.&lt;br /&gt;
如果你的超时是基于物理时间表（例如100s之后这个连接超时），那么这应该不会打扰你，因为它是一个完全正确的行为。&lt;/p&gt;

&lt;p&gt;If you want to compare wall clock/system timestamps to your timers, then you need to use ev_periodics, as these are based on the wall clock time, where your comparisons will always generate correct results.&lt;br /&gt;
如果你想为你的定时器比较时钟/系统时间戳，那么你需要使用ev_periodics，因为是ev_periodics基于时钟的，你的比较都会产生正确的结果。&lt;/p&gt;

&lt;p&gt;The special problems of suspended animation&lt;br /&gt;
假死的问题&lt;/p&gt;

&lt;p&gt;When you leave the server world it is quite customary to hit machines that can suspend/hibernate - what happens to the clocks during such a suspend?&lt;br /&gt;
当你离开了服务器领域，你可以完全的控制你的机器，你可以暂停/休眠-那么在这个延迟中间，时钟发生了什么？&lt;/p&gt;

&lt;p&gt;Some quick tests made with a Linux 2.6.28 indicate that a suspend freezes all processes, while the clocks (times, CLOCK_MONOTONIC) continue to run until the system is suspended, but they will not advance while the system is suspended. That means, on resume, it will be as if the program was frozen for a few seconds, but the suspend time will not be counted towards ev_timer when a monotonic clock source is used. The real time clock advanced as expected, but if it is used as sole clocksource, then a long suspend would be detected as a time jump by libev, and timers would be adjusted accordingly.&lt;br /&gt;
在linux 2.6.28上做一些快速的测试，表明暂停并且冻结所有的进程，当时钟（时间，单调时钟）继续运行直到系统被暂停，当他们不会提前当系统暂停。这就意味着，在重新启动的时候，这将会像程序被冻结了几秒钟，但是当单调时钟被使用的时候，暂停时间不会被计算到ev_timer。真实的时间按照预期那样运行，但如果它是被使用的唯一的时间源，那么一个长的暂停将会被libev作为一个时间跳跃检测到，并且定时器会按照这个时间跳跃调整。&lt;/p&gt;

&lt;p&gt;I would not be surprised to see different behaviour in different between operating systems, OS versions or even different hardware.&lt;br /&gt;
我也不会在看到在不同的操作系统，操作系统版本或者是不同的硬件之间存在不同的行为而感到惊讶。&lt;/p&gt;

&lt;p&gt;The other form of suspend (job control, or sending a SIGSTOP) will see a time jump in the monotonic clocks and the realtime clock. If the program is suspended for a very long time, and monotonic clock sources are in use, then you can expect ev_timers to expire as the full suspension time will be counted towards the timers. When no monotonic clock source is in use, then libev will again assume a timejump and adjust accordingly.&lt;br /&gt;
暂停的另外一种形式（作业控制，或者发生一个SIGSTOP信号）将会看到在单调时钟和真实的时钟中有时间跳跃。如果程序被暂停了很多时间，并且使用单调时钟源，那么随着所有的暂停时间将被计算到定时器，你可以期望ev_timers终止。当不是使用单调时钟源时，那么libev将再假定一次时间跳跃，并且相应的调整。&lt;/p&gt;

&lt;p&gt;It might be beneficial for this latter case to call ev_suspend and ev_resume in code that handles SIGTSTP, to at least get deterministic behaviour in this case (you can do nothing against SIGSTOP).&lt;br /&gt;
后一种方法对于调用ev_suspend和ec_resume来处理SIGTSP是有利的，至少在这种情况下有一个稳定的行为（靠SIGSTOP你将不能做任何事情）。&lt;/p&gt;

&lt;h4 id=&quot;watcher-specific-functions-and-data-members-watcher-特殊的函数和数据成员&quot;&gt;Watcher-Specific Functions and Data Members watcher-特殊的函数和数据成员&lt;/h4&gt;

&lt;h5 id=&quot;ev_timer_init-ev_timer--callback-ev_tstamp-after-ev_tstamp-repeat&quot;&gt;ev_timer_init (ev_timer *, callback, ev_tstamp after, ev_tstamp repeat)&lt;/h5&gt;
&lt;h5 id=&quot;ev_timer_set-ev_timer--ev_tstamp-after-ev_tstamp-repeat&quot;&gt;ev_timer_set (ev_timer *, ev_tstamp after, ev_tstamp repeat)&lt;/h5&gt;
&lt;p&gt;Configure the timer to trigger after after seconds. If repeat is 0., then it will automatically be stopped once the timeout is reached. If it is positive, then the timer will automatically be configured to trigger again repeat seconds later, again, and again, until stopped manually.&lt;br /&gt;
配置定时器在after秒之后触发。如果repeat为0，那么定时器在超时一次后自动的停止。如果repeat是正数，那么定时器将会一次又一次的循环触发，直到你手动停止为止。&lt;/p&gt;

&lt;p&gt;The timer itself will do a best-effort at avoiding drift, that is, if you configure a timer to trigger every 10 seconds, then it will normally trigger at exactly 10 second intervals. If, however, your program cannot keep up with the timer (because it takes longer than those 10 seconds to do stuff) the timer will not fire more than once per event loop iteration.&lt;br /&gt;
定时器自己会尽最大的努力避免重叠，也就说，如果你配置一个定时器每10s触发一次，那么它通常会在整整10s的时候被触发，但是，如果你的程序不能在10s内完成回调（因为回调可能需要比10s更长的时间），那么定时器将不会在每次event loop迭代中触发大于一次（PS：是不是也就是说，如果callback耗时比timer的时间间隔长，那么下一次的回调将不会被调用？）。&lt;/p&gt;

&lt;h5 id=&quot;ev_timer_again-loop-ev_timer-&quot;&gt;ev_timer_again (loop, ev_timer *)&lt;/h5&gt;
&lt;p&gt;This will act as if the timer timed out, and restarts it again if it is repeating. It basically works like calling ev_timer_stop, updating the timeout to the repeat value and calling ev_timer_start.&lt;br /&gt;
如果定时器超时，并且如果定时器是重复的，那么此函数会重启它。这基本上工作起来类似于点用ev_timer_stop，更新超时的重复值，然后再调用ev_timer_start。&lt;/p&gt;

&lt;p&gt;The exact semantics are as in the following rules, all of which will be applied to the watcher:&lt;br /&gt;
确切的意思如下所述，所有的这些规则都会应用到watcher：&lt;/p&gt;

&lt;p&gt;If the timer is pending, the pending status is always cleared.&lt;br /&gt;
如果定时器被挂起，那么挂起状态一直被清零。&lt;br /&gt;
If the timer is started but non-repeating, stop it (as if it timed out, without invoking it).&lt;br /&gt;
如果定时器被启动但是不是重复的，停止它（就像定时器超时，但是不调用它）。&lt;br /&gt;
If the timer is repeating, make the repeat value the new timeout and start the timer, if necessary.&lt;br /&gt;
如果定时器是重复的，如果必要，把新的超时值设置成重复的值，并且启动定时器。&lt;br /&gt;
This sounds a bit complicated, see Be smart about timeouts, above, for a usage example.&lt;br /&gt;
这听起来有点复杂，上面有关于超时用法的章节示例。&lt;/p&gt;

&lt;h5 id=&quot;ev_tstamp-ev_timer_remaining-loop-ev_timer-&quot;&gt;ev_tstamp ev_timer_remaining (loop, ev_timer *)&lt;/h5&gt;
&lt;p&gt;Returns the remaining time until a timer fires. If the timer is active, then this time is relative to the current event loop time, otherwise it’s the timeout value currently configured.&lt;br /&gt;
返回离定时器被触发的时间。如果定时器是活跃的，那么这个时间就是相对于当前event loop的时间，否则，这就是当前配置额的超时时间。&lt;/p&gt;

&lt;p&gt;That is, after an ev_timer_set (w, 5, 7), ev_timer_remaining returns 5. When the timer is started and one second passes, ev_timer_remaining will return 4. When the timer expires and is restarted, it will return roughly 7 (likely slightly less as callback invocation takes some time, too), and so on.&lt;br /&gt;
也就是说，在调用ev_timer_set（w，5，7）之后，ev_timer_remaining返回5.当定时器被启动，并且过了1s时间，ev_timer_remaining将返回4.当定时器超时，并且被重启，那么它将返回大约是7（也有可能会比7少一些，因为调用回调函数也需要一些时间），等等。&lt;/p&gt;

&lt;h5 id=&quot;ev_tstamp-repeat-read-write&quot;&gt;ev_tstamp repeat [read-write]&lt;/h5&gt;
&lt;p&gt;The current repeat value. Will be used each time the watcher times out or ev_timer_again is called, and determines the next timeout (if any), which is also when any modifications are taken into account.&lt;br /&gt;
当前重复值。每个监视器超时或ev_timer_again被调用时将被使用，并且确定下一个超时值（如果有的话） ，这也是当任何修改都考虑在内。&lt;/p&gt;

&lt;p&gt;Example: Create a timer that fires after 60 seconds.&lt;br /&gt;
示例：创建一个60s后触发的定时器。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void
one_minute_cb (struct ev_loop *loop, ev_timer *w, int revents)
{
    .. one minute over, w is actually stopped right here
}

ev_timer mytimer;
ev_timer_init (&amp;amp;mytimer, one_minute_cb, 60., 0.);
ev_timer_start (loop, &amp;amp;mytimer);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Example: Create a timeout timer that times out after 10 seconds of inactivity.&lt;br /&gt;
示例：创建一个定时器，10s之内不活动&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void
timeout_cb (struct ev_loop *loop, ev_timer *w, int revents)
{
    .. ten seconds without any activity
    //10s内没有任何活动
}

ev_timer mytimer;
ev_timer_init (&amp;amp;mytimer, timeout_cb, 0., 10.); /* note, only repeat used 注意，只用了repeat*/

ev_timer_again (&amp;amp;mytimer); /* start timer  启动定时器*/
ev_run (loop, 0);

// and in some piece of code that gets executed on any &quot;activity&quot;:
// reset the timeout to start ticking again at 10 seconds
//PS：这句怎么翻译？
ev_timer_again (&amp;amp;mytimer);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ev_periodic---to-cron-or-not-to-cron--ev_periodoc-克隆或者不克隆&quot;&gt;ev_periodic - to cron or not to cron?  ev_periodoc-克隆或者不克隆&lt;/h3&gt;

&lt;p&gt;Periodic watchers are also timers of a kind, but they are very versatile (and unfortunately a bit complex).&lt;br /&gt;
periodic watchers也是一种定时器，但是他们用途非常多（可惜有点复杂）。&lt;/p&gt;

&lt;p&gt;Unlike ev_timer, periodic watchers are not based on real time (or relative time, the physical time that passes) but on wall clock time (absolute time, the thing you can read on your calender or clock). The difference is that wall clock time can run faster or slower than real time, and time jumps are not uncommon (e.g. when you adjust your wrist-watch).&lt;br /&gt;
不像ev_timer，periodic watchers不是基于真实事件的（或者相对时间，经过的物理时间），但是基于时钟时间（绝对时间，你可以在你的日历或者钟表上读到的时间）。不同的是挂钟时间可以比真实时间跑的更快或者更慢，并且时间跳跃也是经常发生的（比如，当你调整你手表的时候）。&lt;/p&gt;

&lt;p&gt;You can tell a periodic watcher to trigger after some specific point in time: for example, if you tell a periodic watcher to trigger “in 10 seconds” (by specifying e.g. ev_now () + 10., that is, an absolute time not a delay) and then reset your system clock to January of the previous year, then it will take a year or more to trigger the event (unlike an ev_timer, which would still trigger roughly 10 seconds after starting it, as it uses a relative timeout).&lt;br /&gt;
你可以告诉你的periodic watcher在指定的时间点之后触发：比如，如果你告诉一个periodic watcher在10s后触发（通过指定如ev_now（） +10，也就说，一个不延迟的绝对时间）并且重设你的系统时间到去年的一个月，那么periodic将会在至少1年的时间来触发事件（不像ev_timer，ev_timer仍然会在开始的10s之后触发，因为它使用的是相对时间）。&lt;/p&gt;

&lt;p&gt;ev_periodic watchers can also be used to implement vastly more complex timers, such as triggering an event on each “midnight, local time”, or other complicated rules. This cannot be done with ev_timer watchers, as those cannot react to time jumps.&lt;br /&gt;
ev_periodic watchers也可以被用来实现复杂的多的定时器，比如每个本地的午夜触发事件，或者另外复杂的规则。这是不能用ev_timer来实现的，因为ev_timer不能对于时间跳跃做出更好的反映。&lt;/p&gt;

&lt;p&gt;As with timers, the callback is guaranteed to be invoked only when the point in time where it is supposed to trigger has passed. If multiple timers become ready during the same loop iteration then the ones with earlier time-out values are invoked before ones with later time-out values (but this is no longer true when a callback calls ev_run recursively).&lt;br /&gt;
如果定时器 ，只有当这个触发事件的时间点已经过了，回调函数才是保证被调用的，如果在同一个循环迭代中有多个定时器变的就绪，那么早超时的定时器比晚超时的定时器早调用（当回调函数中递归的调用ev_run时，这个规则会被打破）。&lt;/p&gt;

&lt;h4 id=&quot;watcher-specific-functions-and-data-members-watcher-特殊的函数和数据成员-1&quot;&gt;Watcher-Specific Functions and Data Members watcher-特殊的函数和数据成员&lt;/h4&gt;

&lt;h5 id=&quot;ev_periodic_init-ev_periodic--callback-ev_tstamp-offset-ev_tstamp-interval-reschedule_cb&quot;&gt;ev_periodic_init (ev_periodic *, callback, ev_tstamp offset, ev_tstamp interval, reschedule_cb)&lt;/h5&gt;
&lt;h5 id=&quot;ev_periodic_set-ev_periodic--ev_tstamp-offset-ev_tstamp-interval-reschedule_cb&quot;&gt;ev_periodic_set (ev_periodic *, ev_tstamp offset, ev_tstamp interval, reschedule_cb)&lt;/h5&gt;
&lt;p&gt;Lots of arguments, let’s sort it out… There are basically three modes of operation, and we will explain them from simplest to most complex:&lt;br /&gt;
参数很多，让我们整理一下。基本上有3种操作模式，我们将从最简单的开始到最复杂的这样解释：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;absolute timer (offset = absolute time, interval = 0, reschedule_cb = 0)&lt;br /&gt;
绝对时间（offset = 绝对时间, interval = 0, reschedule_cb = 0）
  In this configuration the watcher triggers an event after the wall clock time offset has passed. It will not repeat and will not adjust when a time jump occurs, that is, if it is to be run at January 1st 2011 then it will be stopped and invoked when the system clock reaches or surpasses this point in time.&lt;br /&gt;
  在这个配置中，watcher会在时钟过了offset这个时间点触发一个事件。它不会重复并且也不会随着时间的跳跃进行调整，也就是说，如果watcher将在2011-01-01运行，那么watcher会在时钟到了或者超过这个时间点的时候停止并且调用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;repeating interval timer (offset = offset within interval, interval &amp;gt; 0, reschedule_cb = 0)&lt;br /&gt;
  重复的间隔时间（offset＝间隔时间，interval&amp;gt;0,reschedule_cb=0)&lt;br /&gt;
  In this mode the watcher will always be scheduled to time out at the next offset + N * interval time (for some integer N, which can also be negative) and then repeat, regardless of any time jumps. The offset argument is merely an offset into the interval periods.&lt;br /&gt;
  在这个模式中，watcher将一直被安排在下一个offset + N*interval时间（N也可能是负数）时触发，并且重复，任何的jumps也不会起作用。offset参数仅仅只是一个间隔周期的补偿而已。&lt;/p&gt;

    &lt;p&gt;This can be used to create timers that do not drift with respect to the system clock, for example, here is an ev_periodic that triggers each hour, on the hour (with respect to UTC):&lt;br /&gt;
  这可以用来创建一个和系统时钟时间跳跃无关的定时器，例如，这里的ev_periodic每个小时触发一次，整整一个小时（相对于UTC来说）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    ev_periodic_set (&amp;amp;periodic, 0., 3600., 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This doesn’t mean there will always be 3600 seconds in between triggers, but only that the callback will be called when the system time shows a full hour (UTC), or more correctly, when the system time is evenly divisible by 3600.&lt;br /&gt;
这并不意味着每次触发的时间间隔都是3600s，但也仅仅当系统时间显示整整一个小时（UTC）的时候，回调函数才会被调用，或者更准确的说，当系统时间为3600整除的时候才会触发事件（PS：难道那么多废话就是为了表达“整点”）。&lt;/p&gt;

&lt;p&gt;Another way to think about it (for the mathematically inclined) is that ev_periodic will try to run the callback in this mode at the next possible time where time = offset (mod interval), regardless of any time jumps.&lt;br /&gt;
考虑这个问题（为了数学倾向）的另一种方式就是ev_periodic将试着在这种模式下在下一个时间点time＝offset（取余interval）时运行回调，不会理会任何的时间跳跃。&lt;/p&gt;

&lt;p&gt;The interval MUST be positive, and for numerical stability, the interval value should be higher than 1/8192 (which is around 100 microseconds) and offset should be higher than 0 and should have at most a similar magnitude as the current time (say, within a factor of ten). Typical values for offset are, in fact, 0 or something between 0 and interval, which is also the recommended range.&lt;br /&gt;
时间间隔必须是正数，并且数值稳定的。这个值应该大于1/8192（大约100微妙），误差应该大于0最大和现在时间一个数量级的数（比方说，是小于10的因数）。典型的误差值，事实上是0或者0-时间间隔之间，这也是推荐的范围。&lt;/p&gt;

&lt;p&gt;Note also that there is an upper limit to how often a timer can fire (CPU speed for example), so if interval is very small then timing stability will of course deteriorate. Libev itself tries to be exact to be about one millisecond (if the OS supports it and the machine is fast enough).&lt;br /&gt;
还要注意的是，有一个多久可以触发定时器的上限（例如CPU的速度），所以如果时间间隔非常小，那么时序的稳定性肯定会变差。Libev自己会试着去稳定在1毫秒（如果OS提供这个精度并且机器足够快）。&lt;/p&gt;

&lt;p&gt;manual reschedule mode (offset ignored, interval ignored, reschedule_cb = callback)&lt;br /&gt;
手动重新排序模式（offset 忽略，interval 忽略，reschedule_cb＝callback）&lt;br /&gt;
In this mode the values for interval and offset are both being ignored. Instead, each time the periodic watcher gets scheduled, the reschedule callback will be called with the watcher as first, and the current time as second argument.&lt;br /&gt;
在这个模式中，offset和interval的值都被忽略。相反的，每次periodic watcher都会被排序，首先会使用watcher作为参数来调用重新排序的回调函数，并且当前时间作为第二个参数。&lt;/p&gt;

&lt;p&gt;NOTE: This callback MUST NOT stop or destroy any periodic watcher, ever, or make ANY other event loop modifications whatsoever, unless explicitly allowed by documentation here.&lt;br /&gt;
注意：除非文档明确允许这样做，否则这个回调必须不能停止或者释放任何的periodic watcher，或者无论什么也不能对event loop做出任何的修改。&lt;/p&gt;

&lt;p&gt;If you need to stop it, return now + 1e30 (or so, fudge fudge) and stop it afterwards (e.g. by starting an ev_prepare watcher, which is the only event loop modification you are allowed to do). &lt;br /&gt;
如果你需要停止这个periodic，返回now + 1e30（左后）然后停止它（例如通过启动一个ev_prepare watcher，它是唯一一个被允许修改event loop的）。&lt;/p&gt;

&lt;p&gt;The callback prototype is ev_tstamp (&lt;em&gt;reschedule_cb)(ev_periodic *w, ev_tstamp now), e.g.:&lt;br /&gt;
回调的原型签名 ev_tstamp (&lt;/em&gt;reschedule_cb)(ev_periodic *w, ev_tstamp now),&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    static ev_tstamp
    my_rescheduler (ev_periodic *w, ev_tstamp now)
    {
        return now + 60.;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;It must return the next time to trigger, based on the passed time value (that is, the lowest time value larger than to the second argument). It will usually be called just before the callback will be triggered, but might be called at other times, too.&lt;br /&gt;
它必须返回下一次触发的时间，这个时间是基于经过时间值的（即，比第二个参数大的最小值）。它经常就在回调被触发之前被调用，但是也有可能在别的时间被调用。&lt;/p&gt;

&lt;p&gt;NOTE: This callback must always return a time that is higher than or equal to the passed now value.&lt;br /&gt;
注意：回调函数必须一直返回一个高于或者等于当前已经过去时间的值。&lt;/p&gt;

&lt;p&gt;This can be used to create very complex timers, such as a timer that triggers on “next midnight, local time”. To do this, you would calculate the next midnight after now and return the timestamp value for this. How you do this is, again, up to you (but it is not trivial, which is the main reason I omitted it as an example).&lt;br /&gt;
它可以被用来创建一个非常复杂的定时器，例如一个在“下一个本地的午夜”触发的定时器。为了做这些，你要计算下一个午夜离现在多少时间，并且要返回这个时间戳。你怎么做？再一次，由你决定（但是它并不是不重要的，这就是我省略它来作为例子的最大原因）。&lt;/p&gt;

&lt;h5 id=&quot;ev_periodic_again-loop-ev_periodic-&quot;&gt;ev_periodic_again (loop, ev_periodic *)&lt;/h5&gt;
&lt;p&gt;Simply stops and restarts the periodic watcher again. This is only useful when you changed some parameters or the reschedule callback would return a different time than the last time it was called (e.g. in a crond like program when the crontabs have changed).&lt;br /&gt;
只是再一次停止并且重启periodic watcher。只有当你改变一些参数或者重新排列回调函数将返回和回调函数被调用时最新的时间不同的时间时是有用的。（例如在一个克隆的程序中当crontabs已经改变）。（PS：这段怎么翻译？德国人写的E文也是nm看不懂的玩意）。&lt;/p&gt;

&lt;h5 id=&quot;ev_tstamp-ev_periodic_at-ev_periodic-&quot;&gt;ev_tstamp ev_periodic_at (ev_periodic *)&lt;/h5&gt;
&lt;p&gt;When active, returns the absolute time that the watcher is supposed to trigger next. This is not the same as the offset argument to ev_periodic_set, but indeed works even in interval and manual rescheduling modes.&lt;br /&gt;
如果watcher是活跃的，返回watcher下一次触发的绝对时间。这个ev_periodic_set的offset参数不同，但是不管是在interval还是手动重排模式，都确实能工作。&lt;/p&gt;

&lt;h5 id=&quot;ev_tstamp-offset-read-write&quot;&gt;ev_tstamp offset [read-write]&lt;/h5&gt;
&lt;p&gt;When repeating, this contains the offset value, otherwise this is the absolute point in time (the offset value passed to ev_periodic_set, although libev might modify this value for better numerical stability).&lt;br /&gt;
当重复的时候，它包含了offset的值，否则它据说一个绝对的时间点（offset传递给ev_periodic_set，尽管libev可能会为了数值稳定性更改这个值）。&lt;/p&gt;

&lt;p&gt;Can be modified any time, but changes only take effect when the periodic timer fires or ev_periodic_again is being called.&lt;br /&gt;
可以在任何时候更改，但是更改只有在periodic定时器触发或者ev_periodic_again再一次被调用时有效。&lt;/p&gt;

&lt;h5 id=&quot;ev_tstamp-interval-read-write&quot;&gt;ev_tstamp interval [read-write]&lt;/h5&gt;
&lt;p&gt;The current interval value. Can be modified any time, but changes only take effect when the periodic timer fires or ev_periodic_again is being called.&lt;br /&gt;
当前间隔时间。任何时候都可以被更改，但是只有在periodic定时器被触发或者ev_periodic_again被调用时才有效。&lt;/p&gt;

&lt;h5 id=&quot;ev_tstamp-reschedule_cbev_periodic-w-ev_tstamp-now-read-write&quot;&gt;ev_tstamp (*reschedule_cb)(ev_periodic *w, ev_tstamp now) [read-write]&lt;/h5&gt;
&lt;p&gt;The current reschedule callback, or 0, if this functionality is switched off. Can be changed any time, but changes only take effect when the periodic timer fires or ev_periodic_again is being called.&lt;br /&gt;
当前重排的回调函数，或者是空的。如果这个功能被关闭，那么任何时候都可以更改，但是更改只有当periodic被触发或者ev_periodic_again被调用时才有效。&lt;/p&gt;

&lt;p&gt;Example: Call a callback every hour, or, more precisely, whenever the system time is divisible by 3600. The callback invocation times have potentially a lot of jitter, but good long-term stability.&lt;br /&gt;
示例：每一个小时调用一个回调，或者更确切的说，是当系统时间是3600的整数倍时。这个回调函数被调用的时间可能会有点波动，但基本拥有良好的长期稳定性。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void
clock_cb (struct ev_loop *loop, ev_periodic *w, int revents)
{
    ... its now a full hour (UTC, or TAI or whatever your clock follows)
}

ev_periodic hourly_tick;
ev_periodic_init (&amp;amp;hourly_tick, clock_cb, 0., 3600., 0);
ev_periodic_start (loop, &amp;amp;hourly_tick);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Example: The same as above, but use a reschedule callback to do it:&lt;br /&gt;
示例：和上面一样，但是使用重排回调函数来做。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;math.h&amp;gt;

static ev_tstamp
my_scheduler_cb (ev_periodic *w, ev_tstamp now)
{
    return now + (3600. - fmod (now, 3600.));
}

ev_periodic_init (&amp;amp;hourly_tick, clock_cb, 0., 0., my_scheduler_cb);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Example: Call a callback every hour, starting now:&lt;br /&gt;
示例：每小时调用一次回调函数，现在开始。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ev_periodic hourly_tick;
ev_periodic_init (&amp;amp;hourly_tick, clock_cb,
fmod (ev_now (loop), 3600.), 3600., 0);
ev_periodic_start (loop, &amp;amp;hourly_tick);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ev_signal---signal-me-when-a-signal-gets-signalled--ev_signal-当一个信号被触发的时候通知我&quot;&gt;ev_signal - signal me when a signal gets signalled!  ev_signal-当一个信号被触发的时候通知我&lt;/h3&gt;

&lt;p&gt;Signal watchers will trigger an event when the process receives a specific signal one or more times. Even though signals are very asynchronous, libev will try its best to deliver signals synchronously, i.e. as part of the normal event processing, like any other event.&lt;br /&gt;
当进程一次或者多次接收到一个指定的信号时，signal watchers将触发一个事件。即使信号是异步信号，libev将尽力给予信号同步，就像其他事件一样，作为正常事件处理的一部分。&lt;/p&gt;

&lt;p&gt;If you want signals to be delivered truly asynchronously, just use sigaction as you would do without libev and forget about sharing the signal. You can even use ev_async from a signal handler to synchronously wake up an event loop.&lt;br /&gt;
如果你想让信号真正的异步，只有使用sigaction，你这样做不需要libev并且忘记共享信号。你也可以在一个信号处理程序中使用ev_async来同步唤醒一个event loop。&lt;/p&gt;

&lt;p&gt;You can configure as many watchers as you like for the same signal, but only within the same loop, i.e. you can watch for SIGINT in your default loop and for SIGIO in another loop, but you cannot watch for SIGINT in both the default loop and another loop at the same time. At the moment, SIGCHLD is permanently tied to the default loop.&lt;br /&gt;
你可以根据你想要的配置很多watchers监听同一个信号，但是只能在同一个loop之内。即你可以在默认的loop上监听SIGINT，在另外一个loop上肩痛SIGIO，但是你不能同时在默认的loop和另外一个loop上都监听SIGINT，大多数时候，SIGCHLD是一直在默认的loop上的。&lt;/p&gt;

&lt;p&gt;Only after the first watcher for a signal is started will libev actually register something with the kernel. It thus coexists with your own signal handlers as long as you don’t register any with libev for the same signal.&lt;br /&gt;
只有在监听信号的第一个watcher被启动后，libev才实际上在内核中注册了一些东西。只要你没有给同样的信号在libev上注册，它就以这种方式来解决你自己的信号处理函数&lt;/p&gt;

&lt;p&gt;If possible and supported, libev will install its handlers with SA_RESTART (or equivalent) behaviour enabled, so system calls should not be unduly interrupted. If you have a problem with system calls getting interrupted by signals you can block all signals in an ev_check watcher and unblock them in an ev_prepare watcher.&lt;br /&gt;
如果可能并且支持的呼哈，libev将会使用开启SA_RESTART（或者同等效果）的行为来注册它的处理函数，所以系统调用不应该过分中断。如果你有一个关于系统调用造成信号中断的问题，那么你可以在ev_check watcher中阻止所有的在信号，并且在ev_preare watcher中解除阻止。&lt;/p&gt;

&lt;p&gt;The special problem of inheritance over fork/execve/pthread_create&lt;br /&gt;
继承fore/execve/pthread_create的问题&lt;/p&gt;

&lt;p&gt;Both the signal mask (sigprocmask) and the signal disposition (sigaction) are unspecified after starting a signal watcher (and after stopping it again), that is, libev might or might not block the signal, and might or might not set or restore the installed signal handler (but see EVFLAG_NOSIGMASK).&lt;br /&gt;
在启动信号watcher之后（在再一次停止它之后），信号掩码（sigprocmask）和信号处理程序没有被指定，也就是说，libev可能会或者也可能不会阻塞这个信号，并且可能会也可能不会设置或者重新设置信号的处理函数（但是要看EVFLAG_NOSIGMASK参数）。&lt;br /&gt;
PS：在启动信号watcher之后？这句话怎么理解？应该是之前吧？&lt;/p&gt;

&lt;p&gt;While this does not matter for the signal disposition (libev never sets signals to SIG_IGN, so handlers will be reset to SIG_DFL on execve), this matters for the signal mask: many programs do not expect certain signals to be blocked.&lt;br /&gt;
虽然这对于信号处理并不要紧（libev从未设置SIG_IGN信号，所以在execve的时候，处理程序将会被重新设置到SIG_DFL），对于信号掩码重要的是：很多程序不希望某些信号被阻塞住。&lt;/p&gt;

&lt;p&gt;This means that before calling exec (from the child) you should reset the signal mask to whatever “default” you expect (all clear is a good choice usually).&lt;br /&gt;
这意味着，在调用exec之前（从子进程中）你要重新设置信号掩码到你希望的默认状态（通常，把所有的都清除掉是一个好的选择）。&lt;/p&gt;

&lt;p&gt;The simplest way to ensure that the signal mask is reset in the child is to install a fork handler with pthread_atfork that resets it. That will catch fork calls done by libraries (such as the libc) as well.&lt;br /&gt;
这个简单的方法来确保信号掩码是在子进程中被重置的，并且使用pthread_atfork来注册一个fork的处理程序来重置信号掩码。这还不如通过程序库来捕捉fork调用（例如libc）。&lt;/p&gt;

&lt;p&gt;In current versions of libev, the signal will not be blocked indefinitely unless you use the signalfd API (EV_SIGNALFD). While this reduces the window of opportunity for problems, it will not go away, as libev has to modify the signal mask, at least temporarily.&lt;br /&gt;
在当前的libev版本中，信号是不会被无限期的阻塞的，除非你使用signalfd API(EV_SIGNALFD).虽然那这样做拖延了问题的被发现的时机，但是问题不会消失，因为libev可以更改信号掩码，至少目前是这样的。&lt;/p&gt;

&lt;p&gt;So I can’t stress this enough: If you do not reset your signal mask when you expect it to be empty, you have a race condition in your code. This is not a libev-specific thing, this is true for most event libraries.&lt;br /&gt;
所以我不能强调这一点：当你期望你的信号掩码是空的时候，如果你不能重置你的信号掩码，你可以在你的代码中有一个竞争的条件。这不是libev特有的，这对于大多数event库来说都是对的。&lt;/p&gt;

&lt;p&gt;The special problem of threads signal handling&lt;br /&gt;
线程信号处理函数的问题&lt;/p&gt;

&lt;p&gt;POSIX threads has problematic signal handling semantics, specifically, a lot of functionality (sigfd, sigwait etc.) only really works if all threads in a process block signals, which is hard to achieve.&lt;br /&gt;
POSIX线程有有问题的信号处理语义，说明确一些，很多的功能（sigfd sigwait等）只能真正的工作只进程中所有的线程阻塞信号，这是很难实现的。&lt;/p&gt;

&lt;p&gt;When you want to use sigwait (or mix libev signal handling with your own for the same signals), you can tackle this problem by globally blocking all signals before creating any threads (or creating them with a fully set sigprocmask) and also specifying the EVFLAG_NOSIGMASK when creating loops. Then designate one thread as “signal receiver thread” which handles these signals. You can pass on any signals that libev might be interested in by calling ev_feed_signal.&lt;br /&gt;
当你想使用sigwait（或者对于同样的信号混合你自己的libev的信号处理程序），你可以通过在创建任何线程（或者使用一个完全的集合sigprocmask创建它们）之前全局阻塞所有的信号解决这个问题，或者也可以当创建loop时指定EVFLAG_NOSIGMASK参数。然后指定一个线程为“信号接收线程”来处理这些信号。你可以传递任何信号，libev可能通过调用ev_feed_signal对这些信号感兴趣。&lt;/p&gt;

&lt;h4 id=&quot;watcher-specific-functions-and-data-members&quot;&gt;Watcher-Specific Functions and Data Members&lt;/h4&gt;

&lt;h5 id=&quot;ev_signal_init-ev_signal--callback-int-signum&quot;&gt;ev_signal_init (ev_signal *, callback, int signum)&lt;/h5&gt;
&lt;h5 id=&quot;ev_signal_set-ev_signal--int-signum&quot;&gt;ev_signal_set (ev_signal *, int signum)&lt;/h5&gt;
&lt;p&gt;Configures the watcher to trigger on the given signal number (usually one of the SIGxxx constants).&lt;br /&gt;
配置watcher来触发给定的信号&lt;/p&gt;

&lt;h4 id=&quot;int-signum-read-only&quot;&gt;int signum [read-only]&lt;/h4&gt;
&lt;p&gt;The signal the watcher watches out for.&lt;br /&gt;
watcher监听到的信号&lt;/p&gt;

&lt;p&gt;Example: Try to exit cleanly on SIGINT.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void
sigint_cb (struct ev_loop *loop, ev_signal *w, int revents)
{
    ev_break (loop, EVBREAK_ALL);
}

ev_signal signal_watcher;
ev_signal_init (&amp;amp;signal_watcher, sigint_cb, SIGINT);
ev_signal_start (loop, &amp;amp;signal_watcher);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ev_child---watch-out-for-process-status-changes-ev_child-监控进程状态的改变&quot;&gt;ev_child - watch out for process status changes ev_child-监控进程状态的改变&lt;/h3&gt;

&lt;p&gt;Child watchers trigger when your process receives a SIGCHLD in response to some child status changes (most typically when a child of yours dies or exits). It is permissible to install a child watcher after the child has been forked (which implies it might have already exited), as long as the event loop isn’t entered (or is continued from a watcher), i.e., forking and then immediately registering a watcher for the child is fine, but forking and registering a watcher a few event loop iterations later or in the next callback invocation is not.&lt;br /&gt;
当你的进程对于一些子进程状态的改变收到一个SIGCHLD信号的响应时，子进程watcher触发（最典型的是当你的子进程死掉或者退出）。它允许在子进程被fork之后，注册一个子进程的watcher（这意味这它可能已经退出了），只要event loop没有被进入（或者从一个watcher继续循环），即fork子进程然后马上为子进程注册一个watcher的正确的做法，但是fork一个子进程，然后在一些event loop循环迭代后注册一个watcher，或者在下一次的回调函数调用中注册watcher，这些方法是不正确的。&lt;/p&gt;

&lt;p&gt;Only the default event loop is capable of handling signals, and therefore you can only register child watchers in the default event loop.&lt;br /&gt;
只有默认的event loop能处理信号，因此你只能在默认event loop中注册子进程的watcher。&lt;/p&gt;

&lt;p&gt;Due to some design glitches inside libev, child watchers will always be handled at maximum priority (their priority is set to EV_MAXPRI by libev)&lt;br /&gt;
由于libev内部的一些设计问题，子进程的watchers一直被设计成拥有最大的优先级（它们的优先级被libev设置成EV_MAXPRI）。&lt;/p&gt;

&lt;p&gt;Process Interaction&lt;br /&gt;
进程的作用&lt;/p&gt;

&lt;p&gt;Libev grabs SIGCHLD as soon as the default event loop is initialised. This is necessary to guarantee proper behaviour even if the first child watcher is started after the child exits. The occurrence of SIGCHLD is recorded asynchronously, but child reaping is done synchronously as part of the event loop processing. Libev always reaps all children, even ones not watched.&lt;br /&gt;
只要默认的event loop已经被初始化，libev就可以捕获SIGCHLD。
即使第一个子进程watcher在子进程退出后被启动，这对于保证适当的行为也是必须的。SIGHLD的发生被记录是异步的，但是子进程把它作为event loop处理过程的一部分来同步进程。libev一直循环所有的子进程，即使是那些没有被监控的。&lt;/p&gt;

&lt;p&gt;Overriding the Built-In Processing&lt;br /&gt;
覆盖内置的处理&lt;/p&gt;

&lt;p&gt;Libev offers no special support for overriding the built-in child processing, but if your application collides with libev’s default child handler, you can override it easily by installing your own handler for SIGCHLD after initialising the default loop, and making sure the default loop never gets destroyed. You are encouraged, however, to use an event-based approach to child reaping and thus use libev’s support for that, so other libev users can use ev_child watchers freely.&lt;br /&gt;
libev对于覆盖内置的子进程处理，没有提供特殊的支持，但是如果你的应用程序与libev默认的子进程处理函数有冲突，你可以在初始化默认的loop之后给SIGCHLD信号注册你自己的处理函数，从而简单的覆盖它，并且确保默认的loop永远不会被释放。这是被鼓励的，不管怎么样，为了使用一个event-base处理子进程迭代并且因此使用libev支持它，所以另外的libev用户可以自由的使用ev_child wahcter。&lt;/p&gt;

&lt;p&gt;Stopping the Child Watcher&lt;/p&gt;

&lt;p&gt;Currently, the child watcher never gets stopped, even when the child terminates, so normally one needs to stop the watcher in the callback. Future versions of libev might stop the watcher automatically when a child exit is detected (calling ev_child_stop twice is not a problem).&lt;br /&gt;
目前，子进程watcher永远不会停止，即使子进程退出，所以通常需要在回调中停止watcher。libev未来的版本可能会增加当子进程退出时自动停止watcher（调用ev_child_stop两次并不是一个问题）。&lt;/p&gt;

&lt;h4 id=&quot;watcher-specific-functions-and-data-members--watcher-特殊的函数和数据成员&quot;&gt;Watcher-Specific Functions and Data Members  watcher-特殊的函数和数据成员&lt;/h4&gt;

&lt;h5 id=&quot;ev_child_init-ev_child--callback-int-pid-int-trace&quot;&gt;ev_child_init (ev_child *, callback, int pid, int trace)&lt;/h5&gt;
&lt;h5 id=&quot;ev_child_set-ev_child--int-pid-int-trace&quot;&gt;ev_child_set (ev_child *, int pid, int trace)&lt;/h5&gt;
&lt;p&gt;Configures the watcher to wait for status changes of process pid (or any process if pid is specified as 0). The callback can look at the rstatus member of the ev_child watcher structure to see the status word (use the macros from sys/wait.h and see your systems waitpid documentation). The rpid member contains the pid of the process causing the status change. trace must be either 0 (only activate the watcher when the process terminates) or 1 (additionally activate the watcher when the process is stopped or continued).&lt;br /&gt;
配置watcher用来等待进程id为pid的进程改变状态（如果pid为0，监控任意进程）。在回调函数中可以查看ev_child watcher结构的rstatus成员来查看状态消息（使用sys/wat.h中的宏，详细请查看waitpid文档）。rpid成员包括改变状态的pid，trace必须是0（只有当进程退出，watcher是活跃的）或者是1（当进程被停止或者继续的时候额外添加活跃的watcher）。&lt;/p&gt;

&lt;h5 id=&quot;int-pid-read-only&quot;&gt;int pid [read-only]&lt;/h5&gt;
&lt;p&gt;The process id this watcher watches out for, or 0, meaning any process id.&lt;br /&gt;
watcher监控的进程id，如果是0，表示任何进程&lt;/p&gt;

&lt;h5 id=&quot;int-rpid-read-write&quot;&gt;int rpid [read-write]&lt;/h5&gt;
&lt;p&gt;The process id that detected a status change.&lt;br /&gt;
检测到状态发生变化的进程id&lt;/p&gt;

&lt;h5 id=&quot;int-rstatus-read-write&quot;&gt;int rstatus [read-write]&lt;/h5&gt;
&lt;p&gt;The process exit/trace status caused by rpid (see your systems waitpid and sys/wait.h documentation for details).&lt;br /&gt;
通过rpid引起进程退出或者跟踪的状态（详细查看你的系统waitpid和sys/wait.h文档）&lt;/p&gt;

&lt;p&gt;Example: fork() a new process and install a child handler to wait for its completion.&lt;br /&gt;
示例：for一个新的进程，并且注册一个子进程处理函数来等到进程结束。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ev_child cw;

static void
child_cb (EV_P_ ev_child *w, int revents)
{
    ev_child_stop (EV_A_ w);
    printf (&quot;process %d exited with status %x\n&quot;, w-&amp;gt;rpid, w-&amp;gt;rstatus);
}

pid_t pid = fork ();

if (pid &amp;lt; 0)
// error
else if (pid == 0)
{
    // the forked child executes here
    exit (1);
}
else
{
    ev_child_init (&amp;amp;cw, child_cb, pid, 0);
    ev_child_start (EV_DEFAULT_ &amp;amp;cw);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ev_stat---did-the-file-attributes-just-change--ev_stat-就改变了文件属性&quot;&gt;ev_stat - did the file attributes just change?  ev_stat-就改变了文件属性？&lt;/h3&gt;

&lt;p&gt;This watches a file system path for attribute changes. That is, it calls stat on that path in regular intervals (or when the OS says it changed) and sees if it changed compared to the last time, invoking the callback if it did. Starting the watcher stat’s the file, so only changes that happen after the watcher has been started will be reported.&lt;br /&gt;
ev_stat监控文件系统路径的属性变化。相当于在路径上有规律的调用stat来查看是不是和上一次调用stat时的状态不一样了，如果是，那么调用回调函数。启动watcher监控文件，只有在watcher被启动以后熟悉发生改变才会被报告。&lt;/p&gt;

&lt;p&gt;The path does not need to exist: changing from “path exists” to “path does not exist” is a status change like any other. The condition “path does not exist” (or more correctly “path cannot be stat’ed”) is signified by the st_nlink field being zero (which is otherwise always forced to be at least one) and all the other fields of the stat buffer having unspecified contents.&lt;br /&gt;
路径并不需要存在：从路径存在到路径不存在的改变是一种状态的改变，就像其他的改变一样。”路径不存在“的条件（或者更确切的说是”路径不能被stat“）是通过st_nlink字段变成0指定的（换种说法就是一直被迫编程另外一种），并且所有stat buffer另外的字段内容也不确定。&lt;/p&gt;

&lt;p&gt;The path must not end in a slash or contain special components such as . or … The path should be absolute: If it is relative and your working directory changes, then the behaviour is undefined.&lt;br /&gt;
Since there is no portable change notification interface available, the portable implementation simply calls stat(2) regularly on the path to see if it changed somehow. You can specify a recommended polling interval for this case. If you specify a polling interval of 0 (highly recommended!) then a suitable, unspecified default value will be used (which you can expect to be around five seconds, although this might change dynamically). Libev will also impose a minimum interval which is currently around 0.1, but that’s usually overkill.&lt;br /&gt;
路径必须不能一斜线或者特殊字符结束，比如.或者..。路径必须是绝对路径，如果它是相对路径，并且你的工作目录被改变，那么ev_stat的行为就是未定义的。由于没有便捷的改变通知接口可用，所以就简单的在路径上调用stat（2）来实现便捷通知，以达到查看路径是否改变。你可以指定调用stat的时间间隔。如果你把时间间隔设置成0（强烈推荐），那么就使用默认值（默认值大概在5s左右，但是也会动态的改变）。libev支持最小的时间间隔为0.1s，但是这个值经常是太过度了。&lt;/p&gt;

&lt;p&gt;This watcher type is not meant for massive numbers of stat watchers, as even with OS-supported change notifications, this can be resource-intensive.&lt;br /&gt;
这种watcher类型一般不是为了大量的stat watchers考虑的，因为即使使用系统支持的改变通知接口，这也是很耗资源的。&lt;/p&gt;

&lt;p&gt;At the time of this writing, the only OS-specific interface implemented is the Linux inotify interface (implementing kqueue support is left as an exercise for the reader. Note, however, that the author sees no way of implementing ev_stat semantics with kqueue, except as a hint).&lt;br /&gt;
到目前为止，只有linux实现了通知接口（使用kqueue实现一个接口作为读者的一个练习。注意，不管怎么说，作者都觉得不能使用kqueue来实现ev_stat的语义，除非暗地里有变通）。&lt;/p&gt;

&lt;p&gt;ABI Issues (Largefile Support)&lt;br /&gt;
ABI问题（大文件的支持）&lt;/p&gt;

&lt;p&gt;Libev by default (unless the user overrides this) uses the default compilation environment, which means that on systems with large file support disabled by default, you get the 32 bit version of the stat structure. When using the library from programs that change the ABI to use 64 bit file offsets the programs will fail. In that case you have to compile libev with the same flags to get binary compatibility. This is obviously the case with any flags that change the ABI, but the problem is most noticeably displayed with ev_stat and large file support.&lt;br /&gt;
libev在默认情况（除非你改变它）使用默认的编译环境，这意味着在系统上默认的是关闭大文件支持的，你得到的32位的stat结构。当把使用32位程序库的程序改变ABI到使用64位系统时将会失败。这种情况下，你必须使用同样的参数来编译libev以获取二进制的支持。这是显然的情况，使用任何标志来改变ABI，但问题是大多数使用ev_stat和大文件支持的显式的显示。&lt;/p&gt;

&lt;p&gt;The solution for this is to lobby your distribution maker to make large file interfaces available by default (as e.g. FreeBSD does) and not optional. Libev cannot simply switch on large file support because it has to exchange stat structures with application programs compiled using the default compilation environment.&lt;br /&gt;
这个问题的解决方案就是忽悠你的系统发行商默认支持大文件接口可用而不是选用（就像freebsd一样）。libev不能简单的切换大文件支持，因为它要使用默认的编译环境编译应用程序来交换stat结构。&lt;/p&gt;

&lt;p&gt;Inotify and Kqueue&lt;br /&gt;
通知和kqueue&lt;/p&gt;

&lt;p&gt;When inotify (7) support has been compiled into libev and present at runtime, it will be used to speed up change detection where possible. The inotify descriptor will be created lazily when the first ev_stat watcher is being started.&lt;br /&gt;
当支持inotify（7）被编译进libev并且运行，它将被尽可能的用来提升改变侦测的速度。inotify描述符将会在第一个ev_stat watcher开始的时候被惰性的创建。&lt;/p&gt;

&lt;p&gt;Inotify presence does not change the semantics of ev_stat watchers except that changes might be detected earlier, and in some cases, to avoid making regular stat calls. Even in the presence of inotify support there are many cases where libev has to resort to regular stat polling, but as long as kernel 2.6.25 or newer is used (2.6.24 and older have too many bugs), the path exists (i.e. stat succeeds), and the path resides on a local filesystem (libev currently assumes only ext2/3, jfs, reiserfs and xfs are fully working) libev usually gets away without polling.&lt;br /&gt;
inotify的存在并不改变ev_stat watcher的语义，除非改变可能被侦测的更早，并且在某些情况下，避免正常的stat调用。即使在inotify的载体存在有许多的情况下， libev也不得不诉诸定期统计轮询，但是只要内核2.6.25或者更新的被使用（2.6.24或者更老的有很多bug），路径存在（级stat成功），以及路径是本地路径（libev当前支持只有ext2/3，ifs，reiserfs和xfs），libev经常不需要polling就被触发了。&lt;/p&gt;

&lt;p&gt;There is no support for kqueue, as apparently it cannot be used to implement this functionality, due to the requirement of having a file descriptor open on the object at all times, and detecting renames, unlinks etc. is difficult.&lt;br /&gt;
不对kqueue进行支持，显然它不能被用来实现这个功能，，因为在一个对象上打开一个文件描述符，并且重新命名，将解除等的要求是困难的。&lt;/p&gt;

&lt;p&gt;stat () is a synchronous operation&lt;br /&gt;
stat（）是同步操作&lt;/p&gt;

&lt;p&gt;Libev doesn’t normally do any kind of I/O itself, and so is not blocking the process. The exception are ev_stat watchers - those call stat (), which is a synchronous operation.&lt;br /&gt;
libev通常自己不会做任何类型的IO类型，所以不会阻塞进程。唯一的另外是ev_stat watchers-他们调用stat（），这是同步操作。&lt;/p&gt;

&lt;p&gt;For local paths, this usually doesn’t matter: unless the system is very busy or the intervals between stat’s are large, a stat call will be fast, as the path data is usually in memory already (except when starting the watcher).&lt;br /&gt;
对于本地路径，这通常不是那么重要：除非系统非常忙碌或者间隔时间很大，stat调用通常都很快，因为路径的stat数据通常都是已经在内存里面的（除了watcher启动的时候）。&lt;/p&gt;

&lt;p&gt;For networked file systems, calling stat () can block an indefinite time due to network issues, and even under good conditions, a stat call often takes multiple milliseconds.&lt;br /&gt;
对于网络文件系统，调用stat（）可能阻塞一段不定的时间用来处理网络问题，并且即使网络条件不错，一个stat调用通常也要话费掉好几毫秒。&lt;/p&gt;

&lt;p&gt;Therefore, it is best to avoid using ev_stat watchers on networked paths, although this is fully supported by libev.&lt;br /&gt;
因此，最好不要吧ev_stat watchers用在远程路径上，尽管libev完全支持它。&lt;/p&gt;

&lt;p&gt;The special problem of stat time resolution&lt;br /&gt;
stat时间精度的问题&lt;/p&gt;

&lt;p&gt;The stat () system call only supports full-second resolution portably, and even on systems where the resolution is higher, most file systems still only support whole seconds.&lt;br /&gt;
stat（）系统调用仅提供正秒的精度支持，即使系统的精度再高，大多数文件系统仍然只提供正秒的精度支持。&lt;/p&gt;

&lt;p&gt;That means that, if the time is the only thing that changes, you can easily miss updates: on the first update, ev_stat detects a change and calls your callback, which does something. When there is another update within the same second, ev_stat will be unable to detect unless the stat data does change in other ways (e.g. file size).&lt;br /&gt;
这意味着，如果你仅仅改变的是文件的时间，那么你可能很容易就会错过更新：在第一次更新的时候，ev_stat发现了一个改变并且调用你的回调，执行回调函数。当在同一秒再一次更新的时候，ev_stat将不能发现这个时间更新除非用另外一种方法更新了别的stat数据（比如文件大小）。&lt;/p&gt;

&lt;p&gt;The solution to this is to delay acting on a change for slightly more than a second (or till slightly after the next full second boundary), using a roughly one-second-delay ev_timer (e.g. ev_timer_set (w, 0., 1.02); ev_timer_again (loop, w)).&lt;br /&gt;
解决方案就是延迟一秒来更新（或者在一下秒之后），使用一个1秒的ev_timer（例如：ev_timer_set (w, 0., 1.02); ev_timer_again (loop, w)）。&lt;/p&gt;

&lt;p&gt;The .02 offset is added to work around small timing inconsistencies of some operating systems (where the second counter of the current time might be be delayed. One such system is the Linux kernel, where a call to gettimeofday might return a timestamp with a full second later than a subsequent time call - if the equivalent of time () is used to update file times then there will be a small window where the kernel uses the previous second to update file times but libev might already execute the timer callback).&lt;br /&gt;
.02的误差被加进来来解决系统之间的时间误差（当前时间的计数器可能会被延迟。就像linux内核系统，调用gettimeofday可能返回一个正秒时间戳大于紧跟其后的time调用-如果相当于time（）时间被用来更新文件时间，那么将会有一个小的误差窗口，内核会使用前一秒来更新文件时间，但是libev可能已经执行了这个timer的回调了）。&lt;br /&gt;
PS：其实说白了，就是系统时间有误差，所以，需要加一个误差时间来弥补这个误差造成的更新被忽略问题。&lt;/p&gt;

&lt;h4 id=&quot;watcher-specific-functions-and-data-members-watcher-特有的函数和数据成员&quot;&gt;Watcher-Specific Functions and Data Members watcher-特有的函数和数据成员&lt;/h4&gt;

&lt;h5 id=&quot;ev_stat_init-ev_stat--callback-const-char-path-ev_tstamp-interval&quot;&gt;ev_stat_init (ev_stat *, callback, const char *path, ev_tstamp interval)&lt;/h5&gt;
&lt;h5 id=&quot;ev_stat_set-ev_stat--const-char-path-ev_tstamp-interval&quot;&gt;ev_stat_set (ev_stat *, const char *path, ev_tstamp interval)&lt;/h5&gt;
&lt;p&gt;Configures the watcher to wait for status changes of the given path. The interval is a hint on how quickly a change is expected to be detected and should normally be specified as 0 to let libev choose a suitable value. The memory pointed to by path must point to the same path for as long as the watcher is active.&lt;br /&gt;
配置一个watcher来等到给定路径的状态的改变。interval是一个暗示多久发生一个变化被发现，通常指定为0，让libev自己决定这个值。只要watcher是可用的，path都只想一个相同的路径。&lt;/p&gt;

&lt;p&gt;The callback will receive an EV_STAT event when a change was detected, relative to the attributes at the time the watcher was started (or the last change was detected).&lt;br /&gt;
当改变被发现的时候，回调函数将会接收到一个EV_STAT事件。相当于在这个时候对于属性来说，watcher被启动了（或者最后一个变化被检测到）。&lt;/p&gt;

&lt;h5 id=&quot;ev_stat_stat-loop-ev_stat-&quot;&gt;ev_stat_stat (loop, ev_stat *)&lt;/h5&gt;
&lt;p&gt;Updates the stat buffer immediately with new values. If you change the watched path in your callback, you could call this function to avoid detecting this change (while introducing a race condition if you are not the only one changing the path). Can also be useful simply to find out the new values.&lt;br /&gt;
立即获取新的stat数据。如果你在回调函数中更改监控路径，你可以调用这个函数来避免检测到这个变化（如果你不仅仅改变监控的路径，需要引入急诊条件）。也可以简单的获取新的stat值。&lt;/p&gt;

&lt;h5 id=&quot;ev_statdata-attr-read-only&quot;&gt;ev_statdata attr [read-only]&lt;/h5&gt;
&lt;p&gt;The most-recently detected attributes of the file. Although the type is ev_statdata, this is usually the (or one of the) struct stat types suitable for your system, but you can only rely on the POSIX-standardised members to be present. If the st_nlink member is 0, then there was some error while stating the file.&lt;br /&gt;
最近检测到的文件属性。尽管类型是ev_statdata，当这通常都是适合你系统的stat结构数据（或者之一），但是你只能依靠POSIX标准成员来处理。如果st_nlink成员是0，那么检测的文件出现了一些错误。&lt;/p&gt;

&lt;h5 id=&quot;ev_statdata-prev-read-only&quot;&gt;ev_statdata prev [read-only]&lt;/h5&gt;
&lt;p&gt;The previous attributes of the file. The callback gets invoked whenever prev != attr, or, more precisely, one or more of these members differ: st_dev, st_ino, st_mode, st_nlink, st_uid, st_gid, st_rdev, st_size, st_atime, st_mtime, st_ctime.&lt;br /&gt;
文件属性的前一个值。当prev！＝attr的时候，回调函数被调用，或者更正确的说，一个或者多个成员不同的时候：st_dev, st_ino, st_mode, st_nlink, st_uid, st_gid, st_rdev, st_size, st_atime, st_mtime, st_ctime.&lt;/p&gt;

&lt;h5 id=&quot;ev_tstamp-interval-read-only&quot;&gt;ev_tstamp interval [read-only]&lt;/h5&gt;
&lt;p&gt;The specified interval.&lt;br /&gt;
指定时间间隔&lt;/p&gt;

&lt;h5 id=&quot;const-char-path-read-only&quot;&gt;const char *path [read-only]&lt;/h5&gt;
&lt;p&gt;The file system path that is being watched.&lt;br /&gt;
待监控的文件系统路径&lt;/p&gt;

&lt;p&gt;Example: Watch /etc/passwd for attribute changes.&lt;br /&gt;
示例：监控/etc/passwd的属性改变&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void
passwd_cb (struct ev_loop *loop, ev_stat *w, int revents)
{
    /* /etc/passwd changed in some way */
    //改变密码文件
    if (w-&amp;gt;attr.st_nlink)
    {
        printf (&quot;passwd current size  %ld\n&quot;, (long)w-&amp;gt;attr.st_size);
        printf (&quot;passwd current atime %ld\n&quot;, (long)w-&amp;gt;attr.st_mtime);
        printf (&quot;passwd current mtime %ld\n&quot;, (long)w-&amp;gt;attr.st_mtime);
    } else {
        /* you shalt not abuse printf for puts */
        puts (&quot;wow, /etc/passwd is not there, expect problems. &quot;
        &quot;if this is windows, they already arrived\n&quot;);
    }

    ...
    ev_stat passwd;

    ev_stat_init (&amp;amp;passwd, passwd_cb, &quot;/etc/passwd&quot;, 0.);
    ev_stat_start (loop, &amp;amp;passwd);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Example: Like above, but additionally use a one-second delay so we do not miss updates (however, frequent updates will delay processing, too, so one might do the work both on ev_stat callback invocation and on ev_timer callback invocation).&lt;br /&gt;
示例：同上，但是增加使用一个一秒的延迟，所以我们不会错过更新（但是，频繁的更新会延迟处理，因为太多了，所以ev_stat和ev_timer的回调调用都会被调用）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static ev_stat passwd;
static ev_timer timer;

static void
timer_cb (EV_P_ ev_timer *w, int revents)
{
    ev_timer_stop (EV_A_ w);
    /* now it's one second after the most recent passwd change */
}

static void
stat_cb (EV_P_ ev_stat *w, int revents)
{
    /* reset the one-second timer */
    ev_timer_again (EV_A_ &amp;amp;timer);
}

...
ev_stat_init (&amp;amp;passwd, stat_cb, &quot;/etc/passwd&quot;, 0.);
ev_stat_start (loop, &amp;amp;passwd);
ev_timer_init (&amp;amp;timer, timer_cb, 0., 1.02);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ev_idle---when-youve-got-nothing-better-to-do-ev_idle-当你没有什么更好的事情做的时候&quot;&gt;ev_idle - when you’ve got nothing better to do… ev_idle-当你没有什么更好的事情做的时候&lt;/h3&gt;

&lt;p&gt;Idle watchers trigger events when no other events of the same or higher priority are pending (prepare, check and other idle watchers do not count as receiving “events”).
当没有另外的同级别或者更高优先级的事件未触发时，触发Idle事件。&lt;/p&gt;

&lt;p&gt;That is, as long as your process is busy handling sockets or timeouts (or even signals, imagine) of the same or higher priority it will not be triggered. But when your process is idle (or only lower-priority watchers are pending), the idle watchers are being called once per event loop iteration - until stopped, that is, or your process receives more events and becomes busy again with higher priority stuff.&lt;br /&gt;
这就是说，只要你的进程忙于处理同级别或者更高级别的sockets或者timeout（或者信号等）事件，Idle watcher将不会被触发。但是当你的进程处于空闲状态（或者只有低优先级的watchers未被处理），idle watcher将会每次event loop循环被调用一次直到停止，或者你的进程接收到很多事件又再一次被高优先级的事件变的忙碌。&lt;/p&gt;

&lt;p&gt;The most noteworthy effect is that as long as any idle watchers are active, the process will not block when waiting for new events.&lt;br /&gt;
最值得一提的是，只要任何idle watchers是活跃的，那么进程在等待新事件的时候不会阻塞。&lt;/p&gt;

&lt;p&gt;Apart from keeping your process non-blocking (which is a useful effect on its own sometimes), idle watchers are a good place to do “pseudo-background processing”, or delay processing stuff to after the event loop has handled all outstanding events.&lt;br /&gt;
除了保持你的进程非阻塞（在自己的事件上面这是有用的效果），idle watchers是一个做“伪后台”处理的好时候，或者把事件延迟到event loop处理完所有的未解决事件以后在处理。&lt;/p&gt;

&lt;p&gt;Abusing an ev_idle watcher for its side-effect&lt;br /&gt;
滥用ev_idle导致的副作用&lt;br /&gt;
As long as there is at least one active idle watcher, libev will never sleep unnecessarily. Or in other words, it will loop as fast as possible. For this to work, the idle watcher doesn’t need to be invoked at all - the lowest priority will do.&lt;br /&gt;
只要有一个活跃的idle watcher，libev将永远没必要休眠。或者换句话说，libev将尽可能快的循环，为了这个工作，idle watcher是完全没必要被调用的-所以，最小的优先级就可以保证libev无休止循环了。&lt;/p&gt;

&lt;p&gt;This mode of operation can be useful together with an ev_check watcher, to do something on each event loop iteration - for example to balance load between different connections.&lt;br /&gt;
这种模式和ev_check watcher一起使用将是非常有用的，每次循环的时候都做一些事情-比如在不同的连接之间做负载均衡。&lt;/p&gt;

&lt;p&gt;See Abusing an ev_check watcher for its side-effect for a longer example.&lt;br /&gt;
详情请查看滥用ev_check watcher导致副作用的更长的例子。&lt;/p&gt;

&lt;h4 id=&quot;watcher-specific-functions-and-data-members-1&quot;&gt;Watcher-Specific Functions and Data Members&lt;/h4&gt;

&lt;h5 id=&quot;ev_idle_init-ev_idle--callback&quot;&gt;ev_idle_init (ev_idle *, callback)&lt;/h5&gt;
&lt;p&gt;Initialises and configures the idle watcher - it has no parameters of any kind. There is a ev_idle_set macro, but using it is utterly pointless, believe me.&lt;br /&gt;
初始化和配置idle watcher-它没有任何类型的参数，这是一个ev_idle_set宏，但是使用它是毫无意义的，相信我。&lt;/p&gt;

&lt;p&gt;Example: Dynamically allocate an ev_idle watcher, start it, and in the callback, free it. Also, use no error checking, as usual.&lt;br /&gt;
例子：动态的分配一个ev_idle watcher，启动它，并且在回调函数中，释放它。同样，经常不用错误检测。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void
idle_cb (struct ev_loop *loop, ev_idle *w, int revents)
{
    // stop the watcher
    ev_idle_stop (loop, w);
    // now we can free it
    free (w);
    // now do something you wanted to do when the program has
    // no longer anything immediate to do.
}

ev_idle *idle_watcher = malloc (sizeof (ev_idle));
ev_idle_init (idle_watcher, idle_cb);
ev_idle_start (loop, idle_watcher);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ev_prepare-and-ev_check---customise-your-event-loop--ev_prepare和ev_check--自定义你的event-loop&quot;&gt;ev_prepare and ev_check - customise your event loop!  ev_prepare和ev_check  自定义你的event loop&lt;/h3&gt;

&lt;p&gt;Prepare and check watchers are often (but not always) used in pairs: prepare watchers get invoked before the process blocks and check watchers afterwards.&lt;br /&gt;
prepare和check通常（但不是一直）都是成对使用的：prepare watchers在处理块之前（PS：应该是循环loop，调用各个回调函数之前）被调用，check watcer在之后被调用。&lt;/p&gt;

&lt;p&gt;You must not call ev_run (or similar functions that enter the current event loop) or ev_loop_fork from either ev_prepare or ev_check watchers. Other loops than the current one are fine, however. The rationale behind this is that you do not need to check for recursion in those watchers, i.e. the sequence will always be ev_prepare, blocking, ev_check so if you have one watcher of each kind they will always be called in pairs bracketing the blocking call.&lt;br /&gt;
你不能在ev_prepare或者ev_check watchers中调用ev_run（或者能进入当前循环的类似的函数）或者ev_loop_fork。不管怎么说，其他的循环相比当前循环都是好的。这样做的理由是你不需要在另外一些watchers中检查递归了。即，循序一直是ev_prepare，阻塞，ev_check。所以如果你每一种类型都有一个watcher，那么他们将一直成对的被包装在阻塞调用中被调用。&lt;/p&gt;

&lt;p&gt;Their main purpose is to integrate other event mechanisms into libev and their use is somewhat advanced. They could be used, for example, to track variable changes, implement your own watchers, integrate net-snmp or a coroutine library and lots more. They are also occasionally useful if you cache some data and want to flush it before blocking (for example, in X programs you might want to do an XFlush () in an ev_prepare watcher).&lt;br /&gt;
它们的主要目的是集成另外的事件机制到libev中并且他们的用法是稍微有点高级的。他们可以被用来，例如，跟踪变量的变化，实现你自己的watchers，继承net-snmp或者一个协同库，或者更多。如果你想缓存一些数据并且想在阻塞之前刷新到磁盘，那么它们对此也是支持的（例如，在X程序中，你可能想在ev_prepare watcher中做一个XFlush（）操作）。&lt;/p&gt;

&lt;p&gt;This is done by examining in each prepare call which file descriptors need to be watched by the other library, registering ev_io watchers for them and starting an ev_timer watcher for any timeouts (many libraries provide exactly this functionality). Then, in the check watcher, you check for any events that occurred (by checking the pending status of all watchers and stopping them) and call back into the library. The I/O and timer callbacks will never actually be called (but must be valid nevertheless, because you never know, you know?).&lt;br /&gt;
这是通过检查在每一个prepare调用中文件描述符需要被别的程序库监控，为它们注册ev_io watchers ，为了任何的超时，启动一个ev_timer watcher（很多程序库都提供这些功能）。那么，在check watcher中，你检查任何发生的事件（通过检查所有watchers的未处理状态并且停止它们）并且回调到程序库中。IO和定时器事件将事实上永远不会被调用（但是尽管如此，io和timer必须是有效的，因为你永远不知道，你懂的）。&lt;/p&gt;

&lt;p&gt;As another example, the Perl Coro module uses these hooks to integrate coroutines into libev programs, by yielding to other active coroutines during each prepare and only letting the process block if no coroutines are ready to run (it’s actually more complicated: it only runs coroutines with priority higher than or equal to the event loop and one coroutine of lower priority, but only once, using idle watchers to keep the event loop from blocking if lower-priority coroutines are active, thus mapping low-priority coroutines to idle/background tasks).&lt;br /&gt;
另外一个例子，Perl的coro模块使用钩子来继承协程到libev程序中，通过依从另外的活跃协程在每次prepare和如果没有协程准备运行，只让进程阻塞。（这实际上更加复杂：它只能运行协同程序优先高于或等于事件循环和低优先级中的一个协同程序，但仅仅一次，如果低优先级的协程是活跃的，那么使用idle watchers来保证event loop阻塞，从而映射优先级低的协程为空闲/后台任务）。&lt;/p&gt;

&lt;p&gt;When used for this purpose, it is recommended to give ev_check watchers highest (EV_MAXPRI) priority, to ensure that they are being run before any other watchers after the poll (this doesn’t matter for ev_prepare watchers).&lt;br /&gt;
当用来作为这个目的的时候，建议给ev_check watchers最好的优先级（EV_MAXPRI），来确保他们在任何另外的watchers之前和poll之后运行（对于ev_prepare watchers来说无关紧要）。&lt;/p&gt;

&lt;p&gt;Also, ev_check watchers (and ev_prepare watchers, too) should not activate (“feed”) events into libev. While libev fully supports this, they might get executed before other ev_check watchers did their job. As ev_check watchers are often used to embed other (non-libev) event loops those other event loops might be in an unusable state until their ev_check watcher ran (always remind yourself to coexist peacefully with others).&lt;br /&gt;
此外，ev_check watchers（ev_prepare watchers也是如此）应该不会激活事件到libev中，尽管libev完全支持这个功能，他们可能在另外的ev_check watchers被调用之前执行。由于ev_check watchers经常被用来嵌入另外（非libev）的event loop，另外的event loops可能在一个不稳定的状态，知道他们的ev_check watcer运行（总是提醒你自己与他人和平相处）。&lt;/p&gt;

&lt;p&gt;Abusing an ev_check watcher for its side-effect&lt;br /&gt;
ec_check被滥用的副作用&lt;/p&gt;

&lt;p&gt;ev_check (and less often also ev_prepare) watchers can also be useful because they are called once per event loop iteration. For example, if you want to handle a large number of connections fairly, you normally only do a bit of work for each active connection, and if there is more work to do, you wait for the next event loop iteration, so other connections have a chance of making progress.&lt;br /&gt;
ev_check（往往还有ev_prepare）watchers是有用的，因为它们在每次的event loop迭代中都会被调用一次。例如，如果你想公平的处理大量的连接，你通常每个连接只能做一点事情，如果你有更多的事情要做，你必须等待下一次的迭代，所以另外的连接有取得处理的机会。&lt;/p&gt;

&lt;p&gt;Using an ev_check watcher is almost enough: it will be called on the next event loop iteration. However, that isn’t as soon as possible - without external events, your ev_check watcher will not be invoked.&lt;br /&gt;
使用一个ev_check watcher是不够的：它将会在下一次的event loop迭代中被调用。然而，这不是尽可能的-如果没有外部事件，你的ev_check watcher将不会被调用。&lt;/p&gt;

&lt;p&gt;This is where ev_idle watchers come in handy - all you need is a single global idle watcher that is active as long as you have one active ev_check watcher. The ev_idle watcher makes sure the event loop will not sleep, and the ev_check watcher makes sure a callback gets invoked. Neither watcher alone can do that.&lt;br /&gt;
这个时候ev_idle watcher就会派上用场了-，只要你有一个活跃的ev_check，你就需要的是一个全局的活跃的idle watcher。ev_idle watcher确保event loop不需要休眠，ev_check watcher确保函数被调用，任何一个单独的watcher都不能做到这样。&lt;br /&gt;
PS：其实就是说使用ev_idle watcher来带动event loop迭代，从而唤醒ev_prepare和ev_check。&lt;/p&gt;

&lt;h4 id=&quot;watcher-specific-functions-and-data-members-2&quot;&gt;Watcher-Specific Functions and Data Members&lt;/h4&gt;

&lt;h5 id=&quot;ev_prepare_init-ev_prepare--callback&quot;&gt;ev_prepare_init (ev_prepare *, callback)&lt;/h5&gt;
&lt;h5 id=&quot;ev_check_init-ev_check--callback&quot;&gt;ev_check_init (ev_check *, callback)&lt;/h5&gt;
&lt;p&gt;Initialises and configures the prepare or check watcher - they have no parameters of any kind. There are ev_prepare_set and ev_check_set macros, but using them is utterly, utterly, utterly and completely pointless.&lt;br /&gt;
初始化和配置prepare和check watcher-他们没有任何类型的参数。它们只是ev_prepare_set和ev_check_set宏，但是使用他们是完全完全完全没有意义的。&lt;/p&gt;

&lt;p&gt;There are a number of principal ways to embed other event loops or modules into libev. Here are some ideas on how to include libadns into libev (there is a Perl module named EV::ADNS that does this, which you could use as a working example. Another Perl module named EV::Glib embeds a Glib main context into libev, and finally, Glib::EV embeds EV into the Glib event loop).&lt;br /&gt;
有一些嵌入另外的event loops或者模块到libev的主要方法。下面是一些关于怎么把libadns嵌入到libev的方法（perl的EV::ADNS模块就是这么做的，你可以使用它作为一个可以工作的示例。另外一个perl的EV:Glib模块把一个Glib的主要上下文嵌入到libev，最后，Glib::EV嵌入EV到Glib的event loop）。&lt;/p&gt;

&lt;p&gt;Method 1: Add IO watchers and a timeout watcher in a prepare handler, and in a check watcher, destroy them and call into libadns. What follows is pseudo-code only of course. This requires you to either use a low priority for the check watcher or use ev_clear_pending explicitly, as the callbacks for the IO/timeout watchers might not have been called yet.&lt;br /&gt;
方法1：在一个prepare处理事件中加一个IO watcher和timeout watcher，并且在check watcher，释放他们并且调用libadns。下面当然是伪代码，这需要你要么使用一个低优先级的check watcher或者明确使用ev_clear_pending，作为IO/timeout watchers的回调可能不会被调用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static ev_io iow [nfd];
static ev_timer tw;

static void
io_cb (struct ev_loop *loop, ev_io *w, int revents)
{
}

// create io watchers for each fd and a timer before blocking
static void
adns_prepare_cb (struct ev_loop *loop, ev_prepare *w, int revents)
{
    int timeout = 3600000;
    struct pollfd fds [nfd];
    // actual code will need to loop here and realloc etc.
    adns_beforepoll (ads, fds, &amp;amp;nfd, &amp;amp;timeout, timeval_from (ev_time ()));

    /* the callback is illegal, but won't be called as we stop during check */
    ev_timer_init (&amp;amp;tw, 0, timeout * 1e-3, 0.);
    ev_timer_start (loop, &amp;amp;tw);

    // create one ev_io per pollfd
    for (int i = 0; i &amp;lt; nfd; ++i)
    {
        ev_io_init (iow + i, io_cb, fds [i].fd,
        ((fds [i].events &amp;amp; POLLIN ? EV_READ : 0)
        | (fds [i].events &amp;amp; POLLOUT ? EV_WRITE : 0)));

        fds [i].revents = 0;
        ev_io_start (loop, iow + i);
    }
}

// stop all watchers after blocking
static void
adns_check_cb (struct ev_loop *loop, ev_check *w, int revents)
{
    ev_timer_stop (loop, &amp;amp;tw);

    for (int i = 0; i &amp;lt; nfd; ++i)
    {
        // set the relevant poll flags
        // could also call adns_processreadable etc. here
        struct pollfd *fd = fds + i;
        int revents = ev_clear_pending (iow + i);
        if (revents &amp;amp; EV_READ ) fd-&amp;gt;revents |= fd-&amp;gt;events &amp;amp; POLLIN;
        if (revents &amp;amp; EV_WRITE) fd-&amp;gt;revents |= fd-&amp;gt;events &amp;amp; POLLOUT;

        // now stop the watcher
        ev_io_stop (loop, iow + i);
    }

    adns_afterpoll (adns, fds, nfd, timeval_from (ev_now (loop));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Method 2: This would be just like method 1, but you run adns_afterpoll in the prepare watcher and would dispose of the check watcher.&lt;br /&gt;
方法2：和方法i差不多，但是在prepare watcher中运行adns_afterpoll，并且处理check watcher。&lt;/p&gt;

&lt;p&gt;Method 3: If the module to be embedded supports explicit event notification (libadns does), you can also make use of the actual watcher callbacks, and only destroy/create the watchers in the prepare watcher.&lt;br /&gt;
方法3：如果模块被嵌入需要提供显式的通知（libadns就这样做的），你也可以利用实际watcher的回调，并且只在prepare watcher中释放/创建watchers。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void
timer_cb (EV_P_ ev_timer *w, int revents)
{
    adns_state ads = (adns_state)w-&amp;gt;data;
    update_now (EV_A);

    adns_processtimeouts (ads, &amp;amp;tv_now);
}

static void
io_cb (EV_P_ ev_io *w, int revents)
{
    adns_state ads = (adns_state)w-&amp;gt;data;
    update_now (EV_A);

    if (revents &amp;amp; EV_READ ) adns_processreadable  (ads, w-&amp;gt;fd, &amp;amp;tv_now);
    if (revents &amp;amp; EV_WRITE) adns_processwriteable (ads, w-&amp;gt;fd, &amp;amp;tv_now);
}
// do not ever call adns_afterpoll
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Method 4: Do not use a prepare or check watcher because the module you want to embed is not flexible enough to support it. Instead, you can override their poll function. The drawback with this solution is that the main loop is now no longer controllable by EV. The Glib::EV module uses this approach, effectively embedding EV as a client into the horrible libglib event loop.&lt;br /&gt;
方法2：不使用prepare或者check watcher，因为你想嵌入的模块不够灵活的支持他。相反，你可以重写你的poll函数。这种解决方案的缺点是，主loop不能通过EV控制。Glib::EV模块使用这种方法，当客户端进入libglib event loop是，有效的嵌入EV。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static gint
event_poll_func (GPollFD *fds, guint nfds, gint timeout)
{
    int got_events = 0;

    for (n = 0; n &amp;lt; nfds; ++n)
    // create/start io watcher that sets the relevant bits in fds[n] and increment got_events

    if (timeout &amp;gt;= 0)
    // create/start timer

    // poll
    ev_run (EV_A_ 0);

    // stop timer again
    if (timeout &amp;gt;= 0)
    ev_timer_stop (EV_A_ &amp;amp;to);

    // stop io watchers again - their callbacks should have set
    for (n = 0; n &amp;lt; nfds; ++n)
    ev_io_stop (EV_A_ iow [n]);

    return got_events;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ev_embed---when-one-backend-isnt-enough-ev_embed-当一个后台不够用的时候&quot;&gt;ev_embed - when one backend isn’t enough… ev_embed-当一个后台不够用的时候&lt;/h3&gt;

&lt;p&gt;This is a rather advanced watcher type that lets you embed one event loop into another (currently only ev_io events are supported in the embedded loop, other types of watchers might be handled in a delayed or incorrect fashion and must not be used).&lt;br /&gt;
这是一个相当高级的watcher类型，让你可以把一个event loop嵌入到另外一个event loop中（当前，在嵌入的loop中只有ev_io events是获得支持的，别的类型的watchers可能会被延迟处理或者出错，所以不能使用）。&lt;/p&gt;

&lt;p&gt;There are primarily two reasons you would want that: work around bugs and prioritise I/O.&lt;br /&gt;
使用ev_embed的原因主要有2个：解决bug和优先级IO。&lt;/p&gt;

&lt;p&gt;As an example for a bug workaround, the kqueue backend might only support sockets on some platform, so it is unusable as generic backend, but you still want to make use of it because you have many sockets and it scales so nicely. In this case, you would create a kqueue-based loop and embed it into your default loop (which might use e.g. poll). Overall operation will be a bit slower because first libev has to call poll and then kevent, but at least you can use both mechanisms for what they are best: kqueue for scalable sockets and poll if you want it to work :)&lt;br /&gt;
作为一个解决bug的例子，在一些平台上，kqueue只支持sockets，所以它并不是一个通用的后台，但是你仍然想要使用它，因为你有很多的socket要处理并且kqueue处理的很好。在这种情况下，你可以创建一个基于kqueue的loop并且把它嵌入你的默认的loop（默认的loop可能是基于poll的）。总体的操作可能会有一点慢，因为首先libev要调用poll然后才是kevent（应该是queuue的事件吧），但是，至少你可以同时使用2个合适的机制：kqueue处理socket，poll处理你想要它做的事情）。&lt;/p&gt;

&lt;p&gt;As for prioritising I/O: under rare circumstances you have the case where some fds have to be watched and handled very quickly (with low latency), and even priorities and idle watchers might have too much overhead. In this case you would put all the high priority stuff in one loop and all the rest in a second one, and embed the second one in the first.&lt;br /&gt;
至于考虑到优先级的IO：在极少数情况下，你可能介意一些fds被监控和快速的被处理（低延迟的），优先级和idle watchers也可能会有更多的开销。在这种情况下，你可以把一些高优先级的事情放到一个loop中，剩下的放到第二个loop中，然后把第二个嵌入到第一个。&lt;/p&gt;

&lt;p&gt;As long as the watcher is active, the callback will be invoked every time there might be events pending in the embedded loop. The callback must then call ev_embed_sweep (mainloop, watcher) to make a single sweep and invoke their callbacks (the callback doesn’t need to invoke the ev_embed_sweep function directly, it could also start an idle watcher to give the embedded loop strictly lower priority for example).&lt;br /&gt;
只要watcher是活跃的，回调将每次都会被调用，这可能是嵌入loop中的未处理事件。回调必须调用ev_embed_sweep（mainloop，watcher）来做一次扫描并且调用它们的回调（回调不需要立即调用ev_embed_sweep函数，它也可以启动一个idle watcher来给嵌入的loop严格的低优先级）。&lt;/p&gt;

&lt;p&gt;You can also set the callback to 0, in which case the embed watcher will automatically execute the embedded loop sweep whenever necessary.&lt;br /&gt;
你也可以把回调设置成0，这种情况下，embed watcher将会在有必要的情况下自动的执行被嵌入loop的扫描。&lt;/p&gt;

&lt;p&gt;Fork detection will be handled transparently while the ev_embed watcher is active, i.e., the embedded loop will automatically be forked when the embedding loop forks. In other cases, the user is responsible for calling ev_loop_fork on the embedded loop.&lt;br /&gt;
当ev_embed watcher是活跃状态的时候，fork检测将会被透明的处理，即当被嵌入的loop fork时，被嵌入loop将自动的forked。另外一种情况，用户自己负责在被嵌入的loop上调用ev_loop_fork。&lt;/p&gt;

&lt;p&gt;Unfortunately, not all backends are embeddable: only the ones returned by ev_embeddable_backends are, which, unfortunately, does not include any portable one.&lt;br /&gt;
不幸的时，不是所有的后台都可以被嵌入：只有ev_embeddable_backends返回的才可以，这很不幸，不能包括任意的。&lt;/p&gt;

&lt;p&gt;So when you want to use this feature you will always have to be prepared that you cannot get an embeddable loop. The recommended way to get around this is to have a separate variables for your embeddable loop, try to create it, and if that fails, use the normal loop for everything.&lt;br /&gt;
所以当你使用这个功能的时候你得有心理准备：你不能得到一个可以被嵌入的loop。解决这个问题推荐的方法是有一个变量来保存你的被嵌入的loop，试着创建它，如果失败，那么就使用默认的loop。&lt;/p&gt;

&lt;p&gt;ev_embed and fork&lt;/p&gt;

&lt;p&gt;While the ev_embed watcher is running, forks in the embedding loop will automatically be applied to the embedded loop as well, so no special fork handling is required in that case. When the watcher is not running, however, it is still the task of the libev user to call ev_loop_fork () as applicable.&lt;br /&gt;
当ev_embed watcher运行的时候，在被嵌入的loop中forks将会自动的被很好的应用在被嵌入的loop中，所以在这种情况下，不需要特殊的fork来处理。当watcher不在运行的时候，不管怎么样，它仍然是libev用户的任务来调用ev_loop_fork（）。&lt;/p&gt;

&lt;h4 id=&quot;watcher-specific-functions-and-data-members-3&quot;&gt;Watcher-Specific Functions and Data Members&lt;/h4&gt;

&lt;h5 id=&quot;ev_embed_init-ev_embed--callback-struct-ev_loop-embedded_loop&quot;&gt;ev_embed_init (ev_embed *, callback, struct ev_loop *embedded_loop)&lt;/h5&gt;
&lt;h5 id=&quot;ev_embed_set-ev_embed--struct-ev_loop-embedded_loop&quot;&gt;ev_embed_set (ev_embed *, struct ev_loop *embedded_loop)&lt;/h5&gt;
&lt;p&gt;Configures the watcher to embed the given loop, which must be embeddable. If the callback is 0, then ev_embed_sweep will be invoked automatically, otherwise it is the responsibility of the callback to invoke it (it will continue to be called until the sweep has been done, if you do not want that, you need to temporarily stop the embed watcher).&lt;br /&gt;
配置watcher来嵌入到给定的loop，loop必须是被嵌入的。如果回调是0，那么ev_embed_sweep将会自动调用，否则调用的它的责任将是回调的（它将仍然被调用知道扫描被完成，如果你不想这样，你需要暂停被嵌入watcher）。&lt;/p&gt;

&lt;h5 id=&quot;ev_embed_sweep-loop-ev_embed-&quot;&gt;ev_embed_sweep (loop, ev_embed *)&lt;/h5&gt;
&lt;p&gt;Make a single, non-blocking sweep over the embedded loop. This works similarly to ev_run (embedded_loop, EVRUN_NOWAIT), but in the most appropriate way for embedded loops.&lt;br /&gt;
在被嵌入的loop上做一个单一的，非阻塞的扫描。这个工作类似于ev_run（evbedded_loop，EVRUN_NOWAIT），但是是被嵌入loop最合适的方法。&lt;/p&gt;

&lt;h5 id=&quot;struct-ev_loop-other-read-only&quot;&gt;struct ev_loop *other [read-only]&lt;/h5&gt;
&lt;p&gt;The embedded event loop.&lt;/p&gt;

&lt;p&gt;Example: Try to get an embeddable event loop and embed it into the default event loop. If that is not possible, use the default loop. The default loop is stored in loop_hi, while the embeddable loop is stored in loop_lo (which is loop_hi in the case no embeddable loop can be used).&lt;br /&gt;
例子：试着得到一个被嵌入的event loop，并且嵌入它到默认的loop。如果这是不可能的，那就使用默认的loop。默认的loop被保存在loop_hi，而可以嵌入的loop保存在loop_lo（也就是loop_hi在没有嵌入的循环可以使用的情况下）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct ev_loop *loop_hi = ev_default_init (0);
struct ev_loop *loop_lo = 0;
ev_embed embed;

// see if there is a chance of getting one that works
//看看是否有可以得到工作的机会
// (remember that a flags value of 0 means autodetection)
//记住0表示自动检测
loop_lo = ev_embeddable_backends () &amp;amp; ev_recommended_backends ()
? ev_loop_new (ev_embeddable_backends () &amp;amp; ev_recommended_backends ())
: 0;

// if we got one, then embed it, otherwise default to loop_hi
//如果得到一个，就嵌入它，否则就使用默认的。
if (loop_lo)
{
    ev_embed_init (&amp;amp;embed, 0, loop_lo);
    ev_embed_start (loop_hi, &amp;amp;embed);
}
else
loop_lo = loop_hi;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Example: Check if kqueue is available but not recommended and create a kqueue backend for use with sockets (which usually work with any kqueue implementation). Store the kqueue/socket-only event loop in loop_socket. (One might optionally use EVFLAG_NOENV, too).&lt;br /&gt;
例子：检查kqueue是否可用，但是不建议创建一个kqueue后台来给socket使用（这通常适用于任何kqueue实现）。保存kqueue/socket-only event loop在loop——socket中。（也有人可能会选择使用EVFLAG_NOENV）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct ev_loop *loop = ev_default_init (0);
struct ev_loop *loop_socket = 0;
ev_embed embed;

if (ev_supported_backends () &amp;amp; ~ev_recommended_backends () &amp;amp; EVBACKEND_KQUEUE)
    if ((loop_socket = ev_loop_new (EVBACKEND_KQUEUE))
    {
        ev_embed_init (&amp;amp;embed, 0, loop_socket);
        ev_embed_start (loop, &amp;amp;embed);
    }

if (!loop_socket)
    loop_socket = loop;

// now use loop_socket for all sockets, and loop for everything else
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ev_fork---the-audacity-to-resume-the-event-loop-after-a-fork-ev_fork-在fork之后强制恢复event-loop&quot;&gt;ev_fork - the audacity to resume the event loop after a fork ev_fork 在fork之后强制恢复event loop&lt;/h3&gt;

&lt;p&gt;Fork watchers are called when a fork () was detected (usually because whoever is a good citizen cared to tell libev about it by calling ev_loop_fork). The invocation is done before the event loop blocks next and before ev_check watchers are being called, and only in the child after the fork. If whoever good citizen calling ev_default_fork cheats and calls it in the wrong process, the fork handlers will be invoked, too, of course.&lt;br /&gt;
当fork函数被检测到时，fork watcher被调用（通常因为不会在意是那个成员告诉了libev：它调用了ev_loop_fork）。这个调用将在下一次的event loop阻塞之前和ev_check watcher被调用之前，并且只在fork之后的子进程中被调用。不管那个成员在错误的进程中调用ev_default_fork欺骗和调用它，fork处理事件当然也会被调用。&lt;/p&gt;

&lt;p&gt;The special problem of life after fork - how is it possible?&lt;br /&gt;
fork之后生命周期特殊的问题-有哪些可能？&lt;/p&gt;

&lt;p&gt;Most uses of fork () consist of forking, then some simple calls to set up/change the process environment, followed by a call to exec(). This sequence should be handled by libev without any problems.&lt;br /&gt;
大多数使用fork来创建新进程，然后简单的调用一些设置或者改变进程环境，比如接着调用exec函数。这一序列将毫无疑问的被libev处理。&lt;/p&gt;

&lt;p&gt;This changes when the application actually wants to do event handling in the child, or both parent in child, in effect “continuing” after the fork.&lt;br /&gt;
这会在应用程序实际上想在子进程或者父子进程中执行事件处理函数的时候改变，实际上是在fork之后继续。&lt;/p&gt;

&lt;p&gt;The default mode of operation (for libev, with application help to detect forks) is to duplicate all the state in the child, as would be expected when either the parent or the child process continues.&lt;br /&gt;
缺省的操作模式（对于libev来说，应用程序期望检测到forks）是在子进程中复制所有的状态，不管是对于父进程还是子进程来说，都是希望能一如既往。&lt;/p&gt;

&lt;p&gt;When both processes want to continue using libev, then this is usually the wrong result. In that case, usually one process (typically the parent) is supposed to continue with all watchers in place as before, while the other process typically wants to start fresh, i.e. without any active watchers.&lt;br /&gt;
当父子进程都希望继续使用libev，那么这通常都是错误的。在这种情况下，通常一个进程（通常是父进程）还是会和以前一样带着所有的watchers继续执行，同时，另外一个进程执行新的libev，即没有任何活跃的watchers。&lt;/p&gt;

&lt;p&gt;The cleanest and most efficient way to achieve that with libev is to simply create a new event loop, which of course will be “empty”, and use that for new watchers. This has the advantage of not touching more memory than necessary, and thus avoiding the copy-on-write, and the disadvantage of having to use multiple event loops (which do not support signal watchers).&lt;br /&gt;
最简洁和最高效的实现方式是使用libev创建一个新的event loop，新的event loop当然就是”空“的了，并且用新的event loop监听新的watchers。这避免了很多的无必要的内存接触，从而避免了内存的写时复制，并且避免了使用多个event loop的缺点（多个event loop不能对信号watchers提供支持）。&lt;/p&gt;

&lt;p&gt;When this is not possible, or you want to use the default loop for other reasons, then in the process that wants to start “fresh”, call ev_loop_destroy (EV_DEFAULT) followed by ev_default_loop (…). Destroying the default loop will “orphan” (not stop) all registered watchers, so you have to be careful not to execute code that modifies those watchers. Note also that in that case, you have to re-register any signal watchers.&lt;br /&gt;
当这是不可能或者你想要为了别的原因使用默认的loop，比如在进程中以“新鲜”开始，那额在ev_default_loop()之后调用ev_loop_destry。释放默认的loop将“孤立”（而不是停止）所有已注册的watchers，所以你必须小心不要执行源码更改别的watchers。也要注意，在这种情况下，你必须重新注册所有的signal watchers。&lt;/p&gt;

&lt;h4 id=&quot;watcher-specific-functions-and-data-members-4&quot;&gt;Watcher-Specific Functions and Data Members&lt;/h4&gt;

&lt;h5 id=&quot;ev_fork_init-ev_fork--callback&quot;&gt;ev_fork_init (ev_fork *, callback)&lt;/h5&gt;
&lt;p&gt;Initialises and configures the fork watcher - it has no parameters of any kind. There is a ev_fork_set macro, but using it is utterly pointless, really.&lt;br /&gt;
初始化和配置fork watcher-它没有任何类型的参数。这就是一个ev_fork_set宏，但是使用它是毫无意义的，真的。&lt;/p&gt;

&lt;h3 id=&quot;ev_cleanup---even-the-best-things-end-ev_cleanup-在即使最好的东西也结束的时候&quot;&gt;ev_cleanup - even the best things end ev_cleanup-在即使最好的东西也结束的时候&lt;/h3&gt;

&lt;p&gt;Cleanup watchers are called just before the event loop is being destroyed by a call to ev_loop_destroy.&lt;br /&gt;
cleanup watchers将只会在event loop被ev_loop_destroy函数destroy之前被调用。&lt;/p&gt;

&lt;p&gt;While there is no guarantee that the event loop gets destroyed, cleanup watchers provide a convenient method to install cleanup hooks for your program, worker threads and so on - you just to make sure to destroy the loop when you want them to be invoked.&lt;br /&gt;
虽然这不能保证event loop被销毁，清理watchers的所有钩子程序，执行线程等等-你只要确认当你想他们被调用的时候销毁loop。&lt;/p&gt;

&lt;p&gt;Cleanup watchers are invoked in the same way as any other watcher. Unlike all other watchers, they do not keep a reference to the event loop (which makes a lot of sense if you think about it). Like all other watchers, you can call libev functions in the callback, except ev_cleanup_start.&lt;br /&gt;
cleanup wathers和别的watchers使用同样的方法被调用。但是不想另外所有的watchers，他们不会维持和event loop的引用（比如你思考这个问题，它会有很多的意义）。和别的所有的watchers一样，你可以在回调函数中调用libev函数，除了ev_cleanup_start函数之外。&lt;/p&gt;

&lt;h4 id=&quot;watcher-specific-functions-and-data-members-5&quot;&gt;Watcher-Specific Functions and Data Members&lt;/h4&gt;

&lt;h5 id=&quot;ev_cleanup_init-ev_cleanup--callback&quot;&gt;ev_cleanup_init (ev_cleanup *, callback)&lt;/h5&gt;
&lt;p&gt;Initialises and configures the cleanup watcher - it has no parameters of any kind. There is a ev_cleanup_set macro, but using it is utterly pointless, I assure you.&lt;br /&gt;
初始化和配置cleanup watcher-他没有任何类型的参数。这就是一个ev_cleanup_set宏，但是使用它没有意义，我向你保证。&lt;/p&gt;

&lt;p&gt;Example: Register an atexit handler to destroy the default loop, so any cleanup functions are called. &lt;br /&gt;
示例：注册一个atexit处理事件来释放默认的loop，所以任何清理函数被调用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void
program_exits (void)
{
    ev_loop_destroy (EV_DEFAULT_UC);
}

...
atexit (program_exits);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ev_async---how-to-wake-up-an-event-loop-ev_async--怎么唤醒一个event-loop&quot;&gt;ev_async - how to wake up an event loop ev_async -怎么唤醒一个event loop&lt;/h3&gt;

&lt;p&gt;In general, you cannot use an ev_loop from multiple threads or other asynchronous sources such as signal handlers (as opposed to multiple event loops - those are of course safe to use in different threads).&lt;br /&gt;
一般情况下，你不能在多线程或者另外的比如类似于信号事件的异步来源中使用一个ev_loop（在不同的线程中使用不同的event loop，这当然是线程安全的）。&lt;/p&gt;

&lt;p&gt;Sometimes, however, you need to wake up an event loop you do not control, for example because it belongs to another thread. This is what ev_async watchers do: as long as the ev_async watcher is active, you can signal it by calling ev_async_send, which is thread- and signal safe.&lt;br /&gt;
有的时候，不管怎么样，你需要唤醒一个你不能控制的event loop，例如这个event loop属于另外一个线程。这就是ev_sync watcher所能做的：只要ev_async watcher是可用的，你就可以通过调用ev_async_end来唤醒它，并且这是线程和信号安全的。&lt;/p&gt;

&lt;p&gt;This functionality is very similar to ev_signal watchers, as signals, too, are asynchronous in nature, and signals, too, will be compressed (i.e. the number of callback invocations may be less than the number of ev_async_send calls). In fact, you could use signal watchers as a kind of “global async watchers” by using a watcher on an otherwise unused signal, and ev_feed_signal to signal this watcher from another thread, even without knowing which loop owns the signal.&lt;br /&gt;
当处理信号的时候，这个功能非常类似于ev_signal watchers，也有非同步的性质，也会被压缩（即：调用回调的次数可能会少于调用ev_async_send的次数）。事实上，你可以通过在另外一个没有使用的信号上使用一个watcher，来使该signal watcher作为一种全局的异步watchers，然后在另外一个线程中调用ev_feed_signal来唤醒它，即使你不知道哪个looo拥有这个信号。&lt;/p&gt;

&lt;h5 id=&quot;queueing&quot;&gt;Queueing&lt;/h5&gt;

&lt;p&gt;ev_async does not support queueing of data in any way. The reason is that the author does not know of a simple (or any) algorithm for a multiple-writer-single-reader queue that works in all cases and doesn’t need elaborate support such as pthreads or unportable memory access semantics.&lt;br /&gt;
ev_async没有提供任何方式的队列。原因就是作者不知道适应任何情况下的，一个简单的算法来实现多写单读的队列，并且也不需要复杂的提供例如pthread或者不可移植的访问内存语义。&lt;/p&gt;

&lt;p&gt;That means that if you want to queue data, you have to provide your own queue. But at least I can tell you how to implement locking around your queue:&lt;br /&gt;
这就意味着，如果你想排列你的数据，你必须提供你自己的队列。但是至少，我可以告诉你怎么实现你的队列锁。&lt;/p&gt;

&lt;p&gt;queueing from a signal handler context&lt;br /&gt;
排列一个信号处理事件上下文&lt;br /&gt;
To implement race-free queueing, you simply add to the queue in the signal handler but you block the signal handler in the watcher callback. Here is an example that does that for some fictitious SIGUSR1 handler:&lt;br /&gt;
实现一个自由队列，在信号处理函数中加入到队列，在watcher callback中阻塞你的程序，这是一个例子：对SIGUSR1处理函数排队。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static ev_async mysig;

static void
sigusr1_handler (void)
{
    sometype data;

    // no locking etc.
    queue_put (data);
    ev_async_send (EV_DEFAULT_ &amp;amp;mysig);
}

static void
mysig_cb (EV_P_ ev_async *w, int revents)
{
    sometype data;
    sigset_t block, prev;

    sigemptyset (&amp;amp;block);
    sigaddset (&amp;amp;block, SIGUSR1);
    sigprocmask (SIG_BLOCK, &amp;amp;block, &amp;amp;prev);

    while (queue_get (&amp;amp;data))
    process (data);

    if (sigismember (&amp;amp;prev, SIGUSR1)
    sigprocmask (SIG_UNBLOCK, &amp;amp;block, 0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;(Note: pthreads in theory requires you to use pthread_setmask instead of sigprocmask when you use threads, but libev doesn’t do it either…).&lt;br /&gt;
（注意：理论上，当你使用pthreads时，pthread需要使用pthread_setmask来代替sigprocmask，但是libev需要这样做，所以。。。。）。&lt;/p&gt;

&lt;p&gt;queueing from a thread context&lt;br /&gt;
一个线程上下文中排序&lt;br /&gt;
The strategy for threads is different, as you cannot (easily) block threads but you can easily preempt them, so to queue safely you need to employ a traditional mutex lock, such as in this pthread example:&lt;br /&gt;
对于线程，方法是不一样的，因为你不能（轻易）的阻塞线程，但是你可以轻易的抢占他们，所以你需要一个传统的mutex锁，以便排队数据，就像在这个示例一样。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static ev_async mysig;
static pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER;

static void
otherthread (void)
{
    // only need to lock the actual queueing operation
    pthread_mutex_lock (&amp;amp;mymutex);
    queue_put (data);
    pthread_mutex_unlock (&amp;amp;mymutex);

    ev_async_send (EV_DEFAULT_ &amp;amp;mysig);
}

static void
mysig_cb (EV_P_ ev_async *w, int revents)
{
    pthread_mutex_lock (&amp;amp;mymutex);

    while (queue_get (&amp;amp;data))
    process (data);

    pthread_mutex_unlock (&amp;amp;mymutex);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;watcher-specific-functions-and-data-members-6&quot;&gt;Watcher-Specific Functions and Data Members&lt;/h4&gt;

&lt;h5 id=&quot;ev_async_init-ev_async--callback&quot;&gt;ev_async_init (ev_async *, callback)&lt;/h5&gt;
&lt;p&gt;Initialises and configures the async watcher - it has no parameters of any kind. There is a ev_async_set macro, but using it is utterly pointless, trust me.&lt;br /&gt;
初始化和配置async watcher-它没有任何类型的参数。其实就是一个ev_asynv_set宏，但是使用这个宏是没有意义的，相信我。&lt;/p&gt;

&lt;h5 id=&quot;ev_async_send-loop-ev_async-&quot;&gt;ev_async_send (loop, ev_async *)&lt;/h5&gt;
&lt;p&gt;Sends/signals/activates the given ev_async watcher, that is, feeds an EV_ASYNC event on the watcher into the event loop, and instantly returns.&lt;br /&gt;
发送/触发/激活给定的ev_async watcher。即发送一个EV_ASYNC事件到event loop中的watcher，然后立即返回。&lt;/p&gt;

&lt;p&gt;Unlike ev_feed_event, this call is safe to do from other threads, signal or similar contexts (see the discussion of EV_ATOMIC_T in the embedding section below on what exactly this means).&lt;br /&gt;
不像ev_feed_event，从另外的线程中，信号或者类似的环境中调用这个函数是线程安全的（请查阅下面的EV_ATOMIC_T的嵌入部分）。&lt;/p&gt;

&lt;p&gt;Note that, as with other watchers in libev, multiple events might get compressed into a single callback invocation (another way to look at this is that ev_async watchers are level-triggered: they are set on ev_async_send, reset when the event loop detects that).&lt;br /&gt;
注意：和另外的libev中的watcher一样，多个事件可能会被合并成到一个回调中调用（理解这个问题的另外一种是把ev_async看成是水平触发的（PS：结合epoll，kqueue这种理解）：他们在ev_async_send时被触发，并且在event loop检测时被复位）。&lt;/p&gt;

&lt;p&gt;This call incurs the overhead of at most one extra system call per event loop iteration, if the event loop is blocked, and no syscall at all if the event loop (or your program) is processing events. That means that repeated calls are basically free (there is no need to avoid calls for performance reasons) and that the overhead becomes smaller (typically zero) under load.&lt;br /&gt;
这个函数调用最多在每次event loop迭代中在开始引起一个额外的系统调用，如果event loop是被阻塞的，而且如果event loop（或者你的程序）根本没有系统调用处理事件。这意味着重复调用基本上不消耗资源（没有必要为了性能原因限制调用）并且负债开销也会变小（通常为0）。&lt;/p&gt;

&lt;h5 id=&quot;bool--ev_async_pending-ev_async-&quot;&gt;bool = ev_async_pending (ev_async *)&lt;/h5&gt;
&lt;p&gt;Returns a non-zero value when ev_async_send has been called on the watcher but the event has not yet been processed (or even noted) by the event loop.&lt;br /&gt;
返回非0值意味着给定watcher的ev_async_send被调用，但是事件并没有被event loop处理完成。&lt;/p&gt;

&lt;p&gt;ev_async_send sets a flag in the watcher and wakes up the loop. When the loop iterates next and checks for the watcher to have become active, it will reset the flag again. ev_async_pending can be used to very quickly check whether invoking the loop might be a good idea.&lt;br /&gt;
ev_async_send在watcher上设置一个标志并且唤醒loop。当下一次loop迭代并且检查watcher使其变成活跃时，他将会再一次重置他的状态。ev_async_pending可以被当作一个好的方法用来快速的检查是否调用loop。&lt;/p&gt;

&lt;p&gt;Not that this does not check whether the watcher itself is pending, only whether it has been requested to make this watcher pending: there is a time window between the event loop checking and resetting the async notification, and the callback being invoked.&lt;br /&gt;
不是说这不能检查watcher本身是否被挂起，只是检查他是否被请求使这个watcher挂起：这是一个在event loop检查并且重置async通知和回调函数被调用之间的时间窗口，&lt;/p&gt;

&lt;h2 id=&quot;other-functions&quot;&gt;OTHER FUNCTIONS&lt;/h2&gt;

&lt;p&gt;There are some other functions of possible interest. Described. Here. Now.&lt;br /&gt;
这里是一些你可能感兴趣的另外一个功能。&lt;/p&gt;

&lt;h3 id=&quot;ev_once-loop-int-fd-int-events-ev_tstamp-timeout-callback&quot;&gt;ev_once (loop, int fd, int events, ev_tstamp timeout, callback)&lt;/h3&gt;
&lt;p&gt;This function combines a simple timer and an I/O watcher, calls your callback on whichever event happens first and automatically stops both watchers. This is useful if you want to wait for a single event on an fd or timeout without having to allocate/configure/start/stop/free one or more watchers yourself.&lt;br /&gt;
这个函数合并了一个简单的timer watcher和一个IO watcher，哪个watcher先发生，就会自动停止两个watcher，并且调用你的回调函数。这对于你想在一个fd上等到一个IO事件或者超时事件而不用必须自己申请/配置/开始/停止/释放watcher是非常有用的，&lt;/p&gt;

&lt;p&gt;If fd is less than 0, then no I/O watcher will be started and the events argument is being ignored. Otherwise, an ev_io watcher for the given fd and events set will be created and started.&lt;br /&gt;
如果fd小于0，那么将没有IO watcher被启动，并且这个参数将会被忽略。否则对于给定的fd将创建和启动ev_io watcher。&lt;/p&gt;

&lt;p&gt;If timeout is less than 0, then no timeout watcher will be started. Otherwise an ev_timer watcher with after = timeout (and repeat = 0) will be started. 0 is a valid timeout.&lt;br /&gt;
如果timeout小于0，那么没有超时watcher将被启动。否则一个after＝timeout（和repeat ＝ 0）的ev_timer watcher将被启动。0是一个有效的超时。&lt;/p&gt;

&lt;p&gt;The callback has the type void (&lt;em&gt;cb)(int revents, void *arg) and is passed an revents set like normal event callbacks (a combination of EV_ERROR, EV_READ, EV_WRITE or EV_TIMER) and the arg value passed to ev_once. Note that it is possible to receive both a timeout and an io event at the same time - you probably should give io events precedence.&lt;br /&gt;
回调函数的类型是void (&lt;/em&gt;cb)(int revents, void *arg)，并且通过设置一个正确的revents（一个EV_ERROR，EV_READ，EV_WRITE或者EV_TIMER的组合），并且参数arg的值也会传递给ev）once。注意：可能会同时收到超时和IO event-你或许应该给io事件一个高优先级。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Example: wait up to ten seconds for data to appear on STDIN_FILENO.

static void stdin_ready (int revents, void *arg)
{
    if (revents &amp;amp; EV_READ)
    /* stdin might have data for us, joy! */;
    else if (revents &amp;amp; EV_TIMER)
    /* doh, nothing entered */;
}

ev_once (STDIN_FILENO, EV_READ, 10., stdin_ready, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ev_feed_fd_event-loop-int-fd-int-revents&quot;&gt;ev_feed_fd_event (loop, int fd, int revents)&lt;/h3&gt;
&lt;p&gt;Feed an event on the given fd, as if a file descriptor backend detected the given events.&lt;br /&gt;
向给定的fd发送一个事件，就好像文件描述符后台检测到事件一样。&lt;/p&gt;

&lt;h3 id=&quot;ev_feed_signal_event-loop-int-signum&quot;&gt;ev_feed_signal_event (loop, int signum)&lt;/h3&gt;
&lt;p&gt;Feed an event as if the given signal occurred. See also ev_feed_signal, which is async-safe.&lt;br /&gt;
发送一个给定的信号。请查阅ev_feed_signal，这是异步安全的。&lt;/p&gt;

&lt;h2 id=&quot;common-or-useful-idioms-or-both常见或者是习惯用法&quot;&gt;COMMON OR USEFUL IDIOMS (OR BOTH)常见或者是习惯用法&lt;/h2&gt;

&lt;p&gt;This section explains some common idioms that are not immediately obvious. Note that examples are sprinkled over the whole manual, and this section only contains stuff that wouldn’t fit anywhere else.&lt;br /&gt;
本节解释一些不常见的用法。注意：示例对于整个手册来说，本节只包含一些方法，但是不是任何地方都适用。&lt;/p&gt;

&lt;h3 id=&quot;associating-custom-data-with-a-watcher-watcher的自定义数据&quot;&gt;ASSOCIATING CUSTOM DATA WITH A WATCHER watcher的自定义数据&lt;/h3&gt;

&lt;p&gt;Each watcher has, by default, a void *data member that you can read or modify at any time: libev will completely ignore it. This can be used to associate arbitrary data with your watcher. If you need more data and don’t want to allocate memory separately and store a pointer to it in that data member, you can also “subclass” the watcher type and provide your own data:&lt;br /&gt;
每个watcher默认都有一个void *data成员，你可以在任何时候都读写这个成员：libev会完全忽略它。这可用于将任意数据与观察者相关联。如果您需要更多的数据，不希望单独分配内存和存储指向它的数据成员，也可以“继承”的watcher类型，并提供自己的数据：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct my_io
{
    ev_io io;
    int otherfd;
    void *somedata;
    struct whatever *mostinteresting;
};

...
struct my_io w;
ev_io_init (&amp;amp;w.io, my_cb, fd, EV_READ);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And since your callback will be called with a pointer to the watcher, you can cast it back to your own type:&lt;br /&gt;
当你的回调被使用一个watcher指针调用时，你可以把它转换回你自己的类型。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void my_cb (struct ev_loop *loop, ev_io *w_, int revents)
{
    struct my_io *w = (struct my_io *)w_;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;More interesting and less C-conformant ways of casting your callback function type instead have been omitted.&lt;br /&gt;
构造你回调函数类型的更有趣和更小的c一致性方法，而不是忽略它。&lt;/p&gt;

&lt;h3 id=&quot;building-your-own-composite-watchers-构造你自己的watchers组合&quot;&gt;BUILDING YOUR OWN COMPOSITE WATCHERS 构造你自己的watchers组合&lt;/h3&gt;

&lt;p&gt;Another common scenario is to use some data structure with multiple embedded watchers, in effect creating your own watcher that combines multiple libev event sources into one “super-watcher”:&lt;br /&gt;
另外一个常用的方法是使用多个嵌入式的watcher来构成数据结构，实际上就是创建你自己的watcher，它结合了很多libev事件源来组成一个“超级watcher”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct my_biggy
{
    int some_data;
    ev_timer t1;
    ev_timer t2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In this case getting the pointer to my_biggy is a bit more complicated: Either you store the address of your my_biggy struct in the data member of the watcher (for woozies or C++ coders), or you need to use some pointer arithmetic using offsetof inside your watchers (for real programmers):&lt;br /&gt;
这种情况下获取my_biggy的指针是比较麻烦的：一种方法就是在my_biggy的数据成员中保存一个指向my_biggy的地址，另外一个方法就是通过使用offsetof来计算my_biggy的地址（这是真正的程序员做的）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stddef.h&amp;gt;

static void
t1_cb (EV_P_ ev_timer *w, int revents)
{
    struct my_biggy big = (struct my_biggy *)
    (((char *)w) - offsetof (struct my_biggy, t1));
}

static void
t2_cb (EV_P_ ev_timer *w, int revents)
{
    struct my_biggy big = (struct my_biggy *)
    (((char *)w) - offsetof (struct my_biggy, t2));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;avoiding-finishing-before-returning-在返回之前避免结束&quot;&gt;AVOIDING FINISHING BEFORE RETURNING 在返回之前避免结束&lt;/h3&gt;

&lt;p&gt;Often you have structures like this in event-based programs:&lt;br /&gt;
通常在基于事件的程序中，你有这样的结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;callback ()
{
    free (request);
}

request = start_new_request (..., callback);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The intent is to start some “lengthy” operation. The request could be used to cancel the operation, or do other things with it.&lt;br /&gt;
这样做的目的是启动一些“冗长”的操作。这个请求可以用来取消操作，或者做另外的事情。&lt;/p&gt;

&lt;p&gt;It’s not uncommon to have code paths in start_new_request that immediately invoke the callback, for example, to report errors. Or you add some caching layer that finds that it can skip the lengthy aspects of the operation and simply invoke the callback with the result.
在start_new_request中有代码路径立即调用callback，这种情况并不少见。或者你增加一些缓存层来找到它可以跳过冗长的操作面，并且在结果中简单的调用callback。&lt;/p&gt;

&lt;p&gt;The problem here is that this will happen before start_new_request has returned, so request is not set.&lt;br /&gt;
这里的问题是：这将会在start_ne_request返回之前发生，所以请求没有被设置。&lt;/p&gt;

&lt;p&gt;Even if you pass the request by some safer means to the callback, you might want to do something to the request after starting it, such as canceling it, which probably isn’t working so well when the callback has already been invoked.&lt;br /&gt;
即使你安全的传递访问给callback函数，你也想要在启动请求后给它做一些设置，比如取消它，当callback已经被调用额时候，这就可能不能很好的工作了。&lt;/p&gt;

&lt;p&gt;A common way around all these issues is to make sure that start_new_request always returns before the callback is invoked. If start_new_request immediately knows the result, it can artificially delay invoking the callback by using a prepare or idle watcher for example, or more sneakily, by reusing an existing (stopped) watcher and pushing it into the pending queue:&lt;br /&gt;
围绕这些问题的常用方法是确保start_new_request总是返回的回调函数被调用之前。如果start_new_request立即知道结果，可以人为地通过prepare或者idle watcher来延迟调用回调，例如，以上悄悄，通过重新使用现有的（停止）watcher，将其推到未决队列：&lt;/p&gt;

&lt;h3 id=&quot;ev_set_cb-watcher-callback&quot;&gt;ev_set_cb (watcher, callback);&lt;/h3&gt;
&lt;h3 id=&quot;ev_feed_event-ev_a_-watcher-0&quot;&gt;ev_feed_event (EV_A_ watcher, 0);&lt;/h3&gt;

&lt;p&gt;This way, start_new_request can safely return before the callback is invoked, while not delaying callback invocation too much.&lt;br /&gt;
这种方法，start_new_request可以在callback被调用之前安全的返回。而不是拖延回调调用太多。&lt;/p&gt;

&lt;p&gt;MODEL/NESTED EVENT LOOP INVOCATIONS AND EXIT CONDITIONS&lt;br /&gt;
模型/嵌套的event loop调用和退出条件&lt;/p&gt;

&lt;p&gt;Often (especially in GUI toolkits) there are places where you have modal interaction, which is most easily implemented by recursively invoking ev_run.&lt;br /&gt;
通常（特别在GUI工具箱中），&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;以上的翻译已经足够libev使用了下面的翻译有时间再做了&quot;&gt;以上的翻译已经足够libev使用了。下面的翻译有时间再做了！&lt;/h1&gt;

&lt;p&gt;This brings the problem of exiting - a callback might want to finish the main ev_run call, but not the nested one (e.g. user clicked “Quit”, but a modal “Are you sure?” dialog is still waiting), or just the nested one and not the main one (e.g. user clocked “Ok” in a modal dialog), or some other combination: In these cases, a simple ev_break will not work.&lt;/p&gt;

&lt;p&gt;The solution is to maintain “break this loop” variable for each ev_run invocation, and use a loop around ev_run until the condition is triggered, using EVRUN_ONCE:&lt;/p&gt;

&lt;p&gt;// main loop
int exit_main_loop = 0;&lt;/p&gt;

&lt;p&gt;while (!exit_main_loop)
ev_run (EV_DEFAULT_ EVRUN_ONCE);&lt;/p&gt;

&lt;p&gt;// in a modal watcher
int exit_nested_loop = 0;&lt;/p&gt;

&lt;p&gt;while (!exit_nested_loop)
ev_run (EV_A_ EVRUN_ONCE);&lt;/p&gt;

&lt;p&gt;To exit from any of these loops, just set the corresponding exit variable:&lt;/p&gt;

&lt;p&gt;// exit modal loop
exit_nested_loop = 1;&lt;/p&gt;

&lt;p&gt;// exit main program, after modal loop is finished
exit_main_loop = 1;&lt;/p&gt;

&lt;p&gt;// exit both
exit_main_loop = exit_nested_loop = 1;&lt;/p&gt;

&lt;p&gt;THREAD LOCKING EXAMPLE&lt;/p&gt;

&lt;p&gt;Here is a fictitious example of how to run an event loop in a different thread from where callbacks are being invoked and watchers are created/added/removed.&lt;/p&gt;

&lt;p&gt;For a real-world example, see the EV::Loop::Async perl module, which uses exactly this technique (which is suited for many high-level languages).&lt;/p&gt;

&lt;p&gt;The example uses a pthread mutex to protect the loop data, a condition variable to wait for callback invocations, an async watcher to notify the event loop thread and an unspecified mechanism to wake up the main thread.&lt;/p&gt;

&lt;p&gt;First, you need to associate some data with the event loop:&lt;/p&gt;

&lt;p&gt;typedef struct {
mutex_t lock; /* global loop lock */
ev_async async_w;
thread_t tid;
cond_t invoke_cv;
} userdata;&lt;/p&gt;

&lt;p&gt;void prepare_loop (EV_P)
{
// for simplicity, we use a static userdata struct.
static userdata u;&lt;/p&gt;

&lt;p&gt;ev_async_init (&amp;amp;u-&amp;gt;async_w, async_cb);
ev_async_start (EV_A_ &amp;amp;u-&amp;gt;async_w);&lt;/p&gt;

&lt;p&gt;pthread_mutex_init (&amp;amp;u-&amp;gt;lock, 0);
pthread_cond_init (&amp;amp;u-&amp;gt;invoke_cv, 0);&lt;/p&gt;

&lt;p&gt;// now associate this with the loop
ev_set_userdata (EV_A_ u);
ev_set_invoke_pending_cb (EV_A_ l_invoke);
ev_set_loop_release_cb (EV_A_ l_release, l_acquire);&lt;/p&gt;

&lt;p&gt;// then create the thread running ev_run
pthread_create (&amp;amp;u-&amp;gt;tid, 0, l_run, EV_A);
}&lt;/p&gt;

&lt;p&gt;The callback for the ev_async watcher does nothing: the watcher is used solely to wake up the event loop so it takes notice of any new watchers that might have been added:&lt;/p&gt;

&lt;p&gt;static void
async_cb (EV_P_ ev_async *w, int revents)
{
// just used for the side effects
}&lt;/p&gt;

&lt;p&gt;The l_release and l_acquire callbacks simply unlock/lock the mutex protecting the loop data, respectively.&lt;/p&gt;

&lt;p&gt;static void
l_release (EV_P)
{
userdata *u = ev_userdata (EV_A);
pthread_mutex_unlock (&amp;amp;u-&amp;gt;lock);
}&lt;/p&gt;

&lt;p&gt;static void
l_acquire (EV_P)
{
userdata *u = ev_userdata (EV_A);
pthread_mutex_lock (&amp;amp;u-&amp;gt;lock);
}&lt;/p&gt;

&lt;p&gt;The event loop thread first acquires the mutex, and then jumps straight into ev_run:&lt;/p&gt;

&lt;p&gt;void *
l_run (void *thr_arg)
{
struct ev_loop *loop = (struct ev_loop *)thr_arg;&lt;/p&gt;

&lt;p&gt;l_acquire (EV_A);
pthread_setcanceltype (PTHREAD_CANCEL_ASYNCHRONOUS, 0);
ev_run (EV_A_ 0);
l_release (EV_A);&lt;/p&gt;

&lt;p&gt;return 0;
}&lt;/p&gt;

&lt;p&gt;Instead of invoking all pending watchers, the l_invoke callback will signal the main thread via some unspecified mechanism (signals? pipe writes? Async::Interrupt?) and then waits until all pending watchers have been called (in a while loop because a) spurious wakeups are possible and b) skipping inter-thread-communication when there are no pending watchers is very beneficial):&lt;/p&gt;

&lt;p&gt;static void
l_invoke (EV_P)
{
userdata *u = ev_userdata (EV_A);&lt;/p&gt;

&lt;p&gt;while (ev_pending_count (EV_A))
{
wake_up_other_thread_in_some_magic_or_not_so_magic_way ();
pthread_cond_wait (&amp;amp;u-&amp;gt;invoke_cv, &amp;amp;u-&amp;gt;lock);
}
}&lt;/p&gt;

&lt;p&gt;Now, whenever the main thread gets told to invoke pending watchers, it will grab the lock, call ev_invoke_pending and then signal the loop thread to continue:&lt;/p&gt;

&lt;p&gt;static void
real_invoke_pending (EV_P)
{
userdata *u = ev_userdata (EV_A);&lt;/p&gt;

&lt;p&gt;pthread_mutex_lock (&amp;amp;u-&amp;gt;lock);
ev_invoke_pending (EV_A);
pthread_cond_signal (&amp;amp;u-&amp;gt;invoke_cv);
pthread_mutex_unlock (&amp;amp;u-&amp;gt;lock);
}&lt;/p&gt;

&lt;p&gt;Whenever you want to start/stop a watcher or do other modifications to an event loop, you will now have to lock:&lt;/p&gt;

&lt;p&gt;ev_timer timeout_watcher;
userdata *u = ev_userdata (EV_A);&lt;/p&gt;

&lt;p&gt;ev_timer_init (&amp;amp;timeout_watcher, timeout_cb, 5.5, 0.);&lt;/p&gt;

&lt;p&gt;pthread_mutex_lock (&amp;amp;u-&amp;gt;lock);
ev_timer_start (EV_A_ &amp;amp;timeout_watcher);
ev_async_send (EV_A_ &amp;amp;u-&amp;gt;async_w);
pthread_mutex_unlock (&amp;amp;u-&amp;gt;lock);&lt;/p&gt;

&lt;p&gt;Note that sending the ev_async watcher is required because otherwise an event loop currently blocking in the kernel will have no knowledge about the newly added timer. By waking up the loop it will pick up any new watchers in the next event loop iteration.&lt;/p&gt;

&lt;p&gt;THREADS, COROUTINES, CONTINUATIONS, QUEUES… INSTEAD OF CALLBACKS&lt;/p&gt;

&lt;p&gt;While the overhead of a callback that e.g. schedules a thread is small, it is still an overhead. If you embed libev, and your main usage is with some kind of threads or coroutines, you might want to customise libev so that doesn’t need callbacks anymore.&lt;/p&gt;

&lt;p&gt;Imagine you have coroutines that you can switch to using a function switch_to (coro), that libev runs in a coroutine called libev_coro and that due to some magic, the currently active coroutine is stored in a global called current_coro. Then you can build your own “wait for libev event” primitive by changing EV_CB_DECLARE and EV_CB_INVOKE (note the differing ; conventions):&lt;/p&gt;

&lt;p&gt;#define EV_CB_DECLARE(type)   struct my_coro *cb;
#define EV_CB_INVOKE(watcher) switch_to ((watcher)-&amp;gt;cb)&lt;/p&gt;

&lt;p&gt;That means instead of having a C callback function, you store the coroutine to switch to in each watcher, and instead of having libev call your callback, you instead have it switch to that coroutine.&lt;/p&gt;

&lt;p&gt;A coroutine might now wait for an event with a function called wait_for_event. (the watcher needs to be started, as always, but it doesn’t matter when, or whether the watcher is active or not when this function is called):&lt;/p&gt;

&lt;p&gt;void
wait_for_event (ev_watcher *w)
{
ev_set_cb (w, current_coro);
switch_to (libev_coro);
}&lt;/p&gt;

&lt;p&gt;That basically suspends the coroutine inside wait_for_event and continues the libev coroutine, which, when appropriate, switches back to this or any other coroutine.&lt;/p&gt;

&lt;p&gt;You can do similar tricks if you have, say, threads with an event queue - instead of storing a coroutine, you store the queue object and instead of switching to a coroutine, you push the watcher onto the queue and notify any waiters.&lt;/p&gt;

&lt;p&gt;To embed libev, see EMBEDDING, but in short, it’s easiest to create two files, my_ev.h and my_ev.c that include the respective libev files:&lt;/p&gt;

&lt;p&gt;// my_ev.h
#define EV_CB_DECLARE(type)   struct my_coro *cb;
#define EV_CB_INVOKE(watcher) switch_to ((watcher)-&amp;gt;cb);
#include “../libev/ev.h”&lt;/p&gt;

&lt;p&gt;// my_ev.c
#define EV_H “my_ev.h”
#include “../libev/ev.c”&lt;/p&gt;

&lt;p&gt;And then use my_ev.h when you would normally use ev.h, and compile my_ev.c into your project. When properly specifying include paths, you can even use ev.h as header file name directly.&lt;/p&gt;

&lt;p&gt;LIBEVENT EMULATION&lt;/p&gt;

&lt;p&gt;Libev offers a compatibility emulation layer for libevent. It cannot emulate the internals of libevent, so here are some usage hints:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Only the libevent-1.4.1-beta API is being emulated.
  This was the newest libevent version available when libev was implemented, and is still mostly unchanged in 2010.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Use it by including &lt;event.h&gt;, as usual.&lt;/event.h&gt;&lt;/li&gt;
  &lt;li&gt;The following members are fully supported: ev_base, ev_callback, ev_arg, ev_fd, ev_res, ev_events.&lt;/li&gt;
  &lt;li&gt;Avoid using ev_flags and the EVLIST_*-macros, while it is maintained by libev, it does not work exactly the same way as in libevent (consider it a private API).&lt;/li&gt;
  &lt;li&gt;Priorities are not currently supported. Initialising priorities will fail and all watchers will have the same priority, even though there is an ev_pri field.&lt;/li&gt;
  &lt;li&gt;In libevent, the last base created gets the signals, in libev, the base that registered the signal gets the signals.&lt;/li&gt;
  &lt;li&gt;Other members are not supported.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The libev emulation is not ABI compatible to libevent, you need to use the libev header file and library.
  C++ SUPPORT&lt;/p&gt;

    &lt;p&gt;C API&lt;/p&gt;

    &lt;p&gt;The normal C API should work fine when used from C++: both ev.h and the libev sources can be compiled as C++. Therefore, code that uses the C API will work fine.&lt;/p&gt;

    &lt;p&gt;Proper exception specifications might have to be added to callbacks passed to libev: exceptions may be thrown only from watcher callbacks, all other callbacks (allocator, syserr, loop acquire/release and periodic reschedule callbacks) must not throw exceptions, and might need a throw () specification. If you have code that needs to be compiled as both C and C++ you can use the EV_THROW macro for this:&lt;/p&gt;

    &lt;p&gt;static void
  fatal_error (const char *msg) EV_THROW
  {
  perror (msg);
  abort ();
  }&lt;/p&gt;

    &lt;p&gt;…
  ev_set_syserr_cb (fatal_error);&lt;/p&gt;

    &lt;p&gt;The only API functions that can currently throw exceptions are ev_run, ev_invoke, ev_invoke_pending and ev_loop_destroy (the latter because it runs cleanup watchers).&lt;/p&gt;

    &lt;p&gt;Throwing exceptions in watcher callbacks is only supported if libev itself is compiled with a C++ compiler or your C and C++ environments allow throwing exceptions through C libraries (most do).&lt;/p&gt;

    &lt;p&gt;C++ API&lt;/p&gt;

    &lt;p&gt;Libev comes with some simplistic wrapper classes for C++ that mainly allow you to use some convenience methods to start/stop watchers and also change the callback model to a model using method callbacks on objects.&lt;/p&gt;

    &lt;p&gt;To use it,&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#include &amp;lt;ev++.h&amp;gt;&lt;/p&gt;

&lt;p&gt;This automatically includes ev.h and puts all of its definitions (many of them macros) into the global namespace. All C++ specific things are put into the ev namespace. It should support all the same embedding options as ev.h, most notably EV_MULTIPLICITY.&lt;/p&gt;

&lt;p&gt;Care has been taken to keep the overhead low. The only data member the C++ classes add (compared to plain C-style watchers) is the event loop pointer that the watcher is associated with (or no additional members at all if you disable EV_MULTIPLICITY when embedding libev).&lt;/p&gt;

&lt;p&gt;Currently, functions, static and non-static member functions and classes with operator () can be used as callbacks. Other types should be easy to add as long as they only need one additional pointer for context. If you need support for other types of functors please contact the author (preferably after implementing it).&lt;/p&gt;

&lt;p&gt;For all this to work, your C++ compiler either has to use the same calling conventions as your C compiler (for static member functions), or you have to embed libev and compile libev itself as C++.&lt;/p&gt;

&lt;p&gt;Here is a list of things available in the ev namespace:&lt;/p&gt;

&lt;p&gt;ev::READ, ev::WRITE etc.
These are just enum values with the same values as the EV_READ etc. macros from ev.h.&lt;/p&gt;

&lt;p&gt;ev::tstamp, ev::now
Aliases to the same types/functions as with the ev_ prefix.&lt;/p&gt;

&lt;p&gt;ev::io, ev::timer, ev::periodic, ev::idle, ev::sig etc.
For each ev_TYPE watcher in ev.h there is a corresponding class of the same name in the ev namespace, with the exception of ev_signal which is called ev::sig to avoid clashes with the signal macro defined by many implementations.&lt;/p&gt;

&lt;p&gt;All of those classes have these methods:&lt;/p&gt;

&lt;p&gt;ev::TYPE::TYPE ()
ev::TYPE::TYPE (loop)
ev::TYPE::~TYPE
The constructor (optionally) takes an event loop to associate the watcher with. If it is omitted, it will use EV_DEFAULT.&lt;/p&gt;

&lt;p&gt;The constructor calls ev_init for you, which means you have to call the set method before starting it.&lt;/p&gt;

&lt;p&gt;It will not set a callback, however: You have to call the templated set method to set a callback before you can start the watcher.&lt;/p&gt;

&lt;p&gt;(The reason why you have to use a method is a limitation in C++ which does not allow explicit template arguments for constructors).&lt;/p&gt;

&lt;p&gt;The destructor automatically stops the watcher if it is active.&lt;/p&gt;

&lt;p&gt;w-&amp;gt;set&amp;lt;class, &amp;amp;class::method&amp;gt; (object &lt;em&gt;)
This method sets the callback method to call. The method has to have a signature of void (&lt;/em&gt;)(ev_TYPE &amp;amp;, int), it receives the watcher as first argument and the revents as second. The object must be given as parameter and is stored in the data member of the watcher.&lt;/p&gt;

&lt;p&gt;This method synthesizes efficient thunking code to call your method from the C callback that libev requires. If your compiler can inline your callback (i.e. it is visible to it at the place of the set call and your compiler is good :), then the method will be fully inlined into the thunking function, making it as fast as a direct C callback.&lt;/p&gt;

&lt;p&gt;Example: simple class declaration and watcher initialisation&lt;/p&gt;

&lt;p&gt;struct myclass
{
void io_cb (ev::io &amp;amp;w, int revents) { }
}&lt;/p&gt;

&lt;p&gt;myclass obj;
ev::io iow;
iow.set &amp;lt;myclass, &amp;amp;myclass::io_cb&amp;gt; (&amp;amp;obj);&lt;/p&gt;

&lt;p&gt;w-&amp;gt;set (object *)
This is a variation of a method callback - leaving out the method to call will default the method to operator (), which makes it possible to use functor objects without having to manually specify the operator () all the time. Incidentally, you can then also leave out the template argument list.&lt;/p&gt;

&lt;p&gt;The operator () method prototype must be void operator ()(watcher &amp;amp;w, int revents).&lt;/p&gt;

&lt;p&gt;See the method-set above for more details.&lt;/p&gt;

&lt;p&gt;Example: use a functor object as callback.&lt;/p&gt;

&lt;p&gt;struct myfunctor
{
void operator() (ev::io &amp;amp;w, int revents)
{
…
}
}&lt;/p&gt;

&lt;p&gt;myfunctor f;&lt;/p&gt;

&lt;p&gt;ev::io w;
w.set (&amp;amp;f);&lt;/p&gt;

&lt;p&gt;w-&amp;gt;set&lt;function&gt; (void *data = 0)
Also sets a callback, but uses a static method or plain function as callback. The optional data argument will be stored in the watcher's data member and is free for you to use.&lt;/function&gt;&lt;/p&gt;

&lt;p&gt;The prototype of the function must be void (*)(ev::TYPE &amp;amp;w, int).&lt;/p&gt;

&lt;p&gt;See the method-set above for more details.&lt;/p&gt;

&lt;p&gt;Example: Use a plain function as callback.&lt;/p&gt;

&lt;p&gt;static void io_cb (ev::io &amp;amp;w, int revents) { }
iow.set &lt;io_cb&gt; ();&lt;/io_cb&gt;&lt;/p&gt;

&lt;p&gt;w-&amp;gt;set (loop)
Associates a different struct ev_loop with this watcher. You can only do this when the watcher is inactive (and not pending either).&lt;/p&gt;

&lt;p&gt;w-&amp;gt;set ([arguments])
Basically the same as ev_TYPE_set (except for ev::embed watchers&amp;gt;), with the same arguments. Either this method or a suitable start method must be called at least once. Unlike the C counterpart, an active watcher gets automatically stopped and restarted when reconfiguring it with this method.&lt;/p&gt;

&lt;p&gt;For ev::embed watchers this method is called set_embed, to avoid clashing with the set (loop) method.&lt;/p&gt;

&lt;p&gt;w-&amp;gt;start ()
Starts the watcher. Note that there is no loop argument, as the constructor already stores the event loop.&lt;/p&gt;

&lt;p&gt;w-&amp;gt;start ([arguments])
Instead of calling set and start methods separately, it is often convenient to wrap them in one call. Uses the same type of arguments as the configure set method of the watcher.&lt;/p&gt;

&lt;p&gt;w-&amp;gt;stop ()
Stops the watcher if it is active. Again, no loop argument.&lt;/p&gt;

&lt;p&gt;w-&amp;gt;again () (ev::timer, ev::periodic only)
For ev::timer and ev::periodic, this invokes the corresponding ev_TYPE_again function.&lt;/p&gt;

&lt;p&gt;w-&amp;gt;sweep () (ev::embed only)
Invokes ev_embed_sweep.&lt;/p&gt;

&lt;p&gt;w-&amp;gt;update () (ev::stat only)
Invokes ev_stat_stat.&lt;/p&gt;

&lt;p&gt;Example: Define a class with two I/O and idle watchers, start the I/O watchers in the constructor.&lt;/p&gt;

&lt;p&gt;class myclass
{
ev::io   io  ; void io_cb   (ev::io   &amp;amp;w, int revents);
ev::io   io2 ; void io2_cb  (ev::io   &amp;amp;w, int revents);
ev::idle idle; void idle_cb (ev::idle &amp;amp;w, int revents);&lt;/p&gt;

&lt;p&gt;myclass (int fd)
{
io  .set &amp;lt;myclass, &amp;amp;myclass::io_cb  &amp;gt; (this);
io2 .set &amp;lt;myclass, &amp;amp;myclass::io2_cb &amp;gt; (this);
idle.set &amp;lt;myclass, &amp;amp;myclass::idle_cb&amp;gt; (this);&lt;/p&gt;

&lt;p&gt;io.set (fd, ev::WRITE); // configure the watcher
io.start ();            // start it whenever convenient&lt;/p&gt;

&lt;p&gt;io2.start (fd, ev::READ); // set + start in one call
}
};&lt;/p&gt;

&lt;p&gt;OTHER LANGUAGE BINDINGS&lt;/p&gt;

&lt;p&gt;Libev does not offer other language bindings itself, but bindings for a number of languages exist in the form of third-party packages. If you know any interesting language binding in addition to the ones listed here, drop me a note.&lt;/p&gt;

&lt;p&gt;Perl
The EV module implements the full libev API and is actually used to test libev. EV is developed together with libev. Apart from the EV core module, there are additional modules that implement libev-compatible interfaces to libadns (EV::ADNS, but AnyEvent::DNS is preferred nowadays), Net::SNMP (Net::SNMP::EV) and the libglib event core (Glib::EV and EV::Glib).&lt;/p&gt;

&lt;p&gt;It can be found and installed via CPAN, its homepage is at http://software.schmorp.de/pkg/EV.&lt;/p&gt;

&lt;p&gt;Python
Python bindings can be found at http://code.google.com/p/pyev/. It seems to be quite complete and well-documented.&lt;/p&gt;

&lt;p&gt;Ruby
Tony Arcieri has written a ruby extension that offers access to a subset of the libev API and adds file handle abstractions, asynchronous DNS and more on top of it. It can be found via gem servers. Its homepage is at http://rev.rubyforge.org/.&lt;/p&gt;

&lt;p&gt;Roger Pack reports that using the link order -lws2_32 -lmsvcrt-ruby-190 makes rev work even on mingw.&lt;/p&gt;

&lt;p&gt;Haskell
A haskell binding to libev is available at http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hlibev.&lt;/p&gt;

&lt;p&gt;D
Leandro Lucarella has written a D language binding (ev.d) for libev, to be found at http://www.llucax.com.ar/proj/ev.d/index.html.&lt;/p&gt;

&lt;p&gt;Ocaml
Erkki Seppala has written Ocaml bindings for libev, to be found at http://modeemi.cs.tut.fi/~flux/software/ocaml-ev/.&lt;/p&gt;

&lt;p&gt;Lua
Brian Maher has written a partial interface to libev for lua (at the time of this writing, only ev_io and ev_timer), to be found at http://github.com/brimworks/lua-ev.&lt;/p&gt;

&lt;p&gt;Javascript
Node.js (http://nodejs.org) uses libev as the underlying event library.&lt;/p&gt;

&lt;p&gt;Others
There are others, and I stopped counting.&lt;/p&gt;

&lt;p&gt;MACRO MAGIC&lt;/p&gt;

&lt;p&gt;Libev can be compiled with a variety of options, the most fundamental of which is EV_MULTIPLICITY. This option determines whether (most) functions and callbacks have an initial struct ev_loop * argument.&lt;/p&gt;

&lt;p&gt;To make it easier to write programs that cope with either variant, the following macros are defined:&lt;/p&gt;

&lt;p&gt;EV_A, EV_A_
This provides the loop argument for functions, if one is required (“ev loop argument”). The EV_A form is used when this is the sole argument, EV_A_ is used when other arguments are following. Example:&lt;/p&gt;

&lt;p&gt;ev_unref (EV_A);
ev_timer_add (EV_A_ watcher);
ev_run (EV_A_ 0);&lt;/p&gt;

&lt;p&gt;It assumes the variable loop of type struct ev_loop * is in scope, which is often provided by the following macro.&lt;/p&gt;

&lt;p&gt;EV_P, EV_P_
This provides the loop parameter for functions, if one is required (“ev loop parameter”). The EV_P form is used when this is the sole parameter, EV_P_ is used when other parameters are following. Example:&lt;/p&gt;

&lt;p&gt;// this is how ev_unref is being declared
static void ev_unref (EV_P);&lt;/p&gt;

&lt;p&gt;// this is how you can declare your typical callback
static void cb (EV_P_ ev_timer *w, int revents)&lt;/p&gt;

&lt;p&gt;It declares a parameter loop of type struct ev_loop *, quite suitable for use with EV_A.&lt;/p&gt;

&lt;p&gt;EV_DEFAULT, EV_DEFAULT_
Similar to the other two macros, this gives you the value of the default loop, if multiple loops are supported (“ev loop default”). The default loop will be initialised if it isn’t already initialised.&lt;/p&gt;

&lt;p&gt;For non-multiplicity builds, these macros do nothing, so you always have to initialise the loop somewhere.&lt;/p&gt;

&lt;p&gt;EV_DEFAULT_UC, EV_DEFAULT_UC_
Usage identical to EV_DEFAULT and EV_DEFAULT_, but requires that the default loop has been initialised (UC == unchecked). Their behaviour is undefined when the default loop has not been initialised by a previous execution of EV_DEFAULT, EV_DEFAULT_ or ev_default_init (…).&lt;/p&gt;

&lt;p&gt;It is often prudent to use EV_DEFAULT when initialising the first watcher in a function but use EV_DEFAULT_UC afterwards.&lt;/p&gt;

&lt;p&gt;Example: Declare and initialise a check watcher, utilising the above macros so it will work regardless of whether multiple loops are supported or not.&lt;/p&gt;

&lt;p&gt;static void
check_cb (EV_P_ ev_timer *w, int revents)
{
ev_check_stop (EV_A_ w);
}&lt;/p&gt;

&lt;p&gt;ev_check check;
ev_check_init (&amp;amp;check, check_cb);
ev_check_start (EV_DEFAULT_ &amp;amp;check);
ev_run (EV_DEFAULT_ 0);&lt;/p&gt;

&lt;p&gt;EMBEDDING&lt;/p&gt;

&lt;p&gt;Libev can (and often is) directly embedded into host applications. Examples of applications that embed it include the Deliantra Game Server, the EV perl module, the GNU Virtual Private Ethernet (gvpe) and rxvt-unicode.&lt;/p&gt;

&lt;p&gt;The goal is to enable you to just copy the necessary files into your source directory without having to change even a single line in them, so you can easily upgrade by simply copying (or having a checked-out copy of libev somewhere in your source tree).&lt;/p&gt;

&lt;p&gt;FILESETS&lt;/p&gt;

&lt;p&gt;Depending on what features you need you need to include one or more sets of files in your application.&lt;/p&gt;

&lt;p&gt;CORE EVENT LOOP&lt;/p&gt;

&lt;p&gt;To include only the libev core (all the ev_* functions), with manual configuration (no autoconf):&lt;/p&gt;

&lt;p&gt;#define EV_STANDALONE 1
#include “ev.c”&lt;/p&gt;

&lt;p&gt;This will automatically include ev.h, too, and should be done in a single C source file only to provide the function implementations. To use it, do the same for ev.h in all files wishing to use this API (best done by writing a wrapper around ev.h that you can include instead and where you can put other configuration options):&lt;/p&gt;

&lt;p&gt;#define EV_STANDALONE 1
#include “ev.h”&lt;/p&gt;

&lt;p&gt;Both header files and implementation files can be compiled with a C++ compiler (at least, that’s a stated goal, and breakage will be treated as a bug).&lt;/p&gt;

&lt;p&gt;You need the following files in your source tree, or in a directory in your include path (e.g. in libev/ when using -Ilibev):&lt;/p&gt;

&lt;p&gt;ev.h
ev.c
ev_vars.h
ev_wrap.h&lt;/p&gt;

&lt;p&gt;ev_win32.c      required on win32 platforms only&lt;/p&gt;

&lt;p&gt;ev_select.c     only when select backend is enabled (which is enabled by default)
ev_poll.c       only when poll backend is enabled (disabled by default)
ev_epoll.c      only when the epoll backend is enabled (disabled by default)
ev_kqueue.c     only when the kqueue backend is enabled (disabled by default)
ev_port.c       only when the solaris port backend is enabled (disabled by default)&lt;/p&gt;

&lt;p&gt;ev.c includes the backend files directly when enabled, so you only need to compile this single file.&lt;/p&gt;

&lt;p&gt;LIBEVENT COMPATIBILITY API&lt;/p&gt;

&lt;p&gt;To include the libevent compatibility API, also include:&lt;/p&gt;

&lt;p&gt;#include “event.c”&lt;/p&gt;

&lt;p&gt;in the file including ev.c, and:&lt;/p&gt;

&lt;p&gt;#include “event.h”&lt;/p&gt;

&lt;p&gt;in the files that want to use the libevent API. This also includes ev.h.&lt;/p&gt;

&lt;p&gt;You need the following additional files for this:&lt;/p&gt;

&lt;p&gt;event.h
event.c&lt;/p&gt;

&lt;p&gt;AUTOCONF SUPPORT&lt;/p&gt;

&lt;p&gt;Instead of using EV_STANDALONE=1 and providing your configuration in whatever way you want, you can also m4_include([libev.m4]) in your configure.ac and leave EV_STANDALONE undefined. ev.c will then include config.h and configure itself accordingly.&lt;/p&gt;

&lt;p&gt;For this of course you need the m4 file:&lt;/p&gt;

&lt;p&gt;libev.m4&lt;/p&gt;

&lt;p&gt;PREPROCESSOR SYMBOLS/MACROS&lt;/p&gt;

&lt;p&gt;Libev can be configured via a variety of preprocessor symbols you have to define before including (or compiling) any of its files. The default in the absence of autoconf is documented for every option.&lt;/p&gt;

&lt;p&gt;Symbols marked with “(h)” do not change the ABI, and can have different values when compiling libev vs. including ev.h, so it is permissible to redefine them before including ev.h without breaking compatibility to a compiled library. All other symbols change the ABI, which means all users of libev and the libev code itself must be compiled with compatible settings.&lt;/p&gt;

&lt;p&gt;EV_COMPAT3 (h)
Backwards compatibility is a major concern for libev. This is why this release of libev comes with wrappers for the functions and symbols that have been renamed between libev version 3 and 4.&lt;/p&gt;

&lt;p&gt;You can disable these wrappers (to test compatibility with future versions) by defining EV_COMPAT3 to 0 when compiling your sources. This has the additional advantage that you can drop the struct from struct ev_loop declarations, as libev will provide an ev_loop typedef in that case.&lt;/p&gt;

&lt;p&gt;In some future version, the default for EV_COMPAT3 will become 0, and in some even more future version the compatibility code will be removed completely.&lt;/p&gt;

&lt;p&gt;EV_STANDALONE (h)
Must always be 1 if you do not use autoconf configuration, which keeps libev from including config.h, and it also defines dummy implementations for some libevent functions (such as logging, which is not supported). It will also not define any of the structs usually found in event.h that are not directly supported by the libev core alone.&lt;/p&gt;

&lt;p&gt;In standalone mode, libev will still try to automatically deduce the configuration, but has to be more conservative.&lt;/p&gt;

&lt;p&gt;EV_USE_FLOOR
If defined to be 1, libev will use the floor () function for its periodic reschedule calculations, otherwise libev will fall back on a portable (slower) implementation. If you enable this, you usually have to link against libm or something equivalent. Enabling this when the floor function is not available will fail, so the safe default is to not enable this.&lt;/p&gt;

&lt;p&gt;EV_USE_MONOTONIC
If defined to be 1, libev will try to detect the availability of the monotonic clock option at both compile time and runtime. Otherwise no use of the monotonic clock option will be attempted. If you enable this, you usually have to link against librt or something similar. Enabling it when the functionality isn’t available is safe, though, although you have to make sure you link against any libraries where the clock_gettime function is hiding in (often -lrt). See also EV_USE_CLOCK_SYSCALL.&lt;/p&gt;

&lt;p&gt;EV_USE_REALTIME
If defined to be 1, libev will try to detect the availability of the real-time clock option at compile time (and assume its availability at runtime if successful). Otherwise no use of the real-time clock option will be attempted. This effectively replaces gettimeofday by clock_get (CLOCK_REALTIME, …) and will not normally affect correctness. See the note about libraries in the description of EV_USE_MONOTONIC, though. Defaults to the opposite value of EV_USE_CLOCK_SYSCALL.&lt;/p&gt;

&lt;p&gt;EV_USE_CLOCK_SYSCALL
If defined to be 1, libev will try to use a direct syscall instead of calling the system-provided clock_gettime function. This option exists because on GNU/Linux, clock_gettime is in librt, but librt unconditionally pulls in libpthread, slowing down single-threaded programs needlessly. Using a direct syscall is slightly slower (in theory), because no optimised vdso implementation can be used, but avoids the pthread dependency. Defaults to 1 on GNU/Linux with glibc 2.x or higher, as it simplifies linking (no need for -lrt).&lt;/p&gt;

&lt;p&gt;EV_USE_NANOSLEEP
If defined to be 1, libev will assume that nanosleep () is available and will use it for delays. Otherwise it will use select ().&lt;/p&gt;

&lt;p&gt;EV_USE_EVENTFD
If defined to be 1, then libev will assume that eventfd () is available and will probe for kernel support at runtime. This will improve ev_signal and ev_async performance and reduce resource consumption. If undefined, it will be enabled if the headers indicate GNU/Linux + Glibc 2.7 or newer, otherwise disabled.&lt;/p&gt;

&lt;p&gt;EV_USE_SELECT
If undefined or defined to be 1, libev will compile in support for the select(2) backend. No attempt at auto-detection will be done: if no other method takes over, select will be it. Otherwise the select backend will not be compiled in.&lt;/p&gt;

&lt;p&gt;EV_SELECT_USE_FD_SET
If defined to 1, then the select backend will use the system fd_set structure. This is useful if libev doesn’t compile due to a missing NFDBITS or fd_mask definition or it mis-guesses the bitset layout on exotic systems. This usually limits the range of file descriptors to some low limit such as 1024 or might have other limitations (winsocket only allows 64 sockets). The FD_SETSIZE macro, set before compilation, configures the maximum size of the fd_set.&lt;/p&gt;

&lt;p&gt;EV_SELECT_IS_WINSOCKET
When defined to 1, the select backend will assume that select/socket/connect etc. don’t understand file descriptors but wants osf handles on win32 (this is the case when the select to be used is the winsock select). This means that it will call _get_osfhandle on the fd to convert it to an OS handle. Otherwise, it is assumed that all these functions actually work on fds, even on win32. Should not be defined on non-win32 platforms.&lt;/p&gt;

&lt;p&gt;EV_FD_TO_WIN32_HANDLE(fd)
If EV_SELECT_IS_WINSOCKET is enabled, then libev needs a way to map file descriptors to socket handles. When not defining this symbol (the default), then libev will call _get_osfhandle, which is usually correct. In some cases, programs use their own file descriptor management, in which case they can provide this function to map fds to socket handles.&lt;/p&gt;

&lt;p&gt;EV_WIN32_HANDLE_TO_FD(handle)
If EV_SELECT_IS_WINSOCKET then libev maps handles to file descriptors using the standard _open_osfhandle function. For programs implementing their own fd to handle mapping, overwriting this function makes it easier to do so. This can be done by defining this macro to an appropriate value.&lt;/p&gt;

&lt;p&gt;EV_WIN32_CLOSE_FD(fd)
If programs implement their own fd to handle mapping on win32, then this macro can be used to override the close function, useful to unregister file descriptors again. Note that the replacement function has to close the underlying OS handle.&lt;/p&gt;

&lt;p&gt;EV_USE_WSASOCKET
If defined to be 1, libev will use WSASocket to create its internal communication socket, which works better in some environments. Otherwise, the normal socket function will be used, which works better in other environments.&lt;/p&gt;

&lt;p&gt;EV_USE_POLL
If defined to be 1, libev will compile in support for the poll(2) backend. Otherwise it will be enabled on non-win32 platforms. It takes precedence over select.&lt;/p&gt;

&lt;p&gt;EV_USE_EPOLL
If defined to be 1, libev will compile in support for the Linux epoll(7) backend. Its availability will be detected at runtime, otherwise another method will be used as fallback. This is the preferred backend for GNU/Linux systems. If undefined, it will be enabled if the headers indicate GNU/Linux + Glibc 2.4 or newer, otherwise disabled.&lt;/p&gt;

&lt;p&gt;EV_USE_KQUEUE
If defined to be 1, libev will compile in support for the BSD style kqueue(2) backend. Its actual availability will be detected at runtime, otherwise another method will be used as fallback. This is the preferred backend for BSD and BSD-like systems, although on most BSDs kqueue only supports some types of fds correctly (the only platform we found that supports ptys for example was NetBSD), so kqueue might be compiled in, but not be used unless explicitly requested. The best way to use it is to find out whether kqueue supports your type of fd properly and use an embedded kqueue loop.&lt;/p&gt;

&lt;p&gt;EV_USE_PORT
If defined to be 1, libev will compile in support for the Solaris 10 port style backend. Its availability will be detected at runtime, otherwise another method will be used as fallback. This is the preferred backend for Solaris 10 systems.&lt;/p&gt;

&lt;p&gt;EV_USE_DEVPOLL
Reserved for future expansion, works like the USE symbols above.&lt;/p&gt;

&lt;p&gt;EV_USE_INOTIFY
If defined to be 1, libev will compile in support for the Linux inotify interface to speed up ev_stat watchers. Its actual availability will be detected at runtime. If undefined, it will be enabled if the headers indicate GNU/Linux + Glibc 2.4 or newer, otherwise disabled.&lt;/p&gt;

&lt;p&gt;EV_NO_SMP
If defined to be 1, libev will assume that memory is always coherent between threads, that is, threads can be used, but threads never run on different cpus (or different cpu cores). This reduces dependencies and makes libev faster.&lt;/p&gt;

&lt;p&gt;EV_NO_THREADS
If defined to be 1, libev will assume that it will never be called from different threads (that includes signal handlers), which is a stronger assumption than EV_NO_SMP, above. This reduces dependencies and makes libev faster.&lt;/p&gt;

&lt;p&gt;EV_ATOMIC_T
Libev requires an integer type (suitable for storing 0 or 1) whose access is atomic with respect to other threads or signal contexts. No such type is easily found in the C language, so you can provide your own type that you know is safe for your purposes. It is used both for signal handler “locking” as well as for signal and thread safety in ev_async watchers.&lt;/p&gt;

&lt;p&gt;In the absence of this define, libev will use sig_atomic_t volatile (from signal.h), which is usually good enough on most platforms.&lt;/p&gt;

&lt;p&gt;EV_H (h)
The name of the ev.h header file used to include it. The default if undefined is “ev.h” in event.h, ev.c and ev++.h. This can be used to virtually rename the ev.h header file in case of conflicts.&lt;/p&gt;

&lt;p&gt;EV_CONFIG_H (h)
If EV_STANDALONE isn’t 1, this variable can be used to override ev.c’s idea of where to find the config.h file, similarly to EV_H, above.&lt;/p&gt;

&lt;p&gt;EV_EVENT_H (h)
Similarly to EV_H, this macro can be used to override event.c’s idea of how the event.h header can be found, the default is “event.h”.&lt;/p&gt;

&lt;p&gt;EV_PROTOTYPES (h)
If defined to be 0, then ev.h will not define any function prototypes, but still define all the structs and other symbols. This is occasionally useful if you want to provide your own wrapper functions around libev functions.&lt;/p&gt;

&lt;p&gt;EV_MULTIPLICITY
If undefined or defined to 1, then all event-loop-specific functions will have the struct ev_loop * as first argument, and you can create additional independent event loops. Otherwise there will be no support for multiple event loops and there is no first event loop pointer argument. Instead, all functions act on the single default loop.&lt;/p&gt;

&lt;p&gt;Note that EV_DEFAULT and EV_DEFAULT_ will no longer provide a default loop when multiplicity is switched off - you always have to initialise the loop manually in this case.&lt;/p&gt;

&lt;p&gt;EV_MINPRI
EV_MAXPRI
The range of allowed priorities. EV_MINPRI must be smaller or equal to EV_MAXPRI, but otherwise there are no non-obvious limitations. You can provide for more priorities by overriding those symbols (usually defined to be -2 and 2, respectively).&lt;/p&gt;

&lt;p&gt;When doing priority-based operations, libev usually has to linearly search all the priorities, so having many of them (hundreds) uses a lot of space and time, so using the defaults of five priorities (-2 .. +2) is usually fine.&lt;/p&gt;

&lt;p&gt;If your embedding application does not need any priorities, defining these both to 0 will save some memory and CPU.&lt;/p&gt;

&lt;p&gt;EV_PERIODIC_ENABLE, EV_IDLE_ENABLE, EV_EMBED_ENABLE, EV_STAT_ENABLE, EV_PREPARE_ENABLE, EV_CHECK_ENABLE, EV_FORK_ENABLE, EV_SIGNAL_ENABLE, EV_ASYNC_ENABLE, EV_CHILD_ENABLE.
If undefined or defined to be 1 (and the platform supports it), then the respective watcher type is supported. If defined to be 0, then it is not. Disabling watcher types mainly saves code size.&lt;/p&gt;

&lt;p&gt;EV_FEATURES
If you need to shave off some kilobytes of code at the expense of some speed (but with the full API), you can define this symbol to request certain subsets of functionality. The default is to enable all features that can be enabled on the platform.&lt;/p&gt;

&lt;p&gt;A typical way to use this symbol is to define it to 0 (or to a bitset with some broad features you want) and then selectively re-enable additional parts you want, for example if you want everything minimal, but multiple event loop support, async and child watchers and the poll backend, use this:&lt;/p&gt;

&lt;p&gt;#define EV_FEATURES 0
#define EV_MULTIPLICITY 1
#define EV_USE_POLL 1
#define EV_CHILD_ENABLE 1
#define EV_ASYNC_ENABLE 1&lt;/p&gt;

&lt;p&gt;The actual value is a bitset, it can be a combination of the following values (by default, all of these are enabled):&lt;/p&gt;

&lt;p&gt;1 - faster/larger code
Use larger code to speed up some operations.&lt;/p&gt;

&lt;p&gt;Currently this is used to override some inlining decisions (enlarging the code size by roughly 30% on amd64).&lt;/p&gt;

&lt;p&gt;When optimising for size, use of compiler flags such as -Os with gcc is recommended, as well as -DNDEBUG, as libev contains a number of assertions.&lt;/p&gt;

&lt;p&gt;The default is off when &lt;strong&gt;OPTIMIZE_SIZE&lt;/strong&gt; is defined by your compiler (e.g. gcc with -Os).&lt;/p&gt;

&lt;p&gt;2 - faster/larger data structures
Replaces the small 2-heap for timer management by a faster 4-heap, larger hash table sizes and so on. This will usually further increase code size and can additionally have an effect on the size of data structures at runtime.&lt;/p&gt;

&lt;p&gt;The default is off when &lt;strong&gt;OPTIMIZE_SIZE&lt;/strong&gt; is defined by your compiler (e.g. gcc with -Os).&lt;/p&gt;

&lt;p&gt;4 - full API configuration
This enables priorities (sets EV_MAXPRI=2 and EV_MINPRI=-2), and enables multiplicity (EV_MULTIPLICITY=1).&lt;/p&gt;

&lt;p&gt;8 - full API
This enables a lot of the “lesser used” API functions. See ev.h for details on which parts of the API are still available without this feature, and do not complain if this subset changes over time.&lt;/p&gt;

&lt;p&gt;16 - enable all optional watcher types
Enables all optional watcher types. If you want to selectively enable only some watcher types other than I/O and timers (e.g. prepare, embed, async, child…) you can enable them manually by defining EV_watchertype_ENABLE to 1 instead.&lt;/p&gt;

&lt;p&gt;32 - enable all backends
This enables all backends - without this feature, you need to enable at least one backend manually (EV_USE_SELECT is a good choice).&lt;/p&gt;

&lt;p&gt;64 - enable OS-specific “helper” APIs
Enable inotify, eventfd, signalfd and similar OS-specific helper APIs by default.&lt;/p&gt;

&lt;p&gt;Compiling with gcc -Os -DEV_STANDALONE -DEV_USE_EPOLL=1 -DEV_FEATURES=0 reduces the compiled size of libev from 24.7Kb code/2.8Kb data to 6.5Kb code/0.3Kb data on my GNU/Linux amd64 system, while still giving you I/O watchers, timers and monotonic clock support.&lt;/p&gt;

&lt;p&gt;With an intelligent-enough linker (gcc+binutils are intelligent enough when you use -Wl,–gc-sections -ffunction-sections) functions unused by your program might be left out as well - a binary starting a timer and an I/O watcher then might come out at only 5Kb.&lt;/p&gt;

&lt;p&gt;EV_API_STATIC
If this symbol is defined (by default it is not), then all identifiers will have static linkage. This means that libev will not export any identifiers, and you cannot link against libev anymore. This can be useful when you embed libev, only want to use libev functions in a single file, and do not want its identifiers to be visible.&lt;/p&gt;

&lt;p&gt;To use this, define EV_API_STATIC and include ev.c in the file that wants to use libev.&lt;/p&gt;

&lt;p&gt;This option only works when libev is compiled with a C compiler, as C++ doesn’t support the required declaration syntax.&lt;/p&gt;

&lt;p&gt;EV_AVOID_STDIO
If this is set to 1 at compiletime, then libev will avoid using stdio functions (printf, scanf, perror etc.). This will increase the code size somewhat, but if your program doesn’t otherwise depend on stdio and your libc allows it, this avoids linking in the stdio library which is quite big.&lt;/p&gt;

&lt;p&gt;Note that error messages might become less precise when this option is enabled.&lt;/p&gt;

&lt;p&gt;EV_NSIG
The highest supported signal number, +1 (or, the number of signals): Normally, libev tries to deduce the maximum number of signals automatically, but sometimes this fails, in which case it can be specified. Also, using a lower number than detected (32 should be good for about any system in existence) can save some memory, as libev statically allocates some 12-24 bytes per signal number.&lt;/p&gt;

&lt;p&gt;EV_PID_HASHSIZE
ev_child watchers use a small hash table to distribute workload by pid. The default size is 16 (or 1 with EV_FEATURES disabled), usually more than enough. If you need to manage thousands of children you might want to increase this value (must be a power of two).&lt;/p&gt;

&lt;p&gt;EV_INOTIFY_HASHSIZE
ev_stat watchers use a small hash table to distribute workload by inotify watch id. The default size is 16 (or 1 with EV_FEATURES disabled), usually more than enough. If you need to manage thousands of ev_stat watchers you might want to increase this value (must be a power of two).&lt;/p&gt;

&lt;p&gt;EV_USE_4HEAP
Heaps are not very cache-efficient. To improve the cache-efficiency of the timer and periodics heaps, libev uses a 4-heap when this symbol is defined to 1. The 4-heap uses more complicated (longer) code but has noticeably faster performance with many (thousands) of watchers.&lt;/p&gt;

&lt;p&gt;The default is 1, unless EV_FEATURES overrides it, in which case it will be 0.&lt;/p&gt;

&lt;p&gt;EV_HEAP_CACHE_AT
Heaps are not very cache-efficient. To improve the cache-efficiency of the timer and periodics heaps, libev can cache the timestamp (at) within the heap structure (selected by defining EV_HEAP_CACHE_AT to 1), which uses 8-12 bytes more per watcher and a few hundred bytes more code, but avoids random read accesses on heap changes. This improves performance noticeably with many (hundreds) of watchers.&lt;/p&gt;

&lt;p&gt;The default is 1, unless EV_FEATURES overrides it, in which case it will be 0.&lt;/p&gt;

&lt;p&gt;EV_VERIFY
Controls how much internal verification (see ev_verify ()) will be done: If set to 0, no internal verification code will be compiled in. If set to 1, then verification code will be compiled in, but not called. If set to 2, then the internal verification code will be called once per loop, which can slow down libev. If set to 3, then the verification code will be called very frequently, which will slow down libev considerably.&lt;/p&gt;

&lt;p&gt;The default is 1, unless EV_FEATURES overrides it, in which case it will be 0.&lt;/p&gt;

&lt;p&gt;EV_COMMON
By default, all watchers have a void *data member. By redefining this macro to something else you can include more and other types of members. You have to define it each time you include one of the files, though, and it must be identical each time.&lt;/p&gt;

&lt;p&gt;For example, the perl EV module uses something like this:&lt;/p&gt;

&lt;p&gt;#define EV_COMMON                       \
SV &lt;em&gt;self; /&lt;/em&gt; contains this struct &lt;em&gt;/  \
SV *cb_sv, *fh /&lt;/em&gt; note no trailing “;” */&lt;/p&gt;

&lt;p&gt;EV_CB_DECLARE (type)
EV_CB_INVOKE (watcher, revents)
ev_set_cb (ev, cb)
Can be used to change the callback member declaration in each watcher, and the way callbacks are invoked and set. Must expand to a struct member definition and a statement, respectively. See the ev.h header file for their default definitions. One possible use for overriding these is to avoid the struct ev_loop * as first argument in all cases, or to use method calls instead of plain function calls in C++.&lt;/p&gt;

&lt;p&gt;EXPORTED API SYMBOLS&lt;/p&gt;

&lt;p&gt;If you need to re-export the API (e.g. via a DLL) and you need a list of exported symbols, you can use the provided Symbol.* files which list all public symbols, one per line:&lt;/p&gt;

&lt;p&gt;Symbols.ev      for libev proper
Symbols.event   for the libevent emulation&lt;/p&gt;

&lt;p&gt;This can also be used to rename all public symbols to avoid clashes with multiple versions of libev linked together (which is obviously bad in itself, but sometimes it is inconvenient to avoid this).&lt;/p&gt;

&lt;p&gt;A sed command like this will create wrapper #define’s that you need to include before including ev.h:&lt;/p&gt;

&lt;p&gt;&amp;lt;Symbols.ev sed -e “s/.*/#define &amp;amp; myprefix_&amp;amp;/” &amp;gt;wrap.h&lt;/p&gt;

&lt;p&gt;This would create a file wrap.h which essentially looks like this:&lt;/p&gt;

&lt;p&gt;#define ev_backend     myprefix_ev_backend
#define ev_check_start myprefix_ev_check_start
#define ev_check_stop  myprefix_ev_check_stop
…&lt;/p&gt;

&lt;p&gt;EXAMPLES&lt;/p&gt;

&lt;p&gt;For a real-world example of a program the includes libev verbatim, you can have a look at the EV perl module (http://software.schmorp.de/pkg/EV.html). It has the libev files in the libev/ subdirectory and includes them in the EV/EVAPI.h (public interface) and EV.xs (implementation) files. Only the EV.xs file will be compiled. It is pretty complex because it provides its own header file.&lt;/p&gt;

&lt;p&gt;The usage in rxvt-unicode is simpler. It has a ev_cpp.h header file that everybody includes and which overrides some configure choices:&lt;/p&gt;

&lt;p&gt;#define EV_FEATURES 8
#define EV_USE_SELECT 1
#define EV_PREPARE_ENABLE 1
#define EV_IDLE_ENABLE 1
#define EV_SIGNAL_ENABLE 1
#define EV_CHILD_ENABLE 1
#define EV_USE_STDEXCEPT 0
#define EV_CONFIG_H &lt;config.h&gt;&lt;/config.h&gt;&lt;/p&gt;

&lt;p&gt;#include “ev++.h”&lt;/p&gt;

&lt;p&gt;And a ev_cpp.C implementation file that contains libev proper and is compiled:&lt;/p&gt;

&lt;p&gt;#include “ev_cpp.h”
#include “ev.c”&lt;/p&gt;

&lt;p&gt;INTERACTION WITH OTHER PROGRAMS, LIBRARIES OR THE ENVIRONMENT&lt;/p&gt;

&lt;p&gt;THREADS AND COROUTINES&lt;/p&gt;

&lt;p&gt;THREADS&lt;/p&gt;

&lt;p&gt;All libev functions are reentrant and thread-safe unless explicitly documented otherwise, but libev implements no locking itself. This means that you can use as many loops as you want in parallel, as long as there are no concurrent calls into any libev function with the same loop parameter (ev_default_* calls have an implicit default loop parameter, of course): libev guarantees that different event loops share no data structures that need any locking.&lt;/p&gt;

&lt;p&gt;Or to put it differently: calls with different loop parameters can be done concurrently from multiple threads, calls with the same loop parameter must be done serially (but can be done from different threads, as long as only one thread ever is inside a call at any point in time, e.g. by using a mutex per loop).&lt;/p&gt;

&lt;p&gt;Specifically to support threads (and signal handlers), libev implements so-called ev_async watchers, which allow some limited form of concurrency on the same event loop, namely waking it up “from the outside”.&lt;/p&gt;

&lt;p&gt;If you want to know which design (one loop, locking, or multiple loops without or something else still) is best for your problem, then I cannot help you, but here is some generic advice:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;most applications have a main thread: use the default libev loop in that thread, or create a separate thread running only the default loop.
  This helps integrating other libraries or software modules that use libev themselves and don’t care/know about threading.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;one loop per thread is usually a good model.
  Doing this is almost never wrong, sometimes a better-performance model exists, but it is always a good start.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;other models exist, such as the leader/follower pattern, where one loop is handed through multiple threads in a kind of round-robin fashion.
  Choosing a model is hard - look around, learn, know that usually you can do better than you currently do :-)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;often you need to talk to some other thread which blocks in the event loop.
  ev_async watchers can be used to wake them up from other threads safely (or from signal contexts…).&lt;/p&gt;

    &lt;p&gt;An example use would be to communicate signals or other events that only work in the default loop by registering the signal watcher with the default loop and triggering an ev_async watcher from the default loop watcher callback into the event loop interested in the signal.&lt;/p&gt;

    &lt;p&gt;See also THREAD LOCKING EXAMPLE.&lt;/p&gt;

    &lt;p&gt;COROUTINES&lt;/p&gt;

    &lt;p&gt;Libev is very accommodating to coroutines (“cooperative threads”): libev fully supports nesting calls to its functions from different coroutines (e.g. you can call ev_run on the same loop from two different coroutines, and switch freely between both coroutines running the loop, as long as you don’t confuse yourself). The only exception is that you must not do this from ev_periodic reschedule callbacks.&lt;/p&gt;

    &lt;p&gt;Care has been taken to ensure that libev does not keep local state inside ev_run, and other calls do not usually allow for coroutine switches as they do not call any callbacks.&lt;/p&gt;

    &lt;p&gt;COMPILER WARNINGS&lt;/p&gt;

    &lt;p&gt;Depending on your compiler and compiler settings, you might get no or a lot of warnings when compiling libev code. Some people are apparently scared by this.&lt;/p&gt;

    &lt;p&gt;However, these are unavoidable for many reasons. For one, each compiler has different warnings, and each user has different tastes regarding warning options. “Warn-free” code therefore cannot be a goal except when targeting a specific compiler and compiler-version.&lt;/p&gt;

    &lt;p&gt;Another reason is that some compiler warnings require elaborate workarounds, or other changes to the code that make it less clear and less maintainable.&lt;/p&gt;

    &lt;p&gt;And of course, some compiler warnings are just plain stupid, or simply wrong (because they don’t actually warn about the condition their message seems to warn about). For example, certain older gcc versions had some warnings that resulted in an extreme number of false positives. These have been fixed, but some people still insist on making code warn-free with such buggy versions.&lt;/p&gt;

    &lt;p&gt;While libev is written to generate as few warnings as possible, “warn-free” code is not a goal, and it is recommended not to build libev with any compiler warnings enabled unless you are prepared to cope with them (e.g. by ignoring them). Remember that warnings are just that: warnings, not errors, or proof of bugs.&lt;/p&gt;

    &lt;p&gt;VALGRIND&lt;/p&gt;

    &lt;p&gt;Valgrind has a special section here because it is a popular tool that is highly useful. Unfortunately, valgrind reports are very hard to interpret.&lt;/p&gt;

    &lt;p&gt;If you think you found a bug (memory leak, uninitialised data access etc.) in libev, then check twice: If valgrind reports something like:&lt;/p&gt;

    &lt;p&gt;==2274==    definitely lost: 0 bytes in 0 blocks.
  ==2274==      possibly lost: 0 bytes in 0 blocks.
  ==2274==    still reachable: 256 bytes in 1 blocks.&lt;/p&gt;

    &lt;p&gt;Then there is no memory leak, just as memory accounted to global variables is not a memleak - the memory is still being referenced, and didn’t leak.&lt;/p&gt;

    &lt;p&gt;Similarly, under some circumstances, valgrind might report kernel bugs as if it were a bug in libev (e.g. in realloc or in the poll backend, although an acceptable workaround has been found here), or it might be confused.&lt;/p&gt;

    &lt;p&gt;Keep in mind that valgrind is a very good tool, but only a tool. Don’t make it into some kind of religion.&lt;/p&gt;

    &lt;p&gt;If you are unsure about something, feel free to contact the mailing list with the full valgrind report and an explanation on why you think this is a bug in libev (best check the archives, too :). However, don’t be annoyed when you get a brisk “this is no bug” answer and take the chance of learning how to interpret valgrind properly.&lt;/p&gt;

    &lt;p&gt;If you need, for some reason, empty reports from valgrind for your project I suggest using suppression lists.&lt;/p&gt;

    &lt;p&gt;PORTABILITY NOTES&lt;/p&gt;

    &lt;p&gt;GNU/LINUX 32 BIT LIMITATIONS&lt;/p&gt;

    &lt;p&gt;GNU/Linux is the only common platform that supports 64 bit file/large file interfaces but disables them by default.&lt;/p&gt;

    &lt;p&gt;That means that libev compiled in the default environment doesn’t support files larger than 2GiB or so, which mainly affects ev_stat watchers.&lt;/p&gt;

    &lt;p&gt;Unfortunately, many programs try to work around this GNU/Linux issue by enabling the large file API, which makes them incompatible with the standard libev compiled for their system.&lt;/p&gt;

    &lt;p&gt;Likewise, libev cannot enable the large file API itself as this would suddenly make it incompatible to the default compile time environment, i.e. all programs not using special compile switches.&lt;/p&gt;

    &lt;p&gt;OS/X AND DARWIN BUGS&lt;/p&gt;

    &lt;p&gt;The whole thing is a bug if you ask me - basically any system interface you touch is broken, whether it is locales, poll, kqueue or even the OpenGL drivers.&lt;/p&gt;

    &lt;p&gt;kqueue is buggy&lt;/p&gt;

    &lt;p&gt;The kqueue syscall is broken in all known versions - most versions support only sockets, many support pipes.&lt;/p&gt;

    &lt;p&gt;Libev tries to work around this by not using kqueue by default on this rotten platform, but of course you can still ask for it when creating a loop - embedding a socket-only kqueue loop into a select-based one is probably going to work well.&lt;/p&gt;

    &lt;p&gt;poll is buggy&lt;/p&gt;

    &lt;p&gt;Instead of fixing kqueue, Apple replaced their (working) poll implementation by something calling kqueue internally around the 10.5.6 release, so now kqueue and poll are broken.&lt;/p&gt;

    &lt;p&gt;Libev tries to work around this by not using poll by default on this rotten platform, but of course you can still ask for it when creating a loop.&lt;/p&gt;

    &lt;p&gt;select is buggy&lt;/p&gt;

    &lt;p&gt;All that’s left is select, and of course Apple found a way to fuck this one up as well: On OS/X, select actively limits the number of file descriptors you can pass in to 1024 - your program suddenly crashes when you use more.&lt;/p&gt;

    &lt;p&gt;There is an undocumented “workaround” for this - defining _DARWIN_UNLIMITED_SELECT, which libev tries to use, so select should work on OS/X.&lt;/p&gt;

    &lt;p&gt;SOLARIS PROBLEMS AND WORKAROUNDS&lt;/p&gt;

    &lt;p&gt;errno reentrancy&lt;/p&gt;

    &lt;p&gt;The default compile environment on Solaris is unfortunately so thread-unsafe that you can’t even use components/libraries compiled without -D_REENTRANT in a threaded program, which, of course, isn’t defined by default. A valid, if stupid, implementation choice.&lt;/p&gt;

    &lt;p&gt;If you want to use libev in threaded environments you have to make sure it’s compiled with _REENTRANT defined.&lt;/p&gt;

    &lt;p&gt;Event port backend&lt;/p&gt;

    &lt;p&gt;The scalable event interface for Solaris is called “event ports”. Unfortunately, this mechanism is very buggy in all major releases. If you run into high CPU usage, your program freezes or you get a large number of spurious wakeups, make sure you have all the relevant and latest kernel patches applied. No, I don’t know which ones, but there are multiple ones to apply, and afterwards, event ports actually work great.&lt;/p&gt;

    &lt;p&gt;If you can’t get it to work, you can try running the program by setting the environment variable LIBEV_FLAGS=3 to only allow poll and select backends.&lt;/p&gt;

    &lt;p&gt;AIX POLL BUG&lt;/p&gt;

    &lt;p&gt;AIX unfortunately has a broken poll.h header. Libev works around this by trying to avoid the poll backend altogether (i.e. it’s not even compiled in), which normally isn’t a big problem as select works fine with large bitsets on AIX, and AIX is dead anyway.&lt;/p&gt;

    &lt;p&gt;WIN32 PLATFORM LIMITATIONS AND WORKAROUNDS&lt;/p&gt;

    &lt;p&gt;General issues&lt;/p&gt;

    &lt;p&gt;Win32 doesn’t support any of the standards (e.g. POSIX) that libev requires, and its I/O model is fundamentally incompatible with the POSIX model. Libev still offers limited functionality on this platform in the form of the EVBACKEND_SELECT backend, and only supports socket descriptors. This only applies when using Win32 natively, not when using e.g. cygwin. Actually, it only applies to the microsofts own compilers, as every compiler comes with a slightly differently broken/incompatible environment.&lt;/p&gt;

    &lt;p&gt;Lifting these limitations would basically require the full re-implementation of the I/O system. If you are into this kind of thing, then note that glib does exactly that for you in a very portable way (note also that glib is the slowest event library known to man).&lt;/p&gt;

    &lt;p&gt;There is no supported compilation method available on windows except embedding it into other applications.&lt;/p&gt;

    &lt;p&gt;Sensible signal handling is officially unsupported by Microsoft - libev tries its best, but under most conditions, signals will simply not work.&lt;/p&gt;

    &lt;p&gt;Not a libev limitation but worth mentioning: windows apparently doesn’t accept large writes: instead of resulting in a partial write, windows will either accept everything or return ENOBUFS if the buffer is too large, so make sure you only write small amounts into your sockets (less than a megabyte seems safe, but this apparently depends on the amount of memory available).&lt;/p&gt;

    &lt;p&gt;Due to the many, low, and arbitrary limits on the win32 platform and the abysmal performance of winsockets, using a large number of sockets is not recommended (and not reasonable). If your program needs to use more than a hundred or so sockets, then likely it needs to use a totally different implementation for windows, as libev offers the POSIX readiness notification model, which cannot be implemented efficiently on windows (due to Microsoft monopoly games).&lt;/p&gt;

    &lt;p&gt;A typical way to use libev under windows is to embed it (see the embedding section for details) and use the following evwrap.h header file instead of ev.h:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#define EV_STANDALONE              /* keeps ev from requiring config.h &lt;em&gt;/
#define EV_SELECT_IS_WINSOCKET 1   /&lt;/em&gt; configure libev for windows select */&lt;/p&gt;

&lt;p&gt;#include “ev.h”&lt;/p&gt;

&lt;p&gt;And compile the following evwrap.c file into your project (make sure you do not compile the ev.c or any other embedded source files!):&lt;/p&gt;

&lt;p&gt;#include “evwrap.h”
#include “ev.c”&lt;/p&gt;

&lt;p&gt;The winsocket select function&lt;/p&gt;

&lt;p&gt;The winsocket select function doesn’t follow POSIX in that it requires socket handles and not socket file descriptors (it is also extremely buggy). This makes select very inefficient, and also requires a mapping from file descriptors to socket handles (the Microsoft C runtime provides the function _open_osfhandle for this). See the discussion of the EV_SELECT_USE_FD_SET, EV_SELECT_IS_WINSOCKET and EV_FD_TO_WIN32_HANDLE preprocessor symbols for more info.&lt;/p&gt;

&lt;p&gt;The configuration for a “naked” win32 using the Microsoft runtime libraries and raw winsocket select is:&lt;/p&gt;

&lt;p&gt;#define EV_USE_SELECT 1
#define EV_SELECT_IS_WINSOCKET 1   /* forces EV_SELECT_USE_FD_SET, too */&lt;/p&gt;

&lt;p&gt;Note that winsockets handling of fd sets is O(n), so you can easily get a complexity in the O(n²) range when using win32.&lt;/p&gt;

&lt;p&gt;Limited number of file descriptors&lt;/p&gt;

&lt;p&gt;Windows has numerous arbitrary (and low) limits on things.&lt;/p&gt;

&lt;p&gt;Early versions of winsocket’s select only supported waiting for a maximum of 64 handles (probably owning to the fact that all windows kernels can only wait for 64 things at the same time internally; Microsoft recommends spawning a chain of threads and wait for 63 handles and the previous thread in each. Sounds great!).&lt;/p&gt;

&lt;p&gt;Newer versions support more handles, but you need to define FD_SETSIZE to some high number (e.g. 2048) before compiling the winsocket select call (which might be in libev or elsewhere, for example, perl and many other interpreters do their own select emulation on windows).&lt;/p&gt;

&lt;p&gt;Another limit is the number of file descriptors in the Microsoft runtime libraries, which by default is 64 (there must be a hidden 64 fetish or something like this inside Microsoft). You can increase this by calling _setmaxstdio, which can increase this limit to 2048 (another arbitrary limit), but is broken in many versions of the Microsoft runtime libraries. This might get you to about 512 or 2048 sockets (depending on windows version and/or the phase of the moon). To get more, you need to wrap all I/O functions and provide your own fd management, but the cost of calling select (O(n²)) will likely make this unworkable.&lt;/p&gt;

&lt;p&gt;PORTABILITY REQUIREMENTS&lt;/p&gt;

&lt;p&gt;In addition to a working ISO-C implementation and of course the backend-specific APIs, libev relies on a few additional extensions:&lt;/p&gt;

&lt;p&gt;void (*)(ev_watcher_type *, int revents) must have compatible calling conventions regardless of ev_watcher_type *.
Libev assumes not only that all watcher pointers have the same internal structure (guaranteed by POSIX but not by ISO C for example), but it also assumes that the same (machine) code can be used to call any watcher callback: The watcher callbacks have different type signatures, but libev calls them using an ev_watcher * internally.&lt;/p&gt;

&lt;p&gt;pointer accesses must be thread-atomic
Accessing a pointer value must be atomic, it must both be readable and writable in one piece - this is the case on all current architectures.&lt;/p&gt;

&lt;p&gt;sig_atomic_t volatile must be thread-atomic as well
The type sig_atomic_t volatile (or whatever is defined as EV_ATOMIC_T) must be atomic with respect to accesses from different threads. This is not part of the specification for sig_atomic_t, but is believed to be sufficiently portable.&lt;/p&gt;

&lt;p&gt;sigprocmask must work in a threaded environment
Libev uses sigprocmask to temporarily block signals. This is not allowed in a threaded program (pthread_sigmask has to be used). Typical pthread implementations will either allow sigprocmask in the “main thread” or will block signals process-wide, both behaviours would be compatible with libev. Interaction between sigprocmask and pthread_sigmask could complicate things, however.&lt;/p&gt;

&lt;p&gt;The most portable way to handle signals is to block signals in all threads except the initial one, and run the signal handling loop in the initial thread as well.&lt;/p&gt;

&lt;p&gt;long must be large enough for common memory allocation sizes
To improve portability and simplify its API, libev uses long internally instead of size_t when allocating its data structures. On non-POSIX systems (Microsoft…) this might be unexpectedly low, but is still at least 31 bits everywhere, which is enough for hundreds of millions of watchers.&lt;/p&gt;

&lt;p&gt;double must hold a time value in seconds with enough accuracy
The type double is used to represent timestamps. It is required to have at least 51 bits of mantissa (and 9 bits of exponent), which is good enough for at least into the year 4000 with millisecond accuracy (the design goal for libev). This requirement is overfulfilled by implementations using IEEE 754, which is basically all existing ones.&lt;/p&gt;

&lt;p&gt;With IEEE 754 doubles, you get microsecond accuracy until at least the year 2255 (and millisecond accuracy till the year 287396 - by then, libev is either obsolete or somebody patched it to use long double or something like that, just kidding).&lt;/p&gt;

&lt;p&gt;If you know of other additional requirements drop me a note.&lt;/p&gt;

&lt;p&gt;ALGORITHMIC COMPLEXITIES&lt;/p&gt;

&lt;p&gt;In this section the complexities of (many of) the algorithms used inside libev will be documented. For complexity discussions about backends see the documentation for ev_default_init.&lt;/p&gt;

&lt;p&gt;All of the following are about amortised time: If an array needs to be extended, libev needs to realloc and move the whole array, but this happens asymptotically rarer with higher number of elements, so O(1) might mean that libev does a lengthy realloc operation in rare cases, but on average it is much faster and asymptotically approaches constant time.&lt;/p&gt;

&lt;p&gt;Starting and stopping timer/periodic watchers: O(log skipped_other_timers)
This means that, when you have a watcher that triggers in one hour and there are 100 watchers that would trigger before that, then inserting will have to skip roughly seven (ld 100) of these watchers.&lt;/p&gt;

&lt;p&gt;Changing timer/periodic watchers (by autorepeat or calling again): O(log skipped_other_timers)
That means that changing a timer costs less than removing/adding them, as only the relative motion in the event queue has to be paid for.&lt;/p&gt;

&lt;p&gt;Starting io/check/prepare/idle/signal/child/fork/async watchers: O(1)
These just add the watcher into an array or at the head of a list.&lt;/p&gt;

&lt;p&gt;Stopping check/prepare/idle/fork/async watchers: O(1)
Stopping an io/signal/child watcher: O(number_of_watchers_for_this_(fd/signal/pid % EV_PID_HASHSIZE))
These watchers are stored in lists, so they need to be walked to find the correct watcher to remove. The lists are usually short (you don’t usually have many watchers waiting for the same fd or signal: one is typical, two is rare).&lt;/p&gt;

&lt;p&gt;Finding the next timer in each loop iteration: O(1)
By virtue of using a binary or 4-heap, the next timer is always found at a fixed position in the storage array.&lt;/p&gt;

&lt;p&gt;Each change on a file descriptor per loop iteration: O(number_of_watchers_for_this_fd)
A change means an I/O watcher gets started or stopped, which requires libev to recalculate its status (and possibly tell the kernel, depending on backend and whether ev_io_set was used).&lt;/p&gt;

&lt;p&gt;Activating one watcher (putting it into the pending state): O(1)
Priority handling: O(number_of_priorities)
Priorities are implemented by allocating some space for each priority. When doing priority-based operations, libev usually has to linearly search all the priorities, but starting/stopping and activating watchers becomes O(1) with respect to priority handling.&lt;/p&gt;

&lt;p&gt;Sending an ev_async: O(1)
Processing ev_async_send: O(number_of_async_watchers)
Processing signals: O(max_signal_number)
Sending involves a system call iff there were no other ev_async_send calls in the current loop iteration and the loop is currently blocked. Checking for async and signal events involves iterating over all running async watchers or all signal numbers.&lt;/p&gt;

&lt;p&gt;PORTING FROM LIBEV 3.X TO 4.X&lt;/p&gt;

&lt;p&gt;The major version 4 introduced some incompatible changes to the API.&lt;/p&gt;

&lt;p&gt;At the moment, the ev.h header file provides compatibility definitions for all changes, so most programs should still compile. The compatibility layer might be removed in later versions of libev, so better update to the new API early than late.&lt;/p&gt;

&lt;p&gt;EV_COMPAT3 backwards compatibility mechanism
The backward compatibility mechanism can be controlled by EV_COMPAT3. See “PREPROCESSOR SYMBOLS/MACROS” in the EMBEDDING section.&lt;/p&gt;

&lt;p&gt;ev_default_destroy and ev_default_fork have been removed
These calls can be replaced easily by their ev_loop_xxx counterparts:&lt;/p&gt;

&lt;p&gt;ev_loop_destroy (EV_DEFAULT_UC);
ev_loop_fork (EV_DEFAULT);&lt;/p&gt;

&lt;p&gt;function/symbol renames
A number of functions and symbols have been renamed:&lt;/p&gt;

&lt;p&gt;ev_loop         =&amp;gt; ev_run
EVLOOP_NONBLOCK =&amp;gt; EVRUN_NOWAIT
EVLOOP_ONESHOT  =&amp;gt; EVRUN_ONCE&lt;/p&gt;

&lt;p&gt;ev_unloop       =&amp;gt; ev_break
EVUNLOOP_CANCEL =&amp;gt; EVBREAK_CANCEL
EVUNLOOP_ONE    =&amp;gt; EVBREAK_ONE
EVUNLOOP_ALL    =&amp;gt; EVBREAK_ALL&lt;/p&gt;

&lt;p&gt;EV_TIMEOUT      =&amp;gt; EV_TIMER&lt;/p&gt;

&lt;p&gt;ev_loop_count   =&amp;gt; ev_iteration
ev_loop_depth   =&amp;gt; ev_depth
ev_loop_verify  =&amp;gt; ev_verify&lt;/p&gt;

&lt;p&gt;Most functions working on struct ev_loop objects don’t have an ev_loop_ prefix, so it was removed; ev_loop, ev_unloop and associated constants have been renamed to not collide with the struct ev_loop anymore and EV_TIMER now follows the same naming scheme as all other watcher types. Note that ev_loop_fork is still called ev_loop_fork because it would otherwise clash with the ev_fork typedef.&lt;/p&gt;

&lt;p&gt;EV_MINIMAL mechanism replaced by EV_FEATURES
The preprocessor symbol EV_MINIMAL has been replaced by a different mechanism, EV_FEATURES. Programs using EV_MINIMAL usually compile and work, but the library code will of course be larger.&lt;/p&gt;

&lt;p&gt;GLOSSARY&lt;/p&gt;

&lt;p&gt;active
A watcher is active as long as it has been started and not yet stopped. See WATCHER STATES for details.&lt;/p&gt;

&lt;p&gt;application
In this document, an application is whatever is using libev.&lt;/p&gt;

&lt;p&gt;backend
The part of the code dealing with the operating system interfaces.&lt;/p&gt;

&lt;p&gt;callback
The address of a function that is called when some event has been detected. Callbacks are being passed the event loop, the watcher that received the event, and the actual event bitset.&lt;/p&gt;

&lt;p&gt;callback/watcher invocation
The act of calling the callback associated with a watcher.&lt;/p&gt;

&lt;p&gt;event
A change of state of some external event, such as data now being available for reading on a file descriptor, time having passed or simply not having any other events happening anymore.&lt;/p&gt;

&lt;p&gt;In libev, events are represented as single bits (such as EV_READ or EV_TIMER).&lt;/p&gt;

&lt;p&gt;event library
A software package implementing an event model and loop.&lt;/p&gt;

&lt;p&gt;event loop
An entity that handles and processes external events and converts them into callback invocations.&lt;/p&gt;

&lt;p&gt;event model
The model used to describe how an event loop handles and processes watchers and events.&lt;/p&gt;

&lt;p&gt;pending
A watcher is pending as soon as the corresponding event has been detected. See WATCHER STATES for details.&lt;/p&gt;

&lt;p&gt;real time
The physical time that is observed. It is apparently strictly monotonic :)&lt;/p&gt;

&lt;p&gt;wall-clock time
The time and date as shown on clocks. Unlike real time, it can actually be wrong and jump forwards and backwards, e.g. when you adjust your clock.&lt;/p&gt;

&lt;p&gt;watcher
A data structure that describes interest in certain events. Watchers need to be started (attached to an event loop) before they can receive events.&lt;/p&gt;

&lt;p&gt;AUTHOR&lt;/p&gt;

&lt;p&gt;Marc Lehmann &lt;a href=&quot;mailto:libev@schmorp.de&quot;&gt;libev@schmorp.de&lt;/a&gt;, with repeated corrections by Mikael Magnusson and Emanuele Giaquinta, and minor corrections by many others.&lt;/p&gt;

</description>
        <pubDate>Mon, 29 May 2017 00:00:00 +0800</pubDate>
        <link>http://www.94geek.com/blog/2017/libev-manual-zh-cn/</link>
        <guid isPermaLink="true">http://www.94geek.com/blog/2017/libev-manual-zh-cn/</guid>
      </item>
    
      <item>
        <title>我认为更好的管理github pages blog</title>
        <description>&lt;p&gt;使用jekyll也有好几年了，说实话其实jekyll + markdown的方式真的没有cnblogs等这种专门的平台来的方便。至少纯粹从写blog的角度出发，在目前的互联网用户体验大环境下，冷静思考这种方式，真的挺差。&lt;/p&gt;

&lt;p&gt;以前，在改blog风格之前，因为没有使用jekyll的plugins，所以我还是启用了github pages服务的jekyll服务。但是这次因为图片管理的这个plugin，已经不能再启用github pages的jekyll服务了（因为github禁止第三方的plugins），所以只能启用直接嵌入静态文件的方式来执行。那么问题就来了，整个站点的site是目录和站点的原信息目录，到底怎么解决它们之间的问题？&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;更多的做法&quot;&gt;更多的做法&lt;/h3&gt;

&lt;p&gt;我也搜了一下，更多的做法是这样的：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;在github上开一个project作为pages服务的project；&lt;/li&gt;
  &lt;li&gt;在这个project上开启一个分支gh-pages，因为这是github默认的blog服务分支；&lt;/li&gt;
  &lt;li&gt;当你写blog的时候，checkout到master分支，然后开始写，写完后build；&lt;/li&gt;
  &lt;li&gt;checkout到gh-pages分支，将master中的site目录合并到当前分支；&lt;/li&gt;
  &lt;li&gt;commit gh-pages分支，再commit master分支；&lt;/li&gt;
  &lt;li&gt;结束&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这也是一种办法，但是对于我来说受不了的是：一个目录中文件有冲突。一个文件夹存在了多个功能，区分这些功能的办法竟然是我们使用git的分支来达到目的。虽然这样也可以，但并不能有效的去解决一个问题，或者说我一直要check一个问题：就是我当前到底在哪个分支下？显然，对于有神经质的我来说，这种办法明显不切实际。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;我喜欢的办法&quot;&gt;我喜欢的办法&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;一个目录就一个用处，多个功能我宁愿开多个目录；&lt;/li&gt;
  &lt;li&gt;不要把功能都合并到一起，显然这样在日常维护中很难执行，能分即分开；&lt;/li&gt;
  &lt;li&gt;做事的流程要分开，比如我写blog的时候，我就只要照顾到写blog就可以了，当我准备发布的时候，我只要照顾到发布就可以了。两者之间不要切换来切换去；&lt;/li&gt;
  &lt;li&gt;自动化，比如发布，最好是一个脚本直接搞定；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以我重新设计了一种办法：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;将上面的一个文件夹管理一个blog的方式直接换成2个文件夹，一个只管source的源信息目录，一个管理静态站点，也就是元信息build后生成的site的文件夹；&lt;/li&gt;
  &lt;li&gt;因为blog本质上变成了2个文件夹，所以github上也直接申请两个project，一一对应；&lt;/li&gt;
  &lt;li&gt;调试blog可以在source中进行，source中完成后，cp其中的site目录到我们的静态站点目录；&lt;/li&gt;
  &lt;li&gt;直接commit两个project到github即可；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以有了这样的一个流程脚本：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd 94geek #切换到静态站点proejct
git checkout gh-pages #确保目前在gh-pages分支，github只支持这个分支
cd ../source/ #切换到源目录
rm -rf  _site #删除上一次的site目录
jekyll build #编译当前的source
cp -rf _site/* ../94geek/  #cp当前次生成的site到静态project
git add ./ #加入更新的blog
git status #查看一下当前的状态对不对
git commit -am&quot;upload log&quot; #提交，这里信息被写死了，其实你可以使用参数来指定
git push #同步到github
cd ../94geek #切换到静态project
git add ./ #加入新增的blog静态文件
git status #查看当前静态project的状态
git commit -am&quot;update blog&quot; #提交
git push #同步
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将这个文件放入静态project和source同等级目录下，每次写完blog后只要简单的执行这个脚本即可。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;这种方式有几个好处：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;清晰：目录和功能各司其职；&lt;/li&gt;
  &lt;li&gt;简单：写blog和发布没有任何的确认，其实只要管理好source就可以了，别的都是自动执行；&lt;/li&gt;
  &lt;li&gt;统一：写blog和发布blog不混乱，各管各的，不需要分心来处理；&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sun, 28 May 2017 00:00:00 +0800</pubDate>
        <link>http://www.94geek.com/blog/2017/mgr-blog/</link>
        <guid isPermaLink="true">http://www.94geek.com/blog/2017/mgr-blog/</guid>
      </item>
    
      <item>
        <title>jekyll图片管理插件</title>
        <description>&lt;p&gt;使用jekyll搭建github的pages服务已经很多年了，虽然写的blog不是特别多，但在使用的过程中难免还是遇到了很多的问题。在所有这些问题中，几乎所有的问题都被解决了。但有且只有一个问题几乎无解：图片管理。使用jekyll的程序员几乎都搭配markdown，但是markdown对于图片的管理，简直就是可以用一坨屎来形容。&lt;/p&gt;

&lt;h3 id=&quot;以前问题&quot;&gt;以前问题&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;通常在markdown中，引用图片都是使用标记来进行。但是引用的图片路径往往是一个问题。优先了jekyll，那么本地的编辑器可能就无法显示和预览；优先了本地预览，那么markdown上传到jekyll后路径是一个问题。&lt;/p&gt;

&lt;p&gt;那么我们最常用的就是这种办法：因为markdown引用图片最常用的就是http形式的地址引用。所以前提就是你必须先有一个稳定的图床，然后上传图片，获取地址，再把地址贴入markdown中。这种方式我受不了的地方在于中间插入图片或者修改图片多次的话，往往需要长时间的停下来先弄图片，再写markdown，整个思路会受到很多的影响。有时候弄完图片已经没心情再写东西了。&lt;/p&gt;

&lt;p&gt;那么有没有一种办法来解决这个问题呢？&lt;/p&gt;

&lt;p&gt;首先我们想到了一种办法，把图片直接放到某个文件夹里面，上传到github，但是这样的做法还是会在本地编辑器和jekyll中满足一个。另外一个办法，就是把图片和markdown放在同一个文件夹，这样就没有路径问题了，直接用文件名就可以引用图片。但是这种办法满足了编辑器，在jekyll build的时候，jekyll对于_post目录下的文件只处理markdown文件，不会处理别的文件。看上去这条路也不通了。&lt;/p&gt;

&lt;p&gt;那么到底有没有别的办法呢？&lt;/p&gt;

&lt;h3 id=&quot;我的解决方案&quot;&gt;我的解决方案&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;其实能想到的方案上面都已经全部想到了，但是不管怎么去解决，在jekyll和本地编辑器中往往只能满足一个，两个能同时兼顾的就没有。但是对比上面的几种方案，最靠谱的貌似还是最后一种** markdown和图片同目录 ** 但是在同目录jekyll又不管，幸好jekyll提供了插件功能。&lt;/p&gt;

&lt;p&gt;jekyll的插件有很多种，具体的请查看 &lt;a href=&quot;http://jekyllcn.com/docs/plugins/&quot;&gt;jekyll插件科普&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;回到我们的问题，我们的问题其实已经很清楚了，就是在jekyll解析markdown到html的同时，将同目录的静态文件全部cp到生成的html的目录。这样markdown文件生成的html和静态资源文件又在一个目录下了，这样就可以避免目录的问题了。&lt;/p&gt;

&lt;p&gt;在这些插件的hooks中，我们选择了 :posts :post_write 这个hooks，因为这个hooks是在markdown已经被解析，并且被写入磁盘以后发生的。这个时间点正好就是我们想要的这个时间点。那么我们现在就是只要实现这个hooks就可以了。所以就有了下面的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Jekyll::Hooks.register :posts, :post_write do |doc|
# Minify HTML files after site build
#  gulp = File.join(site.source, 'node_modules', '.bin', 'gulp')
#  system &quot;#{gulp} minifyHTML --silent&quot;
#
#Kernel.puts &quot;11111111111111111111&quot;
#Kernel.puts doc.path

pn = Pathname.new(doc.path)
basedir  = pn.dirname 
dest_path =File.join(doc.site.config[&quot;destination&quot;] , doc.url)
Dir.foreach(basedir) {|x| 
    if !(x.start_with?(&quot;.&quot;))
        if !(x.end_with?(&quot;md&quot;) || x.end_with?(&quot;markdown&quot;))
            stmp = File.join(basedir,x)
            dtmp = File.join(dest_path,x)
            Kernel.puts stmp
            Kernel.puts dtmp
            FileUtils.cp(stmp,dtmp)
            Kernel.puts &quot;copy static file from #{stmp} to #{dtmp}&quot;
        end
    end
}

end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将这个文件保存到_plugins目录下，随便给一个文件名即可。再次运行jekyll server就可以看到这个hooks被执行了。&lt;/p&gt;

&lt;p&gt;具体:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;项目源码: &lt;a href=&quot;https://github.com/xvhfeng/jekyll-markdown-image&quot;&gt;github project&lt;/a&gt;&lt;br /&gt;
2 如何使用：&lt;a href=&quot;https://github.com/xvhfeng/blog-source&quot;&gt;blog源码&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;缺点&quot;&gt;缺点&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;这个解决方案并不是万能的，它也有自己的缺点。目前使用下来，缺点有几个：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;只支持markdown和静态文件同目录的情况；&lt;/li&gt;
  &lt;li&gt;对于jekyll的permalink的配置一定要正确，千奇百怪的配置不一定可用，我的配置是/blog/:year/:title/，注意，最后那个目录分隔符 “/” 一定要带;&lt;/li&gt;
  &lt;li&gt;对于post中的markdown转html的时候，列表页的显示也有问题，如果列表页上会显示摘要或者是文章的一部分内容，而恰巧这部分在列表上显示的内容中有图片的引用，这样这个图片也会有显示问题。因为图片其实是在markdown生成的html目录，而列表页是一个单独的目录，所以图片路径是取不到的。这部分其实是可以完善的，但是对于我来说，这部分几乎很少用到，我也就没管了；&lt;/li&gt;
  &lt;li&gt;因为你使用了自定义的plugin，而github为了安全考虑是不支持自定义plugin的，所以对于使用自定义的用户来说，只能在本地build完了站点后，把_site目录下的文件签入github，使用静态文件的方式来提供blog的服务；（PS，好处时自定义的插件可以让你为所欲为，有失必有得）&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 26 May 2017 00:00:00 +0800</pubDate>
        <link>http://www.94geek.com/blog/2017/blog-image/</link>
        <guid isPermaLink="true">http://www.94geek.com/blog/2017/blog-image/</guid>
      </item>
    
      <item>
        <title>关于csdn的采访</title>
        <description>&lt;p&gt;前几天在csdn的《程序员》杂志上发表了一篇关于我写的&lt;a href=&quot;/2015/DFS.html&quot;&gt;dfs&lt;/a&gt;的文章。借
着这次机会，csdn的编辑钱兄邀请我上4月份的sdcc深圳场做一个演讲。为此，他们还专门
采访了我。刚开始他们准备让我在几个主题里面挑一个，后来我和他们说，这些主题我都可
以，他们可以随便选。钱兄就建议来一个综合的。我觉得这样也可以。然后就有了下文：&lt;/p&gt;

&lt;p&gt;&lt;b&gt; CSDN：请简单介绍下您和目前的工作，以及关注的领域。&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;徐海峰：大家好，我是阅文集团（由盛大文学和腾讯文学整合而成的集团）的首席架构师徐
海峰，大家可以叫我大嘴。我目前的工作主要在分布式存储、分布式计算、公司内部框架的
架构等工作。今年我还给自己加了一个工作项：推动我们的一些项目在GitHub上开源。&lt;/p&gt;

&lt;p&gt;对于我自己来说，我一般比较关注分布式存储和分布式计算、高性能运算等。其实业务系统
的框架架构等工作很久之前就做过了，只是后来更关注分布式计算，所以现在我把它当成了
副业，我的主业主要还是高性能运算。&lt;/p&gt;

&lt;p&gt;&lt;b&gt; CSDN：您有着10年的互联网开发经验，您是如何走上技术这条路的？&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;徐海峰：为什么看见这个问题，我第一个想到的字就是“熬”？其实确实也只能说是熬吧。
开始的时候是技术不太过关，我就开始熬技术方面的。当时也傻乎乎的，办法也不多，就想
到买几本书看看。然后没想到看书竟然后来发展成了我的一个习惯。这10年来，我一直看书
，我霸占了我家的一个半书架，里面都是我的书。这还不算上被我淘汰掉的很多书。在技术
行业就是这样，等你技术ok了，你的机会就来了。还是那句话，熬着，磨练自己，机会只留
给有准备的人。&lt;/p&gt;

&lt;p&gt;&lt;b&gt; CSDN：您现任职于由盛大文学和腾讯文学整合而成的阅文集团，也曾在携程、5173工作
过，可否简要回顾下自己的工作历程，有什么心得和体会可分享？&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;徐海峰：先说一下这3家公司的区别吧！现在的公司阅文集团，因为我的自主性大一些，所
以可以干预很多地方，虽然现在属于刚刚开始，但底子算是比较好的；Ctrip，我当时去的
时候就是磨练心智的，Ctrip在当时比较古板，技术也是相对挺low的（所以待了11个月实在
受不了了，必须要走了）；5173的话比较自由，很多事情都可以很简单的完成，而且同事之
间关系很不错，我们到现在都一直在一起玩，我也在里面待的最久。&lt;/p&gt;

&lt;p&gt;这么多年，我认为公司对人的关系挺大的，判断一家公司的好坏，不能单一的看付多少报酬
，虽然这是第一选择，但是还要看给你做多少的事情，你想做什么，到你能做什么，再到你
能实现什么是有一个很大的跨度的。如果这家公司能给你想法上的自由，行动上的支持那就
应该待的久一些。&lt;/p&gt;

&lt;p&gt;&lt;b&gt; CSDN：您目前是阅文集团的首席架构师，此前也是携程和5173的架构师，在每一个阶段
中您对架构是怎样的理解？以及您对于架构师是如何定义的？&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;徐海峰：我个人觉得架构挺简单的。我一直和我下面的人说，做架构要比用架构简单，因为
你是游戏规则设定者。你既是运动员还是裁判，你再干不过人家那就没法原谅了。另外，架
构好比画圆，不管你怎么画，最后总归要圆回来。当然一个架构的好坏还得看业务模式、人
员素质、使用便捷性等因数。&lt;/p&gt;

&lt;p&gt;一个好的架构一般不是靠短期内做出来的，都是一步一步改出来，或者是总结前面发生的事
情再写出来的。&lt;/p&gt;

&lt;p&gt;我现在说得好像挺简单，不过也有迷茫的时候，记得当时我做一个单点登录都要想很久。在
5173时，我认为技术就是无敌的，那时候刚刚接触分布式计算等技术，一切都是崭新的，充
满着诱惑，几乎每天都干到很晚。后来到了Ctrip发现原来技术差一些也行？其实在Ctrip我
算是闭关，在那里看了很多的书，有技术也有人文类的。一年时间也想通了很多的问题。&lt;/p&gt;

&lt;p&gt;架构不仅和技术有关，还和人有关。一个架构除了完成既定系统任务还要兼顾开发者等。现
在我的同事经常说我喜欢在技术上“强奸”别人。其实完全不是这样，只是我想过几乎所有
的方式/方法，而且我选择了我认为最好的那种。既能做到架构的简洁，又能做到对于开发
者快速的接受。像架构这种东西，不是越灵活越好，我恰恰相反的认为，架构这种东西，特
别是需要靠别人编程配合完成的东西，越限制死越好。&lt;/p&gt;

&lt;p&gt;架构师的定义，我还是觉得他既是裁判又是运动员吧。当架构师不难，难的是怎么让运动人
忘记你裁判的身份。我一直在公司说的一句话：&lt;/p&gt;

&lt;p&gt;我真正的成功在于你们都应该不知道有我这个人存在。特别是在系统上线后，如果在没有我
的情况下，系统能正常运行，那我才算是牛。我也一直朝着这个目标努力。目前来看，在
Ctrip、5173这两个地方都实现了这个目标，我希望在阅文集团也能实现。&lt;/p&gt;

&lt;p&gt;&lt;b&gt; CSDN：您认为具备哪些素质才能成为是出色的架构师？&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;徐海峰：首先是要忍。一个公司的架构或者是技术线并不是一朝一夕来决定的，它有很多的
历史原因，也有很多的无奈之举。所谓的存在即合理，千万不要上来就去大刀阔斧的砍下去
，对于一些觉得不顺眼、不那么完美的事情要学会去接受，等待时机再干掉它；&lt;/p&gt;

&lt;p&gt;其次是要自我进化。作为架构师，一般都是在公司内部技术比较牛的人。现在这个世界是日
新月异的变化着，作为一个公司的技术领航人员，在技术上必须要保持一定的先进性。时刻
需要进化自己，不断的补充新的知识；&lt;/p&gt;

&lt;p&gt;再次代码能力不能丢。我一些朋友也是做架构师的，他们对我现在还在写代码觉得很吃惊，
而我对他们现在不写代码但是确是架构师也很吃惊。一个架构师连代码都不写了，难道就做
做Slides？画画图？然后开几个演讲？这就太颓废了一些。不仅对公司不好，对自己也不负
责任啊。&lt;/p&gt;

&lt;p&gt;最后要学会忍受寂寞。牛的人都是寂寞的。往往一个挺好的事情，当你满怀信心的和同事们
说的时候，他们一脸的迷茫。几乎是没有人点头的，更不要说受到支持。这时候就要学会忍
受这种“寂寞”，并学会去处理这种“寂寞”。&lt;/p&gt;

&lt;p&gt;总的来说，我还是认为架构师和管理者还是不太一样。架构师必须要首先做事情，然后再做
人，当然做事情的时候也要追求合理的方式方法。&lt;/p&gt;

&lt;p&gt;&lt;b&gt; CSDN：目前，阅文集团的架构是怎样的？可否简单介绍下阅文集团整体架构的一些架构
特点？以及作为架构师，您的工作重点有哪些？&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;徐海峰：说实话，阅文的架构还是比较乱的。毕竟是3家公司合并成的。目前我们的架构硬
性上来说简直可以开展览馆了。数据库有：MySQL、SQL Server、Oracle等；应用层有：
Java、PHP、C#、Python等，而业务系统还分属在不同的机房。这是没办法的事情，毕竟以
前是分属3家公司，现在合并了，这种历史预留问题是我们要面对的也是必须要解决的。&lt;/p&gt;

&lt;p&gt;现在我们决定把数据库从Oracle和SQL Server上迁移到MySQL上。应用层基本上以后就只有
Java和PHP了，Java做Service，PHP做页面，各取所长吧。目前我们已经在推进这个事情了
，去年先把内容统一了，今年开始统一应用层和应用层的数据库等。毕竟饭要一口一口吃，
罗马也不是一天建成的。这种“乱”的现象正在一步一步的被改进，我相信用不了多久就能
统一吧。&lt;/p&gt;

&lt;p&gt;我在阅文的时间其实刚刚2年，我是2014年4月15日入职的，那时候还叫腾讯文学。这两年来
，我一直在负责分布式存储和分布式计算的工作。第一年我一个人写了一个分布式文件系统
（DFS），后撰写的文章也发表在《程序员》2016年4月期上。然后抽空算是帮忙吧，贡献了
一个编程框架，叫Albianj。Albianj主要做分布式业务系统用，自带了分布式事务、OEM、
数据路由等功能，它可以让你用单机开发部署到线上，更改几个配置文件立刻就变成分布式
系统来运行，目前也在我们公司大规模的使用。上文中说到的业务系统的迁移就是使用
Albianj来完成的。后来配合内容中心的统一，我还写了一个id生成器，这就是我要在SDCC
2016深圳站之架构技术峰会上讲的，中间因为调度的需要，还开发了一个调度系统，比当当
开源的那个功能要多一些（当当的海峰会不会杀了阅文的海峰？）。从去年7月份开始，我
也开始接管团队，我们团队在做几个东西：一个RPC的通讯协议、Nameserver、LogDB等工作
。&lt;/p&gt;

&lt;p&gt;我今年的工作重点应该不会放在具体的实现上了，我更多的会去做一些系统整体性的架构设
计等工作。还有就是开源的工作，我也一直在不停的推进这件事情。目前来看，上面提到的
几个东西都会开源。到时候欢迎大家去GitHub，一起讨论这些方案和实现。&lt;/p&gt;

&lt;p&gt;&lt;b&gt; CSDN：您如今是如何安排自己的新技术学习、研发团队管理、编程、生活等时间的？
&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;徐海峰：对于学习，我恰恰和别人相反。我不太去关注新的技术，我倒是挺喜欢那种老掉牙
的技术的。开始我是写C#的，后来我尽然去写了C。其实就像我喜欢用VIM或者是Emacs而用
不惯Sublime Text一样，我对于新的东西到不是那么的感冒。我一直觉得现在技术不管怎么
变化，都是从那些老掉牙的技术演化而来的，金矿还是在老掉牙的技术中。比如现在分布式
文件系统的存储技术，几乎和操作系统原理中的磁盘管理一模一样，只是加了很多平衡性、
一致性之类的算法，所以我现在在看汇编。对于汇编，我开始非常抗拒，但前几天的一个系
统Down掉让我重新重视了起来。很多时候，在Online环境中，你根本就是无法Debug，就算
用GDB也仅仅是把Dump文件拿下来，但那次我把源文件给弄丢了，不看汇编不行，所以我还
是下定决定好好的看看汇编。汇编也没有想象中的难，除了繁琐一些，别的都还好。也不知
道是不是我学的不精，还是还没深入下去，没到难的地方。&lt;/p&gt;

&lt;p&gt;管理团队这个事情其实我已近很久没干了。去年开始又需要扮演这个角色了，我才捡了起来
。要说工作嘛，肯定是一个人的时候舒服，人多了黑管理者带来了比较多的乱七八糟事情。
我一般管理分为2部分：&lt;/p&gt;

&lt;p&gt;首先在生活上，我会给与一定的照顾。对于一些可以变通的地方我也不是那么的强求。互联
网公司嘛，本来就是比较自由的，而且我们的工作还不太算是简单的业务实现，而是需要一
定的创造性的，所以在这个上面我一直比较松。另一方面，在技术上，我被我同事称为“魔
鬼”。我同事说我发起火来六亲不认（PS：我已经很少发火了）。我规定对于屡教不改的我
要惩罚。这算是我这里的“私刑”。第一次屡教不改的错误，解决方案抄100遍，第二次200
，依次类推。我觉得犯错误不要紧，谁能无过？关键是你是不是真的用心去记住这个错误。
我对待错误的态度是，第一次叫做不知道，第二次叫做不小心，千万不要有第三次，第三次
在我这里就是故意。既然你故意，那我就用故意的办法治你。我是公司内第一个让下属抄“
100遍”的上司。100遍这种惩罚虽然恶心、下流、卑鄙，但效果却是出奇的好。凡是抄过
100遍的人，至今还没有人抄200遍。编程和生活我还是放在一起说吧。因为我爱人和我说，
在我的生活中，没有生活。我是把爱好玩着玩着最后玩成工作的人。高中的时候就对编程很
感兴趣，后来找工作的时候发现除了编程我啥都不会，所以最后爱好变成了工作。也不知道
这到底算不算是我的优势，我可以花更多的时间在编程上。我觉得时间是一定的，所以你的
时间花在了这里，那么那里就会少一块。我经常性把编程和生活搞乱在一起的。我会在洗澡
的时候想问题，我会在出去玩的时候带着电脑，甚至去年7月份前同事结婚，我们一起去马
尔代夫，早晨起来我还坐在阳台上写代码。完了被朋友笑称：在扔美金写代码。也因为这样
，我觉得我无形中比别人多挤出来了一些时间吧！开始时没有什么效果，但是久而久之，效
果很明显。现在确实感觉知道的比一般的人多一些，贵在坚持啊！&lt;/p&gt;

&lt;p&gt;好好准备，安安心心坚持，机会还是留给有准备的人。&lt;/p&gt;

&lt;p&gt;&lt;b&gt; CSDN：在本次SDCC 2016（深圳站）架构峰会上，您想分享的话题是？&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;徐海峰：这次我分享一个主题：id生成器。说到id生成器，没听过的会很诧异，这也好意思
拿出来说？知道一点的，会和你说Snowflake算法。Twitter的Snowflake算法确实不错，但
是我认为它还能做得更好。我们的id生成器是在统一内容时发现要用。以前我们也是用数据
库的解决方案，但统一内容中心的时候，数据库方案已经不能用了。当然我们也参考了
Snowflake，但是都被否决了。最后我决定自己来开发一个。开始没觉得有多难，其实本身
确实也不是很难，但是需要考虑的相关问题却要很多。一个小小的id，仅仅自是一个uint64
的值，里面却包含了很多的信息和对于取舍的考量。此次分享具体的包括：我们前期怎样使
用数据库生成id、我们为什么放弃Snowflake算法、再到后来我们自己的算法，以及此后我
们特有的排序id算法，来听一下你就知道。&lt;/p&gt;

&lt;p&gt;&lt;b&gt; CSDN：您最期待在SDCC 2016（深圳站）架构峰会上看到哪些内容？&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;徐海峰：我还是想看到更多的自创的东西，而不是使用的心得什么的。这不是说使用的心得
什么的不重要，也很重要，可以让很多人少走很多的弯路。但是技术的发展毕竟是靠创新的
。使用仅仅只是站在了巨人的肩膀上，我更喜欢看到更多的巨人自己站出来。&lt;/p&gt;

&lt;p&gt;对于技术的纵向选择，我这个人并不挑食，只要是好的都可以接受。不管你是运维、DB、架
构，这些都可以相互借鉴。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;这是我得第二次被采访，上一次被采访是去年的11月份，sacc对我做了演讲之前的采访。
相比上一次采访，这一次显然更加的放松一些，说的话也多了一些。&lt;br /&gt;
这些年来，技术圈内也是出现了很多的炒作现象。不是说不能炒作，而是说不能过分的
炒作。虽然我也认为我们现在的年代已经不是“酒香不怕巷子深”了。但是，我们也要在
一定的限制内来运行炒作。而不是泛泛而谈，硬是把死人给炒活了、把原本只是一个
程序员水平给炒成cto。&lt;/p&gt;

&lt;p&gt;PS:话说上首页的感觉还是不错的！！！ &lt;br /&gt;
&lt;img src=&quot;csdn.jpg&quot; alt=&quot;csdn&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 16 Apr 2016 00:00:00 +0800</pubDate>
        <link>http://www.94geek.com/blog/2016/csdn-staffer/</link>
        <guid isPermaLink="true">http://www.94geek.com/blog/2016/csdn-staffer/</guid>
      </item>
    
      <item>
        <title>腾讯文学内容中心id生成器的设计与实现</title>
        <description>&lt;h3 id=&quot;名词解释&quot;&gt;名词解释&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;dfs: 分布式文件系统，具体的实现请参考 [这里] (/2015/DFS.html “分布式文件系统”)&lt;/li&gt;
  &lt;li&gt;idc: idcreator的缩写，是指id生成器本身&lt;/li&gt;
  &lt;li&gt;albianj: 我们开发的一个分布式业务统一框架 具体实现请查考&lt;a href=&quot;/2015/albianj.html&quot; title=&quot;分布式统一框架&quot;&gt;这里&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;数据路由: 业务系统中经常会用到的分库分表操作&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;摘要&quot;&gt;摘要&lt;/h3&gt;

&lt;p&gt;我们设计并实现了一个分布式的id生成器。它是基于linux操作系统的，面向我们几乎所有
的业务操作，为我们所有的业务提供对象的唯一标识，也为我们的错误号提供标示。虽然
id生成器被设计成运行在廉价的linux机器上或者是混搭在别的业务机器上，但是它依然为
我们提供了良好的可访问性和可伸缩性。后期因为业务的需要，我们也让id生成器为我们
提供了良好的完整性和一致性。&lt;/p&gt;

&lt;p&gt;虽然id生成器比较简单，但是它确实出自于我们对于搭建一个分布式业务系统的实际需要
和我们对于搭建分布式业务系统的一个理解。它和我们搭建的dfs或者是albianj一样，并
不是出自于某些论文或者是高大上的理论。它更多的是被用来解决我们在系统中碰到的实
际问题，所以对于我们来说，它比某些开源或者是论文的更加的具有适应性、维护性和
可用性。&lt;/p&gt;

&lt;p&gt;id生成器已经被部署到我们的内容中心系统中，最初的版本已经稳定的运行了9个月，中间
没有一次的down机事故。现在它也被用来改造我们以前的老系统，改造我们从oracle或者
是mssql迁移到mysql的过程。目前为止，我们的id生成器已经部署了2套，一共6台机器，
它为我们源源不断的输出我们需要使用的业务id。&lt;/p&gt;

&lt;p&gt;本文档中我们会最终讨论我们现在id的生成方法和后期我们处理强增长模型id的解决办法,
还有现在的id生成办法和以前id的比较、我们使用id的方法等。当然，我们着重要介绍的
还是我们id生成器在分布式业务系统中的架构和特性。&lt;/p&gt;

&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;

&lt;p&gt;我们开发idc的初衷是确实碰到了业务大数据的问题。我们的书、章、章节等动辄百万、千万、
甚至上亿的记录需要被最后存储到数据库中。就目前的数据量，如果使用简单的方案，只
能寻求商业数据库的支持，但对于一个互联网公司来说，商业的数据库会大大的增加成本
。我们继而选择了使用开源的mysql来作为底层的关系型数据的存储。但因为mysql的单表
压力远远无法满足我们现实的压力需求。我们只能对业务数据进行了拆分，继而变相的对
我们提出了数据路由的功能。&lt;/p&gt;

&lt;p&gt;虽然数据路由的整体实现由&lt;a href=&quot;/2015/albianj.html&quot; title=&quot;分布式统一框架&quot;&gt;albianj&lt;/a&gt;负责并且实现，但
是数据路由的规则必须由我们根据业务设定。而设计数据路由的前提是我们必须要存在一个可以作
为&lt;b&gt;数据路由标识&lt;/b&gt;的载体。同样是路由，如果是web的负载均衡路由一般就会使用客
户端ip等作为标识，但是类似的解决方案并不适用于我们的数据存储，因为数据库的路由
除了存储数据之外，还要考虑可以通过标识能定位位置，继而还能读取这些记录。所以我
们必须具有一个明确的、不会改变的、唯一的标识来配合数据路由。这个标识就是我们这
里要介绍的id。&lt;/p&gt;

&lt;p&gt;我们为此设计并且实现了整个的idc。考虑到目前我们的现实情况，该idc除了具有高性能
的tcp接口和自定义的api外，我们还为此提供了一个语言无关性的http接口。和tcp的api
不一致之处在于tcp会单纯的返回id，而http的接口将会访问一个json对象，继而通过json
可以获取id或者是判断是否出现了访问错误。&lt;/p&gt;

&lt;p&gt;虽然idc是分布式的结构，但是和dfs之类的存储类分布式系统相比还是差别非常大的。对
于dfs中比较强调的数据一致性、数据可恢复等等要求，在id生成器中基本上不需要太多的
考虑。这是因为存储需要保存我们提交的内容，而id它只需要和时间成正相关性即可满足
要求。但idc也需要遵循统一的分布式系统的一些规则。idc同样要满足分布式系统的高可
用性、高稳定性、单点无关性等要求。&lt;/p&gt;

&lt;p&gt;在互联网行业，前期的考虑总觉得已经满足了需求。但是变化永远大于计划。在我们的idc
中，后来的需求还需要满足生成带有业务状态的id。这是我们的idc和别的idc有差别的地
方。在章节的顺序上，我们需要一个定步长并且只可递增不可乱序的id来满足我们的排序
要求。就这个要求，打破了我们前期对于idc的设计，我们对于idc增加了状态的管理，并
且设计了新的算法来满足此需求。&lt;/p&gt;

&lt;h3 id=&quot;设计目标&quot;&gt;设计目标&lt;/h3&gt;

&lt;p&gt;按照往常一样，我们也对我们的idc提出了一些设计上的原则和目标。遵守这些原则、达到
这些目标可以让我们的idc能更好的为我们所用。和以前的dfs和albianj完全不一样，idc
的目标确实比较多，但是它的目标一般都比较的清晰。因为相比它们两个已经设计完的组
件，idc的功能相对简单而单一，对于idc更多还是在性能和扩展性上存在一些实现上的难
度。&lt;/p&gt;

&lt;p&gt;在上面的介绍中，我们重点介绍了我们的idc的背景和大概的用处，以及一些idc必须遵循
的规则。但是我们并没有说明我们的idc的设计构想。所以，下面我就讲一下我们的设计构
想。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;唯一性。从我们的idc中生成的id必须是具有唯一性的。并且是全站唯一的id。这样的id
可以很方便的得到它的业务信息。不管是对于数据路由还是对于业务排错都会具有一个清
晰的、可维护的id；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;短。idc生成的id必须要足够的短。最好是一个uint32的值，最长也不能长于uint64.一
来对于长于uint64的值存储将会是一个麻烦，另外运算也是需要借助移位等算法，对于编程语
言还无法使用语言内置的类型系统；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生成的速度要足够快。这大家都很好理解。没有一个程序是不追求速度的。而且对于我
们的业务系统来说，id的服务是对应于一个分布式的结构。在可用性、可维护性上相比本
地生成或者是数据库生成会有一次的tcp交互时间。所以我们要确保在业务系统正常运行的
情况下，idc能快速的给业务系统提供服务。尽可能的减少因为生成id所需要花费的时间；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;id的运算要足够简单。这是吸取以前使用字符串来作为id的时候的一个教训。不管是应
用程序还是数据库，使用字符串作为id是可以“为所欲为”，但是在运算上不管是排序还
是hash都会比int类型的数据慢很多，或者是多步骤。所以我们生成的id要尽可能的满足于
简单，最好就是一个数字，这样计算可以直接进行，而且可以直接使用内置简单类型；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;id不仅仅是一个无意义的id，而是一个带有业务性质的id。这应该是一条“毁三观”
的目标。因为我们的数据库教科书上有一条明确的规则：实体id最好是不要带业务性质的
，仅仅起标识作用的id。但是这也仅仅只是写在教科书上罢了。其实真的很误人子弟，或
者说是跟不上时代。在现实系统中，一个没有业务意义的id在分布式系统中几乎是寸步难
行。不仅仅是不好维护，而且还很不好扩展，不能自由的做数据路由，也不能给开发者或
者是维护者一个明确的“望文生义”的提示。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;部分自定义位。idc中生成的id除了具有业务意义外，还必须具有一定的空间提供给业
务系统来进行自定义。业务系统中的业务路由也是强业务性质的，和业务结合的相当的紧密
，可以这么说，几乎每一个业务都会有一个不一样的数据路由的定制化功能。而我们需要
满足这些定制化功能。满足定制化功能的前提就是idc中生成的id并不是一个成品，而是一
个半成品。开发者可以通过这个半成品id进行业务加工，使其变成一个完整的、符合当前
业务需求的id；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可识别。可识别，也就是可读性。我们认为这是id作为一个标识最应该具有的一个特性
。一个只可计算机识别不可人类肉眼识别的信息几乎是没有任何用处的。我们的idc中生成
的id必须不是那种只为了计算机而存在的。开发应用程序、维护应用程序的都是我们开发
者或者是维护者，本质上说都是人。我们把开发和维护作为头等大事来对待，而机器运行
程序，这是我们程序的附属品，只是碰巧我们写了一个机器可以运行起来的程序而已。首
要条件还是人类友好。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对索引友好。这其实是我们开发idc第二个重要的原因。如果不要求索引，字符串是最
好的解决方式。但是字符串在排序上太差了，而这也会影响到数据库的速度。使用字符串
，插入数据的时候会对数据库的索引进行随即写入，而数据库最快的速度应该是尽量的避
免随机写，把随机写变成顺序写这样来提高速度。所以我们的idc中产生的id必须要满足这
个要求，也就是说，从一定意义上，idc中生成的id必须是有顺序的，是可以把对数据库
的随机写优化成顺序写的；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面说了很多我们对于idc生成的id的各种设计目标。这仅仅是我们对于这个idc系统
一部分的思考和实践。但是对于我们idc本身，我们也会有一定的设计目标或者说是设计
规则，用来满足我们的idc对于业务系统的支撑。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;高可用性。我们的idc必须具备高可用性的特点。因为我们的idc被设计成分布式的方式
，又是被构建在廉价的linux普通服务器上，所以这些服务器具有易损坏的属性。但是我们
的idc集群不能因为服务器的损坏而不能为业务系统提供服务。我们必须设计一种或者多种
规则来规避单机down机的问题，从而达到整个集群的高可用；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据一致性：起初这并不是idc的一个必须的属性。因为idc被设计为无状态，仅仅与时
间相关，所以这部分被忽略。但是因为现实业务的需求，我们需要带有状态的idc，故数据
的一致性便成为了整个idc集群的一个标准特性，也是必须被满足的特性；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;单机承受能力：根据我们整个的业务系统中的业务压力，
引申出来我们的集群需要能支撑的一个量，这基本上就是我们的整个idc集群的最基础的应
对量。鉴于我们业务的发布量和发布态时间，我们的idc集群在前期基本上需要支持每秒5k
的QPS。在业务大量的导入后，预估计这个量在万的级别，应该不会超过百万。所以划分到
我们的单台机器，基本上在1w／s左右的qps即可扛住整个站点的压力；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后，也是最重要的一点是，我们的idc必须能在经受住我们系统的同时，可以方便对idc
自定义规则。这是我们比较关心的，毕竟业务随时在变，数据随时都在增加，而我们的应
对策略也一直都在变更。在整个的idc架构中，我们必须要保证留取一块地方，给我们的生
成算法服务，它可以方便的进行自定义，可以方便的嵌入或者重写算法。&lt;/p&gt;

&lt;h3 id=&quot;架构&quot;&gt;架构&lt;/h3&gt;

&lt;p&gt;为了达到我们的设计目标，我们对于我们的idc进行了总体上的架构，并且对其架构进行了
细化切分。细分后的idc基本上等同于一个简单的tcp／http服务器。我们也对idc整体的功
能性上进行了细化。目前来说，我们主要的点有以下几个组成：&lt;/p&gt;

&lt;h4 id=&quot;高可用架构&quot;&gt;高可用架构&lt;/h4&gt;

&lt;p&gt;对于一个分布式的集群来说，高可用永远是一个不可回避的话题，也是一个必须达到的话
题。我们的idc也不可避免的需要高可用的架构设计。对于idc来说，相对来说数据比较少
，而且相互之间的关系也没有dfs那么的紧密。起初我们设计的idc压根就是无状态的集群
。所有的id都与也仅仅与时间有关。所以我们的idc被设计成平行的无状态结构。从架构上
来说有点像memcached，服务器没有任何的管理服务器或者是状态服务器来为这些idc集群
提供负载均衡、状态管理和故障转移。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;idc.png&quot; alt=&quot;idc&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是和别的系统一样，业务总归是千变万化的，很多时候计划是赶不上变化的。没有多久
我们就需要一种强一致性的id，我们对于原有的idc集群需要一个重新的考量。为了不影响
现有idc的工作，我们在idc上增加了一个弱化的管理节点，它仅仅只是会管理集群中的idc
，而不会像dfs一样还要做一些负载均衡和故障转移的工作。所以这个增加的节点其实不能
叫做manager，而仅仅只是一个agnet的角色。因为我们这样一个特殊的agnet的架构，所以
对于我们的一致性问题也提出了一定的挑战，因为我们不能使用manager来平衡或者是分配
相同请求的master机器了。因为idc集群还是和以前一样都是平行的架构设计，所以就会带
来一个所有的idc都是master的问题。我们也确实使用一种算法规避了这个问题。具体的请
参考“一致性问题”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;idc2.png&quot; alt=&quot;idc2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于一个没有管理节点的集群，我们原定使用的负载均衡的方式很简单，就两种。一种是
轮训，另外一个是一致性hash。但是一致性hash还是比较少使用的，特别是后来我们使用
了一致性算法后，几乎就不需要一致性hash饿的存在了，轮询就已经可以满足我们的要求
了。因为我们已经不需要知道master机器在哪里，或者是让一台idc机器通过选举变成
master了。这对于系统的简单行和idc集群的性能是一个很大的提升。而我们这个负载均衡
是在客户端实现的。所以对于我们的客户端来说，也是省掉了很多的东西，只需要做一个
简单的哨兵来去维护轮询的idc即可。&lt;/p&gt;

&lt;h4 id=&quot;id的可视化问题&quot;&gt;id的可视化问题&lt;/h4&gt;

&lt;p&gt;说到id的可视化问题，有过id生成算法使用经验的同学肯定会想到snowflake算法。
snowflake算法其实是一种偏向计算机的算法。它通过将一个数转变成二进制，然后通过计
算机的移位算法来解决问题。这也是大家经常会想到的解决方法。这种方式将计算速度看
的非常重要，而忽略了了一个问题：那就是人的问题。系统是由人写出来的，也是由人来
维护的。一个好的代码不仅仅只是写出来给计算机来执行的。而应该是写出来给人看的，
好巧不巧的偏偏海能给计算机运行。所以我们并没有使用类似于snowflake的算法，而是使
用了十进制来生成ID。&lt;/p&gt;

&lt;p&gt;十进制，我们人类经常使用的一种记述算法。相比二进制，它更贴近我们的生活。以至于
到了我们人类一眼或者谁靠着简单的风格位数就可以区分出来数字的意义。这正是我们想
要一种方式，也可以称之为感觉。因为根据我们的经验，一般的id都是在数据路由中使用
，这个时候其实对于系统来说是二进制还是十进制没有什么差别，因为计算机都能处理，
我们人也不会去看；但是当我们维护人员要去看这个id的时候，往往都是在系统出现问题
的时候，这时候时间就会显得异常的宝贵，再加上当时哪种紧张的心理，如果这个id不是
哪种一眼就能看出来意思的id的话，往往会有很大的打击作用，进而会让维护人员产生更
大的焦虑症状。这并不是我们想要的。我们可以看一下以下的例子来感受一下：&lt;/p&gt;

&lt;p&gt;&lt;b&gt;9223  3720 3257 7650 688&lt;/b&gt;这样的一个数字看起来还算相对整齐，但在系统中，它
看起来往往是这样的一个样子&lt;b&gt;9223372032577650688&lt;/b&gt;,这就已经有点凌乱的。压根不
知道表示的是什么鬼。然而，按照snowflake算法，其实它的二进制应该是这样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0111 1111 1111 1111 1111 1111 1111 1111
0000 0001 0001 0000 0100 0000 0000 0000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是我们还是看不懂它表示的是什么意思，我们再对它进行移位计算，分别计算出来它的
各个位置上的值，其实它的真正的表示的值是这样的&lt;b&gt;2199023251472-264-0&lt;/b&gt;(中间的
－是为了方便区分添加的)。敢问你现在是一种什么样的心情？&lt;/p&gt;

&lt;p&gt;但是是不是这种二进制算法就没用？其实也不是。我们也使用了这种算法的变种，我们将
它使用在我们的排错异常号上，具体的可以请参考虾面的使用id章节。&lt;/p&gt;

&lt;h4 id=&quot;id模型&quot;&gt;id模型&lt;/h4&gt;

&lt;p&gt;在我们的业务系统中，我们的id最主要的作用还是作为数据路由的一个标识。所以我们的id
其实最终决定了我们的业务系统数据库存储是不是会均衡或者是趋向于均衡。这就决定了我们
必须要采用一种算法来确定我们生成的id是线性的。又因为我们的id需要对数据库索引的
友好，我们放弃了随机数的算法，而是使用了简单轮询的算法来生成id。&lt;/p&gt;

&lt;p&gt;首先，放弃随机数算法是因为本质上我们没有办法确定随机数会对数据库索引友好。虽然
随机数可以满足线性这么的一个条件，但是先后生成的随机数的大小是我们没有办法决
定的,也就是说又50%的可能性后生成的那个随机数会比前面那个随机数小。这样的概率
显然太大，并不适合我们的要求。那么我们只能选择轮询这种算法。&lt;/p&gt;

&lt;p&gt;其次：我们不会存储轮询的哨兵的值。这个取决于我们的id并不仅仅更我们的轮询数有关，
还和我们的时间有关。我们的id是在时间的基础上增加轮询数来共同决定一个id的主体，
所以对于我们来说，对于轮询数的单调一致性要求并没有想象中的高。所以也会出现下面
的这种情况：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;429497-9998-01-1-00
429498-9999-01-1-00
429498-0000-01-1-00
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个id中，第一部分是时间，第二部分就是轮询数。所以我们的id可能会出现这样的一个
情况：正如第二、第三两个id一样，因为递增到了一个临界值，又为了避免位数的溢出，
我们只能选择将id值的轮询数归0.这样的话，我们也可能会出现部分对索引不友好的情况
（后面生成的id小于前面生成的id）。但是这种情况只是小概率时间，因为这种情况只会
出现在1s之内，当跳过1s后，因为时间的真大，数的前半部分会变大，所以整个数也会变
大。这样就又回到了单调递增的条件下了。&lt;/p&gt;

&lt;p&gt;这种id适合做分库分表，但是对于单表的排序id并不适合，所以我们还提供了严格递增的
算法。&lt;/p&gt;

&lt;p&gt;严格的递增算法其实和轮询递增算法差不多，只是在我们的轮询数上做了一点点的改动。
我们把单调递增改成了秒内递增，溢出不饭号或者是从定向的方法。比如，生成的id号是
这样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;429496-0000-01-1-00
429497-0000-01-1-00
429498-0000-01-1-00
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样的号，会随着前面的时间或者是中间的轮询数单调递增。永远不会出现变小的问题。
但是这仅仅是单台情况下的表现，如果是分布式的情况下，也会出现问题。所以这个id
同样不适用于严格的递增情况。后面我们会讲到碰到需要严格的递增的时候我们的
解决办法。&lt;/p&gt;

&lt;p&gt;这种id明显的看出来不适合按照轮询数来做数据路由。对于这种id，增长的曲线角度永远
是45，而且是每秒都会重新开始，所以就会导致这些id大概率的倾向于值小的路由。&lt;/p&gt;

&lt;p&gt;综上所述：我们目前的两种id增长曲线如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;4.png&quot; alt=&quot;idc4&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;简单唯一性算法&quot;&gt;简单唯一性算法&lt;/h4&gt;

&lt;p&gt;唯一性在单机的系统中还是一个可以容易解决的事情。但是在分布式的系统中，唯一性对
于架构来说往往是一个挑战。终其原因会有很多，但是最大的问题就是：在分布式的系统
中没有一个精确的时钟。没有了精确的时钟，很多的解决方案就会失去作用，而且失去作
用的不仅仅是唯一性，可能的单调性也是一个问题。&lt;/p&gt;

&lt;p&gt;一般解决这个问题的方案是在服务器集群中放一台时间服务器，所有的机器都会每隔一个
心跳时间去这台时间服务器上校验和更新时间。但是就算是再频繁的同步，这种精度也就
是在毫秒甚至是秒级别了。不会有比这个更精确的度了。所以严格的来讲，这不能作为很
好的一个解决办法。&lt;/p&gt;

&lt;p&gt;我们的idc集群因为是分布式的也同样的存在这个问题。而我们也采取了一定的策略来去避
免这个问题。我们将我们的id设计成和时间、机器相关。这样一个带上机器编号的id，能
保证在整个的系统中唯一了。以此，我们的id方案为：&lt;/p&gt;

&lt;center&gt;
&lt;b&gt;时间戳－轮询数－机器id－数据库位&lt;/b&gt;  
&lt;/center&gt;

&lt;p&gt;这种解决办法确实解决了这个问题。但是也有一个副作用。因为考虑到我们的id要放下很
多的业务性质属性，所以留给我们的机器id位就会变的很少。我们现在的情况下留给机器
id位的长度仅有一位，也就是说：我们的idc集群最多支持10台机器。看上去10台机器很少
，但是我们单机的承压在每秒10k。所以基本上我们集群的id生成量在每秒100k。这仅仅是
一种类型的数量，在我们的idc中，一种支持100种类型的id，所以我们整个集群的量大概
在每秒1kk。&lt;/p&gt;

&lt;h4 id=&quot;idc保存数据算法&quot;&gt;IDC保存数据算法&lt;/h4&gt;
&lt;p&gt;该来的还是会来的，只是设计的时候时候未到。我们开始的时候并没有考虑严格的带有递
增id的需求。但是这个需求在后面没多久就出现了。先来看看我们遇到的问题：我们在三
方内容合并的时候，为了迎合原来的各业务系统，不打破他们的使用规则，所以我们的章
节信息在正常的数据路由id使用的基础上，增加了一个排序id，这个id必须是严格递增的
，因为它代表了章节的前后次序。但是在我们的系统结构中，如下图，我们对于mysql使用
了读写分离的策略，那么问题来了，就算我的同步速度非常快，无限快，它也只是趋向于
实时，但并肯定就是实时的。也就是说同步是肯定要时间的，唯一的差别就是时间的长短
。这也就意味着可能会出现下面的情况：我们在master中插入一个正确编号的章节A，这时
候A还没同步到slave数据库，我们又要插入章节B，这时候我们需要一个编号，我们从
slave数据库中读取一个编号，这个编号是当时slave数据库中最大的编号，我们再加上步
长，其实这个编号和刚刚插入的章节A的编号是一样的。然后再插入master数据库，这时候
章节A和章节B的编号就会发生冲突。在我们的系统中，就会出现章节重复的问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;7.png&quot; alt=&quot;idc7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这确实是一个架构上的问题。本质就是写入和读取并不是来自于同一个数据库，所以造成
了数据上的误差。这种问题的解决办法业余很多，以前我们使用的一种办法是在修改数据
或者是需要严格数据一致性插入数据的时候，都要在master数据库中先load一下数据，其
实我们设计的albianj确实也有这个功能，这样做的好处是简单明了。坏处是破坏了架构的
一致性，后期也有可能在代码上引起混乱。而且就一个排序号，这个对我们来说是可以避
免去master数据库load数据的，所以我们采取了另外一个方式：让idc支持这样的一个id生
成。&lt;/p&gt;

&lt;p&gt;总体上来说，这样的需求也不是很难解决。但是因为章节是挂载到一本书的，所以这个id
只要在一本书内唯一并且按步长自增就可以了。没有必要做到全局唯一自增。这样的需求
其实更增加了我们的难度。如果只是全局内单调自增，那么我们只要记录下来一个id就可
以了；现在是每一本书都需要一个id序列，所以idc要为每一本书都记录下来它的id状态。
记录每一本书的算法采用了skiplist。我们将书的id作为唯一的key，当前编号和一些源信
息作为value。这样我们就构建了我们书数据中心的整个索引。每次更新或者查询都只是一
个skiplist的操作而已。&lt;/p&gt;

&lt;p&gt;我们的skiplist通常情况下都是常驻内存的，所以搜索的时候性能并不是问题。而且我们的
item经过测算是一个很小的值，大概只有10b级别。所以256mb的内存就可以存放大概1kw的
item数据，所以不管是内存还是io都不是我们这个skiplist的瓶颈和消耗点所在。&lt;/p&gt;

&lt;p&gt;多本书的问题解决后，我们解决状态的问题。我们给idc配备了一个后台的线程，每隔一个
固定的时间就会触发skiplist的IO化。IO线程会判断skiplist中的item的状态，将短期内
update或者是新增的item刷入到磁盘中。这样状态就会被保存下来。保存了状态后，每次
idc重启都会去判断是否有skiplist的持久化文件，如果有文件，就会先加载这些文件到内
存。如果没有文件，那么就去同逻辑组的idc中随便选取一台，同步skiplist的文件。然后
再加载。这种办法简单，有效。并不存在数据不一致的状态。这是因为我们在生成id的算
法上也会规避这个id状态的问题。&lt;/p&gt;

&lt;h4 id=&quot;有状态id算法&quot;&gt;有状态id算法&lt;/h4&gt;
&lt;p&gt;对于状态id的基本上情况下面已经介绍清楚了，但是我们到底怎么去生成这个id？这是我
们需要考虑的一个问题。其实仔细的分析这个id，貌似就是一个zookeeper就能解决的问题
。但是我们前面还有欠债，因为我们的idc已经上线，并且我们的idc是平行设计，并没有
master的角色。所以这就给我们提出了新的问题，怎么样在全是master的情况下，能生成
一个唯一id？&lt;/p&gt;

&lt;p&gt;提到zookeeper，我们肯定知道它决定谁是master的算法，也就是选举算法。这个算法被我
们采用，但是我们采用这个算法并不是产生一个master的idc，而是产生一个最大的id。如
下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;3.png&quot; alt=&quot;idc3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们将zookeeper的集群启动选举变成一个常态。将每一次的请求都泛化成选举操作。当然
这仅仅出现在这种严格id的情况下，并不影响别的id的生成。所以它也并不会因为特殊的
需求而给整个集群带来性能的颠簸。我们平行的idc设计导致了每一台机器都可能会接收到
请求，所以我们干脆把这些接收到请求的机器全部当成master机器，然后他们会根据客户
端传输来的bookid得到目前当前机器上的id值，先预加上步长，然后会发送请求到集群中
的每一台idc，接到请求的idc也会根据bookid得到当前的id，然后加上步长，直接返回给
发送端机器，发送端机器拿到id后会和自己的做对比，选取最大的id作为当前这次批号的
id，然后把这个id再次通知到集群中的idc，他们会根据这个id和当前的本机id比较，如果
传输来的id更大，更新当前的id；反之不更新，直接返回。发送端接收到整个通知ok的消
息后，返回给客户端当前的id。这个id即是当前最大的id。&lt;/p&gt;

&lt;p&gt;有时候会发生一本书同时发章节的情况，这样我们idc集群可能会有2台机器同时接收到同
一id的申请，也就是所谓的并发，这样也不是不能处理。首先，从业务上来说，对于同一
个id的处理是不是可以被接受？如果不可以，那么我们在业务层就需要使用分布式锁的方
式来规避这个问题；如果业务上这种同时发生也是可行的，那么到我们的idc端是有可能碰
到前后不一致的情况，因为我们的idc集群对于同时到达的同一id的请求，采用的是“类彩
票”方式，也就是所谓的“比手速”，谁先进入idc集群谁就是前面的那一个，后进入的就
是后面那一个。这并不是idc的问题，而是idc其实也无法决定谁先到达这个难题。&lt;/p&gt;

&lt;h4 id=&quot;id长度问题&quot;&gt;id长度问题&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;数据路由: 343429497-9998-01-1-00
有状态id：20160423-000-00-000100
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;看一下这两个数字，对于一个uint64类型的值来说，最大的数是1844 6744 0737 0955 1656，
应该是20位，而我们的数字缺只有19位，少了一位这是为什么呢？&lt;/p&gt;

&lt;p&gt;这其实是idc的一个坑，很多时候并不会碰到，但是当碰到的时候可能就已经来不及了，而
且现象会非常的奇怪。这个问题就是曾经被老生常谈的：溢出。我们的千几位是被时间占
用的，而时间会随着年代的久远越来越多。就算我们不以1970－01-01作为起始时间点（其
实我们也是这样做的），我们按照站点上线的时间点作为一个起始点，那么一个uint32的
值也是有限的，如果我们取的时间精度再高一些，值会更大。而其实溢出会更快，因为我
们看一下uint64的最大值，最高位是18XXXXXXXX,所以只要最高到19XXXXXX就会溢出。所以
为了避免这个问题，我们只能把整个id的值缩短到不管怎么变化，都不会过它的最高第二
位。这样，就永远也不会溢出了。所以我们想到了直接缩掉一位，也就是将最大值直接取
1/2，这样就不会溢出了。&lt;/p&gt;

&lt;p&gt;这里还提到一个问题，这样设计的idc到底可以用多少时间？其实这个时间非常的长，用
int32最大的值来算，基本上我们的idc使用的年限在175年左右。到176年的时候就会溢出。&lt;/p&gt;

&lt;h3 id=&quot;id生成器的id和传统id的比较&quot;&gt;id生成器的id和传统id的比较&lt;/h3&gt;

&lt;p&gt;传统上，我们经常会使用数据库的自增int作为对象的唯一标识，稍微符合现在的系统设计
原则的就会使用GUID／UUID等字符串唯一标识，再进步一些就会自定义一个字符串的唯一
标识，这个字符串不仅仅满足唯一性还会增加一些业务的标识。不管使用何种的算法，它
都和我们对于id的需求又较大的差距，那么这些差距到底表现在哪些方面呢？&lt;/p&gt;

&lt;h4 id=&quot;和数据库生成id相比&quot;&gt;和数据库生成ID相比&lt;/h4&gt;

&lt;p&gt;数据库生成id的方案现在基本上只有2种方案：一种是直接int自增，步长为1；另外一种也
是int自增，但是步长可以自定义，一般步长定义成数据库表的个数。&lt;/p&gt;

&lt;p&gt;int自增、步长为1的方案其实是扩展性最差的方案。首先：它的事务性要求很高，插入数
据和获取id必须在一个事务中操作，否则id就有偏差的可能。第二个步长固定，无法对应
现在互联网大数据的分库分表操作。这个方案一般都会被用在传统企业的数据库设计中，
因为他们的数据库一经设计基本上不太会变更。&lt;/p&gt;

&lt;p&gt;那么第二种步长可自定的方案(如下图)是对上一种方案的优化。将步长设置成数据库表的
数量可以解决当前的数据库分库分表的问题，也减小了数据库的压力。当步长严重依赖于
数据库的表数量，在扩展的时候还需要更改表的设置，从运维和dba的角度来说，其实相当
的不方便。而且对于业务来说，因为步长固定，又为了数据的均衡性，只能选择loop的算
法来进行数据路由。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;9.png&quot; alt=&quot;idc9&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;和字符串id相比&quot;&gt;和字符串id相比&lt;/h4&gt;

&lt;p&gt;使用字符串的方案一般也是有两种：一种是GUID／UUID，另外一个是自定义字符串。GUID
／UUID一般情况下是不太可能会碰撞的，所以唯一性倒是能保证的。对于数据路由，一般
是将GUID／UUID做一个hash，然后取模，使用GUID／UUID的很少使用loop等数据路由算法
，也不太好做。又因为GUID／UUID没有业务性质，所以也很难按照业务类型做数据路由。
和数据库生成id一样。所以也在GUID／UUID的基础上产生了自定义字符串id的算法。&lt;/p&gt;

&lt;p&gt;自定义字符串id一般使用的也是32位长度id。只是可以根据自己的实际情况来给这32位长
度的字符串赋值。这种的字符串的算法一般会使用本地生成，带上机器信息、类型、时间
戳、顺序号。这样的id可以保证唯一性，也可以满足复杂的数据路由功能。但是没有办法
排序，对数据库索引也不友好。&lt;/p&gt;

&lt;p&gt;不管是GUID／UUID还是自定义字符串，总体来说都不是很对我们的需求，我们将它们的优
缺点罗列了一个表：如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;序号&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;优点&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;缺点&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;自定义性强，可以根据实际情况自己定义&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;String有点太长了&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;可以轻松的实现复杂的数据路由算法&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;String截取部分内容或者是整体的hash运算&lt;br /&gt;都会有额外的消耗&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;自定义算法id有人类识别度，&lt;br /&gt;而且后期运维也方便&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;UUID/GUID没有业务性质，人类识别度不高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;本地生成，无事务性、也无延时&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;一样无可排序性，对索引和写入都不友好&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;我们使用id的方法&quot;&gt;我们使用id的方法&lt;/h3&gt;

&lt;p&gt;idc服务器生成的id在我们的系统中已经被广泛的使用。在我们的业务系统中，所有的业
务对象的id都是由idc生成的。我们使用这些id进行了我们的数据路由的设计和实现。目前
的数据路由基本上在单数据库1000张表起。我们的idc和albianj相互配合，完成了我们整
个复杂业务层的数据层。&lt;/p&gt;

&lt;p&gt;我们也不单单将id使用在数据路由中，还将id使用在排错中。这也是一种以前几乎很少会
使用的解决方案，目前使用下来，运行良好。还未出现异常情况。&lt;/p&gt;

&lt;p&gt;下面我们将讨论我们的id使用方案，这仅仅是我们使用的方法而已，并不是标准。根据idc
的id，可以很方便的根据自己的业务来决定自己的数据路由规则。&lt;/p&gt;

&lt;h4 id=&quot;数据路由&quot;&gt;数据路由&lt;/h4&gt;

&lt;p&gt;idc生成的id，不管是自增id还是章节唯一id，至少都保证了3个我们经常会使用的元素：
时间戳、序号、库位。在业务系统中，经常会被使用的数据路由算法有几种：根据时间划
分数据库和表，比如将一个月分成3部分，1-10的放在01表中、11-20放在02表中、21号以
后的放在03表中，这样每个月就产生3张表；使用序号的方式有很多，最常见的是使用取模
或者是最后几位确定，比如我们的分表位是3位长度，那么可以表示0-999的数据，这样可
以把一张表分成1000张分表，获取分表位的数值，根据这个数值推出来这个数据应该放在
那张表中，再插入数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;5.png&quot; alt=&quot;idc5&quot; /&gt;
&lt;img src=&quot;6.png&quot; alt=&quot;idc6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至于库位。其实就是数据库的编号。这个编号也是经常会被忽视的地方。原因是很多时候
，我们其实也可以根据分表位的数值来推导出来应该将数据放在那个表里。但是这种方法
的问题在于。如果我们要扩展数据库，那么我们只有导数据，将数据先重现平衡，然后再
提供服务的一种办法。虽然我们也可以使用“类二叉树”的方法将导数据的量减小一半，
但是依然挺烦人的。所以我们抛弃了这种做法，我们在我们的id上留了2个位置，专门来给
我们的数据库指定位置。这样我们的数据库在扩展的时候可以不用动我们的历史数据。这
也是我们特殊的业务决定的。一般的业务可能不适合使用这套方法。因为这样的做法可能
会将热数据全部放到新加上来的db中，而我们没有这个问题。所以我们在设计的时候可以
不用考虑这个问题&lt;/p&gt;

&lt;p&gt;还有一种数据路由的方式是根据类型来划分。这也是经常需要使用的一种方法。所以我们
在自增的id上增加了类型的位，已方便数据层使用类型进行数据路由。但是我们在章节唯
一id上却没有相应的类型位，这是因为章节自增id其实是我们id的一个垂直细分，也就意
味着只要使用这种id就一定明确的知道你在使用哪种类型的数据，所以这样的意思就是暗
示使用者可以明确的知道正在使用的id用途。所以并不需要类型id。&lt;/p&gt;

&lt;h4 id=&quot;异常排错&quot;&gt;异常排错&lt;/h4&gt;

&lt;p&gt;这应该是我们特有的一种id的使用方法。它主要解决两个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将系统内部的异常或者是错误信息给报给了客户，引起信息外泄，导致数据不安全；&lt;/li&gt;
  &lt;li&gt;定义一个全局的类似于linux的errno的机制，后期需要维护这个列表的成本太高，并
不是一个很好的解决方案；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们经过仔细的考虑，我们觉得对于一个系统来说，过滤异常只要知道异常类型就可以了；
对于异常信息，不应该报给客户，或者说少报给用户，但是系统却必须完整的记录下来，以
方便后期的排查。所以其实非常的简单，对于我们来说，我们只要构建一个桥梁，将报给用户
的信息和系统内部的信息连结上，然后提供给用户的只是简洁的信息，系统记录详情即可。
这样我们就设计了一个这样的id，它甚至不需要使用十进制，二进制的snowflake算法都一样
能达到目的。因为它只要唯一性，只要能和系统内部一一对应起来即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;8.png&quot; alt=&quot;idc8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们使用这种策略，当发生问题的时候，我们只需要问客户要一个id号，然后使用这个id
号到我们的系统中去查询，即可确定用户当时到底发生了什么问题。这个id仅仅相当于这
个用户一个系统级的sessionid而已。&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;我们重新设计和实现了一个完整的、分布式的id生成器。它设计的过程中，我们也碰到了
各种各样的为题，但是最后我们还是一一解决了。&lt;/p&gt;

&lt;p&gt;这个id生成器相对来说还是简单的，但是通过这次的idc设计和实现，我们觉得我们最大的
收获是不迷信“高大上”的算法和“高大上”的公司，踏踏实实的根据自己的业务来自己
实现一个符合我们自己业务的id生成器，即保证了我们的业务系统顺利的完成上线，又锻
炼了我们解决实际问题的能力。&lt;/p&gt;

&lt;p&gt;这个id生成器到目前为止已经在公司内部稳定的运行了9个月多，中间没有一次出现问题和
异常，可以说我们很好的完成了任务，也更深层次的解决了分布式系统的问题。&lt;/p&gt;
</description>
        <pubDate>Mon, 23 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://www.94geek.com/blog/2015/idcreator/</link>
        <guid isPermaLink="true">http://www.94geek.com/blog/2015/idcreator/</guid>
      </item>
    
  </channel>
</rss>
